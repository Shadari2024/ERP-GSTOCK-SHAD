from django.shortcuts import render,redirect,get_object_or_404
from django.views import View
from .models import *
from django.db.models.functions import TruncMonth
from django.views.decorators.csrf import csrf_exempt
import json
from django.db.models.functions import Abs
from django.db.models import Case, When, F, Sum
from django.http import FileResponse
from django.views.decorators.http import require_POST
from django.core.mail import send_mail
from django.contrib.auth.hashers import make_password
from django.utils.crypto import get_random_string
from django.contrib import messages
from django.http import HttpResponse
from django.template.loader import get_template
from xhtml2pdf import pisa
from collections import defaultdict
import tempfile
from weasyprint import HTML
from decimal import Decimal
from django.core.mail import mail_admins
from io import BytesIO
from django.contrib.auth.hashers import make_password
from django.contrib.auth.models import Group
from .utils import envoyer_mail_bienvenue 
from django.core.mail import EmailMultiAlternatives
from django.template.loader import render_to_string
from django.conf import settings
import openpyxl
from openpyxl.styles import Font, Alignment, Border, Side
from django.core.mail import EmailMessage
from django.core.paginator import Paginator
from django.http import JsonResponse
from django.contrib.auth.decorators import login_required,user_passes_test
from django.db import transaction
from decimal import Decimal
import csv
import tempfile
from django.utils.timezone import now
from django.db.models import Q
from django.db.models import Sum,F,Count
from .utils import bilan_caisse_du_jour
from django.contrib.auth import logout
from django.contrib.auth.decorators import login_required, user_passes_test
from datetime import datetime, timedelta
from weasyprint import HTML
from django.template.loader import get_template
from django.http import HttpResponse
from weasyprint import HTML
import tempfile
from .models import InventairePhysique
from django.contrib.auth.decorators import login_required
import json
import base64
from django.views.generic.edit import DeleteView
from django.urls import reverse_lazy
from STOCK.notifications import *
from STOCK.ml.prophet_utils import *
# Create your views here.





from django.http import JsonResponse
from .models import TauxChange, Parametre  # ajuste l'import selon ton app
from django.contrib.auth.decorators import login_required

@login_required
def taux_change_api(request):
    devise_cible = request.GET.get('devise', 'USD').upper()  # s√©curit√© : normalise la saisie
    try:
        parametres = Parametre.objects.get(user=request.user)
        devise_principale = parametres.devise_principale.upper()
    except Parametre.DoesNotExist:
        devise_principale = 'FC'  # valeur par d√©faut

    # Si la devise demand√©e est identique √† la devise principale
    if devise_cible == devise_principale:
        return JsonResponse({'taux': 1.0})

    try:
        # Chercher un taux direct
        taux = TauxChange.objects.get(
            devise_source=devise_principale,
            devise_cible=devise_cible
        ).taux
        return JsonResponse({'taux': float(taux)})

    except TauxChange.DoesNotExist:
        try:
            # Chercher un taux inverse et l'inverser
            taux_inverse = TauxChange.objects.get(
                devise_source=devise_cible,
                devise_cible=devise_principale
            ).taux
            return JsonResponse({'taux': round(1.0 / float(taux_inverse), 6)})

        except TauxChange.DoesNotExist:
            return JsonResponse({'error': 'Taux non disponible entre %s et %s' % (
                devise_principale, devise_cible)}, status=404)



class ClientView(View):
    template_name ='clients/liste.html'
    
    def get(self,request):
        Clients = Client.objects.all()
        context ={
        'Clients':Clients
    }
        paginate_by = 5
    
        return render(request,self.template_name,context)
    
      
      
    def post(self,request):
        
        return redirect("ClientTableau")
    
#ajout client
class FormulaireViewClient(View):
    template_name = "clients/formulaire_client.html"
    
    def get(self, request):
        return render(request, self.template_name)
    
    def post(self, request):
        nom = request.POST.get('nom')
        email = request.POST.get('email')
        telephone = request.POST.get('telephone')
        adresse = request.POST.get('adresse')

        # V√©rifier les doublons
        if Client.objects.filter(email=email).exists():
            messages.error(request, "Cet e-mail est d√©j√† enregistr√©.")
            return redirect('ajoute_client')

        if Client.objects.filter(telephone=telephone).exists():
            messages.error(request, "Ce num√©ro de t√©l√©phone existe d√©j√†.")
            return redirect('ajoute_client')

        # Si tout est OK, on cr√©e
        try:
            client = Client.objects.create(
                nom=nom,
                email=email,
                telephone=telephone,
                adresse=adresse
            )

            # Message de succ√®s
            messages.success(request, "Client ajout√© dans le syst√®me")
            return redirect('liste_client')
        
            # Envoi du mail de bienvenue
            subject = f"Bienvenue {client.nom} chez OBED SERVICE"
            from_email = settings.DEFAULT_FROM_EMAIL
            to_email = client.email
            context = {'nom': client.nom, 'email': client.email}
            html_content = render_to_string('emails/bienvenue.html', context)
            msg = EmailMultiAlternatives(subject, '', from_email, [to_email])
            msg.attach_alternative(html_content, "text/html")
            msg.send()

        except Exception as e:
            messages.error(request, f"Erreur lors de l'enregistrement : {e}")

        return redirect('liste_client')


class Detailsclient(View):
    template_name='clients/clientdetails.html'
    def get(self,request,my_id):
        Detaicl = get_object_or_404(Client,id=my_id)
        context = {
            'obj':Detaicl
        }
        
        return render(request,self.template_name,context)
    
    def post(self,request):
        return redirect('ClientTableau')
      
      
#suppression client
class SupClient(View):
    def get(self,request,my_id):
        sup =get_object_or_404(Client,id=my_id)
        sup.delete()
        if sup:
            try:
                messages.success(request,"supression avec succes")
            except Exception as e:
                messages.error(request,f"erreur de supression {e}")
        return redirect("liste_client")
     
    def post(self,request):
        return redirect("liste_client")
         
    
#modification client

class ModifClient(View):
    template_name = "clients/Modificatclient.html"
    
    def get(self,request,my_id):
        mod = get_object_or_404(Client,id=my_id)
        context = {
            "obj":mod
        }
        
        return render(request,self.template_name,context)
        
    def post(self,request,my_id):
        client = get_object_or_404(Client,id=my_id)
        client.nom = request.POST.get('nom')
        client.email= request.POST.get('email')
        client.telephone =request.POST.get('telephone')
        client.adresse = request.POST.get('adresse')
        client.save()
        messages.success(request,"client modifier ")
        return redirect('liste_client')
        
        
# PDF GENERATION CARTE CLIENT
def generate_pdf(request, my_id):
    client = Client.objects.get(id=my_id)
    template_path = 'Gclient/Clientpdf.html'
    context = {'obj': client}

    template = get_template(template_path)
    html = template.render(context)
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = 'attachment; filename="carte_identite.pdf"'
    
    pisa_status = pisa.CreatePDF(BytesIO(html.encode('utf-8')), dest=response)
    
    if pisa_status.err:
        return HttpResponse('Erreur lors de la g√©n√©ration du PDF')
    return response

    
    
# classe categorie pour affiche et voir
class CatView(View):
    template_name ='categorie/liste_cat.html'
    
    def get(self,request):
        categories = Categorie.objects.all()
        paginator = Paginator(categories, 10)  # 10 cat√©gories par page
        page_number = request.GET.get('page')
        page_obj = paginator.get_page(page_number)
        return render(request,self.template_name, {'page_obj': page_obj})
      
    def post(self,request):
        pass
    


      
    #formulaire cat
class FormulaireCat(View):
    template_name = "categorie/form_cat.html"
    
    def get(self, request):
        cat = Categorie.objects.all()
        return render(request,self.template_name,{'cat':cat})
        
    
    def post(self, request):
        if request.method == 'POST':
            nom = request.POST.get('nom')
            photo = request.FILES.get('photo')  # Important: r√©cup√©rer via FILES

            if nom and photo:
                categorie = Categorie.objects.create(nom=nom, photo=photo)
                messages.success(request, "Cat√©gorie ajout√©e avec succ√®s !")
                return redirect('liste_cat')  # ou la page que tu veux

            messages.error(request, "Veuillez remplir tous les champs.")
        
        return render(request, 'categorie/form_cat.html')
    
    
    
    #ajouter produit 
    
class AjouterProduitView(View):
    def get(self, request):
        categories = Categorie.objects.all()
        return render(request, 'produit/ajouter_produit.html', {'categories': categories})

    def post(self, request):
        nom = request.POST['nom']
        description = request.POST.get('description', '')
        prix_achat = request.POST['prix_achat']
        prix_vente = request.POST['prix_vente']
        stock = request.POST['stock']
        seuil_alerte = request.POST['seuil_alerte']
        categorie_id = request.POST['categorie']
        photo = request.FILES.get('photo', None)

        categorie = Categorie.objects.get(id=categorie_id)

        produit = Produit(
            nom=nom,
            description=description,
            prix_achat=prix_achat,
            prix_vente=prix_vente,
            stock=stock,
            seuil_alerte=seuil_alerte,
            categorie=categorie,
            photo=photo
        )

        produit.save()

        # G√©n√©rer le code-barres apr√®s la sauvegarde du produit
        produit.generate_barcode()

        # Sauvegarder apr√®s la g√©n√©ration du code-barres
        produit.save()

        return render(request, 'produit/ajouter_produit.html', {'categories': Categorie.objects.all(), 'produit': produit})
#etiquette

from django.shortcuts import get_object_or_404
from django.template.loader import get_template
from django.http import HttpResponse
from weasyprint import HTML
def ticket_produit_pdf(request, pk):
    produit = get_object_or_404(Produit, pk=pk)
    parametres = Parametre.objects.first()
    
    # R√©cup√©ration du taux de change USD si diff√©rent de la devise principale
    taux_usd = None
    prix_vente_usd = None
    
    if parametres and parametres.devise_principale != 'USD':
        taux_usd = TauxChange.get_taux(parametres.devise_principale, 'USD')
        if taux_usd:
            try:
                prix_vente_usd = Decimal(produit.prix_vente) * Decimal(taux_usd)
            except:
                prix_vente_usd = None

    template = get_template('produit/ticket_produit.html')
    html = template.render({
        'produit': produit,
        'parametres': parametres,
        'taux_usd': taux_usd,
        'prix_vente_usd': prix_vente_usd,
    })

    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = f'filename=ticket_produit_{produit.id}.pdf'

    HTML(string=html, base_url=request.build_absolute_uri('/')).write_pdf(response)
    return response

    
    #affiche produit
from django.db.models import F
from decimal import Decimal
from STOCK.models import Parametre, TauxChange, Produit
from django.core.paginator import Paginator
from django.shortcuts import render
from django.http import JsonResponse
def produits_list(request):
    search_query = request.GET.get('search', '')
    
    # R√©cup√©ration des produits avec annotation du stock r√©el
    produits = Produit.objects.annotate(
        stock_reel=F('stock')  # Utilise la valeur actuelle de la base
    )
    
    if search_query:
        produits = produits.filter(nom__icontains=search_query)

    # R√©cup√©ration des param√®tres de devise
    try:
        parametres = Parametre.objects.get(user=request.user)
        devise_principale = parametres.devise_principale
        devises_acceptees = parametres.devises_acceptees
    except Parametre.DoesNotExist:
        devise_principale = 'FC'
        devises_acceptees = ['FC']

    # Conversion des prix si n√©cessaire
    devise_demandee = request.GET.get('devise', devise_principale)
    
    if devise_demandee != devise_principale and devise_demandee in devises_acceptees:
        for produit in produits:
            try:
                produit.prix_vente_converti = TauxChange.convertir(
                    produit.prix_vente,
                    devise_principale, 
                    devise_demandee
                )
                produit.prix_achat_converti = TauxChange.convertir(
                    produit.prix_achat,
                    devise_principale,
                    devise_demandee
                )
                produit.devise_affichage = devise_demandee
            except Exception as e:
                print(f"Erreur conversion: {e}")
                produit.prix_vente_converti = produit.prix_vente
                produit.prix_achat_converti = produit.prix_achat
                produit.devise_affichage = devise_principale
    else:
        for produit in produits:
            produit.prix_vente_converti = produit.prix_vente
            produit.prix_achat_converti = produit.prix_achat
            produit.devise_affichage = devise_principale

    paginator = Paginator(produits, 10)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)

    return render(request, 'produit/liste_produit.html', {
        'page_obj': page_obj,
        'devise_principale': devise_principale,
        'devises_acceptees': devises_acceptees,
        'devise_active': devise_demandee,
        'devise_symbols': {'USD': '$', 'EUR': '‚Ç¨', 'CDF': 'FC'}
    })

def produits_search(request):
    search_query = request.GET.get('search', '')
    produits = Produit.objects.filter(nom__icontains=search_query)[:5]

    # Conversion des prix si n√©cessaire
    try:
        parametres = Parametre.objects.get(user=request.user)
        devise_principale = parametres.devise_principale
    except:
        devise_principale = 'FC'

    devise_demandee = request.GET.get('devise', devise_principale)

    results = []
    for p in produits:
        prix_vente = p.prix_vente
        if devise_demandee != devise_principale:
            try:
                prix_vente = TauxChange.convertir(p.prix_vente, devise_principale, devise_demandee)
            except Exception as e:
                print(f"Erreur conversion recherche: {e}")
        
        results.append({
            'id': p.id,
            'nom': p.nom,
            'prix': str(Decimal(str(prix_vente)).quantize(Decimal('0.01'))),
            'devise': devise_demandee
        })

    return JsonResponse({'results': results})
#detail produit
def produit_detail(request, id):
    produit = get_object_or_404(Produit, id=id)
    return render(request, 'produit/detail.html', {'produit': produit})

#commande et article 

@login_required
def creer_commande(request):
    if ClotureCaisse.objects.filter(vendeur=request.user, date_jour=now().date()).exists():
        return render(request, "vente/vente_bloquee.html", {"message": "La caisse est d√©j√† cl√¥tur√©e pour aujourd‚Äôhui."})
    if request.method == "POST":
        client_id = request.POST.get("client")
        paiement = request.POST.get("paiement")
        expiration = request.POST.get("expiration")
        produits = request.POST.getlist("produit[]")
        quantites = request.POST.getlist("quantite[]")
        prix_unitaires = request.POST.getlist("prix_unitaire[]")

        try:
            with transaction.atomic():
                client = Client.objects.get(id=client_id)
                commande = Commande.objects.create(
                    client=client,
                    paiement=paiement,
                    expiration=expiration,
                    vendeur=request.user
                )

                for produit_id, qte, prix in zip(produits, quantites, prix_unitaires):
                    produit = Produit.objects.select_for_update().get(id=produit_id)
                    quantite = int(qte)

                    if produit.stock < quantite:
                        messages.error(request, f"‚ùå Stock insuffisant pour le produit **{produit.nom}**. Stock actuel : {produit.stock}")
                        raise ValueError("Stock insuffisant")

                    # Cr√©er la ligne commande
                    LigneCommande.objects.create(
                        commande=commande,
                        produit=produit,
                        quantite=quantite,
                        prix_unitaire=Decimal(prix)
                    )

                    # D√©duire le stock
                    produit.stock -= quantite
                    produit.save()

                    # Alerte seuil
                    if produit.stock <= produit.seuil_alerte:
                        messages.warning(request, f"‚ö†Ô∏è Le stock du produit **{produit.nom}** est bas ({produit.stock} unit√©s restantes) !")

                        # Envoyer email √† l'admin
                        send_mail(
                            subject=f"Alerte stock bas : {produit.nom}",
                            message=(
                                f"Le stock du produit '{produit.nom}' est tomb√© √† {produit.stock} unit√©s.\n"
                                f"Seuil d'alerte : {produit.seuil_alerte}."
                            ),
                            from_email=settings.DEFAULT_FROM_EMAIL,
                            recipient_list=[settings.ADMINS[0][1]],
                            fail_silently=False,
                        )

                # Total commande
                commande.calculer_total()
                # Juste apr√®s commande.calculer_total()
                commande.valider_commande()


                # R√©cup√©ration des lignes pour PDF
                lignes = commande.lignes.select_related("produit").all()

                # G√©n√©ration du PDF
                template_pdf = render_to_string("commande/commande_pdf.html", {
                    "commande": commande,
                    "lignes": lignes
                })
                pdf_buffer = BytesIO()
                pisa_status = pisa.CreatePDF(template_pdf, dest=pdf_buffer)

                if not pisa_status.err:
                    # Envoi e-mail client
                    sujet = f"Bon de commande #{commande.id}"
                    message_html = render_to_string("commande/emails_commande.html", {
                        "commande": commande,
                        "lignes": lignes
                    })

                    email = EmailMessage(
                        sujet,
                        message_html,
                        to=[commande.client.email],
                    )
                    email.content_subtype = "html"
                    email.attach(f"commande_{commande.id}.pdf", pdf_buffer.getvalue(), "application/pdf")
                    email.send()

                    messages.success(request, "‚úÖ La commande a bien √©t√© cr√©√©e et envoy√©e au client par e-mail.")
                else:
                    messages.warning(request, "‚ö†Ô∏è La commande a √©t√© cr√©√©e, mais une erreur est survenue lors de la g√©n√©ration du PDF.")

                return redirect("liste_commandes")

        except Exception as e:
            messages.error(request, f"‚ùå Erreur lors de la cr√©ation de la commande : {str(e)}")

    clients = Client.objects.all()
    produits = Produit.objects.all()
    return render(request, "commande/creer_commande.html", {
        "clients": clients,
        "produits": produits
    })
    
#details commande
def detail_commande(request, commande_id):
    commande = get_object_or_404(
        Commande.objects.select_related('client', 'vendeur').prefetch_related('lignes__produit', 'historiques'),
        id=commande_id
    )
    return render(request, "commande/detail_commande.html", {
        "commande": commande,
        "historiques": commande.historiques.all().order_by("-date_modification")
    })


from django.shortcuts import render, get_object_or_404
from django.contrib.auth.decorators import login_required
from django.core.paginator import Paginator
from django.db.models import Q
from decimal import Decimal
from .models import Commande, Parametre, TauxChange

@login_required
def liste_commandes(request):
    parametres = get_object_or_404(Parametre, user=request.user)
    devise_affichee = request.session.get('devise_affichee', parametres.devise_principale)

    # R√©cup√©rer le taux USD->CDF
    taux_usd = TauxChange.objects.filter(devise_source='USD', devise_cible='CDF').first()
    taux_usd = taux_usd.taux if taux_usd else 2850  # Valeur par d√©faut

    commandes_list = Commande.objects.select_related('client', 'vendeur').order_by('-date_commande')
    
    # Filtrage et pagination
    search_query = request.GET.get('search', '')
    if search_query:
        commandes_list = commandes_list.filter(
            Q(id__icontains=search_query) |
            Q(client__nom__icontains=search_query) |
            Q(vendeur__username__icontains=search_query) |
            Q(statut__icontains=search_query)
        )
    
    paginator = Paginator(commandes_list, 10)
    page_number = request.GET.get('page')
    commandes = paginator.get_page(page_number)

    # Pr√©-formater les montants dans la vue
    for commande in commandes:
        commande.montant_cdf_formate = parametres.format_devise(commande.montant_total, 'CDF')
        if devise_affichee != 'CDF':
            try:
                montant_converti = Decimal(commande.montant_total) / Decimal(taux_usd)
                commande.montant_converti_formate = parametres.format_devise(montant_converti, devise_affichee)
            except:
                commande.montant_converti_formate = "Erreur"

    return render(request, 'commande/liste_commandes.html', {
        'commandes': commandes,
        'devise_affichee': devise_affichee,
        'devise_principale': parametres.devise_principale,
        'taux_usd': taux_usd,
        'devises_acceptees': parametres.devises_acceptees or [parametres.devise_principale],
        'search_query': search_query,
        'parametres': parametres,
    })
    
    
from django.views.decorators.http import require_POST
from django.views.decorators.csrf import csrf_exempt
from django.http import JsonResponse

@require_POST
@csrf_exempt  # Temporaire pour les tests, √† remplacer par une gestion CSRF appropri√©e
def update_taux(request):
    try:
        taux = request.POST.get('taux')
        devise_source = request.POST.get('devise_source', 'USD')
        devise_cible = request.POST.get('devise_cible', 'CDF')
        
        # Valider que le taux est un nombre positif
        taux_decimal = Decimal(taux)
        if taux_decimal <= 0:
            raise ValueError("Le taux doit √™tre positif")

        # Mettre √† jour ou cr√©er le taux de change
        taux_obj, created = TauxChange.objects.update_or_create(
            devise_source=devise_source,
            devise_cible=devise_cible,
            defaults={
                'taux': taux_decimal,
                'est_manuel': True
            }
        )

        return JsonResponse({
            'status': 'success',
            'message': 'Taux mis √† jour avec succ√®s',
            'taux': str(taux_obj.taux)
        })

    except Exception as e:
        return JsonResponse({
            'status': 'error',
            'message': str(e)
        }, status=400)

@login_required
def convertir_devise(request):
    if request.method == 'POST':
        montant = Decimal(request.POST.get('montant', 0))
        devise_cible = request.POST.get('devise_cible', 'USD')
        
        try:
            # R√©cup√©rer le taux USD->CDF (ex: 1 USD = 2850 CDF)
            taux = TauxChange.get_taux(devise_cible, 'CDF')
            if taux:
                montant_converti = montant / taux
                return JsonResponse({
                    'success': True,
                    'montant_converti': f"{montant_converti:.2f}",
                    'devise_cible': devise_cible,
                    'taux': f"1 {devise_cible} = {taux:.6f} CDF"
                })
        except Exception as e:
            return JsonResponse({'success': False, 'error': str(e)})
    
    return JsonResponse({'success': False, 'error': 'Requ√™te invalide'})

#imprimer commande
def commande_pdf(request, commande_id):
    commande = get_object_or_404(Commande.objects.prefetch_related('lignes__produit'), id=commande_id)

    template = render_to_string("commande/commande_pdf.html", {
        "commande": commande,
        "lignes": commande.lignes.all()
    })
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = f'inline; filename="commande_{commande.id}.pdf"'

    pisa_status = pisa.CreatePDF(BytesIO(template.encode("utf-8")), dest=response)

    if pisa_status.err:
        return HttpResponse("Erreur lors de la g√©n√©ration du PDF", status=500)

    return response




#Vue pour modifier le statut
@login_required
def changer_statut_commande(request, commande_id):
    commande = get_object_or_404(Commande, id=commande_id)

    if request.method == "POST":
        nouveau_statut = request.POST.get("statut")
        if nouveau_statut != commande.statut:
            HistoriqueStatut.objects.create(
                commande=commande,
                ancien_statut=commande.statut,
                nouveau_statut=nouveau_statut,
                modifie_par=request.user
            )
            commande.statut = nouveau_statut
            commande.save()
            messages.success(request, "‚úÖ Statut mis √† jour avec succ√®s.")

        return redirect("detail_commande", commande_id=commande.id)

    return render(request, "commande/modifier_statut.html", {"commande": commande})


#importation fichier commande csv
@login_required
def export_commandes_csv(request):
    response = HttpResponse(content_type='text/csv')
    response['Content-Disposition'] = 'attachment; filename="commandes.csv"'

    writer = csv.writer(response)
    # Ent√™tes
    writer.writerow([
        'ID',
        'Client',
        'Email Client',
        'Paiement',
        'Expiration',
        'Vendeur',
        'Email Vendeur',
        'Montant Total',
        'Statut',
        'Date de Cr√©ation',
    ])

    commandes = Commande.objects.select_related('client', 'vendeur').all()
    for commande in commandes:
        writer.writerow([
            commande.id,
            commande.client.nom if commande.client else '',
            commande.client.email if commande.client else '',
            commande.paiement,
            commande.expiration.strftime('%d/%m/%Y') if commande.expiration else '',
            commande.vendeur.get_full_name() if commande.vendeur else '',
            commande.vendeur.email if commande.vendeur else '',
            commande.montant_total,
            commande.statut,
            commande.date_commande.strftime('%d/%m/%Y %H:%M'),
        ])

    return response

#import excel

def export_commandes_excel(request):
    wb = openpyxl.Workbook()
    ws = wb.active
    ws.title = "Commandes"

    # En-t√™tes
    headers = [
        "ID", "Client", "Email Client", "Paiement", "Expiration",
        "Vendeur", "Montant Total (FC)", "Statut", "Date de Cr√©ation"
    ]
    ws.append(headers)

    # Style des en-t√™tes
    header_font = Font(bold=True)
    border = Border(
        left=Side(style='thin'), right=Side(style='thin'),
        top=Side(style='thin'), bottom=Side(style='thin')
    )
    for col in range(1, len(headers) + 1):
        cell = ws.cell(row=1, column=col)
        cell.font = header_font
        cell.alignment = Alignment(horizontal='center')
        cell.border = border

    # Donn√©es
    commandes = Commande.objects.select_related("client", "vendeur").all()
    for commande in commandes:
        ws.append([
            commande.id,
            commande.client.nom,
            commande.client.email,
            commande.paiement,
            commande.expiration.strftime('%d/%m/%Y') if commande.expiration else '',
            commande.vendeur.get_full_name() if commande.vendeur else '',
            float(commande.montant_total),
            commande.statut,
            commande.date_commande.strftime('%d/%m/%Y %H:%M'),
        ])

    # Ajuster la largeur des colonnes
    for column_cells in ws.columns:
        length = max(len(str(cell.value)) if cell.value else 0 for cell in column_cells)
        ws.column_dimensions[column_cells[0].column_letter].width = length + 2

    # R√©ponse HTTP
    response = HttpResponse(
        content_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
    )
    response["Content-Disposition"] = "attachment; filename=commandes.xlsx"
    wb.save(response)
    return response

def gestion_stock_et_produit(request):
    return render(request,'Gestion des produits et stock/liste.html')

def vente_enligne_(request):
    return render(request,'Vente au comptoir ou en ligne/liste.html')

def Achats_gestion(request):
    return render(request,'achats/liste.html')

#suppression commande
@login_required
def supprimer_commande(request, commande_id):
    commande = get_object_or_404(Commande, id=commande_id)
    
    if request.method == 'POST':
        commande.delete()
        messages.success(request, f"üóëÔ∏è La commande #{commande_id} a √©t√© supprim√©e avec succ√®s.")
        return redirect('liste_commandes')
    
    messages.warning(request, "‚ö†Ô∏è Suppression annul√©e.")
    return redirect('liste_commandes')



#vente confirme

@login_required
def confirmer_commande(request, commande_id):
    commande = get_object_or_404(Commande, id=commande_id)
    if commande.valider_commande():
        messages.success(request, "‚úÖ Vente confirm√©e et stock mis √† jour.")
    else:
        messages.error(request, "‚ùå Stock insuffisant pour confirmer la vente.")
    return redirect("liste_commandes")


#Vente au comptoire creer
from decimal import Decimal, InvalidOperation



@login_required
def vente_au_comptoir(request):
    today = timezone.now().date()

    # V√©rifier si la caisse est cl√¥tur√©e
    if ClotureCaisse.objects.filter(vendeur=request.user, date_jour=today).exists():
        return render(request, "vente/vente_bloquee.html", {
            "message": "La caisse est d√©j√† cl√¥tur√©e pour aujourd'hui."
        })

    # R√©cup√©rer les produits et cat√©gories
    produits = Produit.objects.all()
    categories = Categorie.objects.all()

    # R√©cup√©rer les param√®tres utilisateur
    try:
        parametres = request.user.parametre
        devise_principale = parametres.devise_principale
        devises_acceptees = parametres.devises_acceptees or ['USD', 'CDF']
        devises_formatees = {
            devise: parametres.format_devise(1, devise)
            for devise in devises_acceptees
        }
    except Parametre.DoesNotExist:
        parametres = None
        devise_principale = 'USD'
        devises_acceptees = ['USD', 'CDF']
        devises_formatees = {'USD': '$1.00', 'CDF': 'FC1.00'}

    # R√©cup√©rer les taux de change
    taux_change = {}
    for devise in devises_acceptees:
        if devise != devise_principale:
            try:
                taux = TauxChange.get_taux(devise_principale, devise)
                if taux:
                    taux_change[devise] = Decimal(str(taux))
            except ValidationError:
                continue

    # D√©terminer la devise √† afficher
    devise_affichee = request.session.get('devise_affichee', devise_principale)
    if devise_affichee not in devises_acceptees:
        devise_affichee = devise_principale

    taux_affiche = taux_change.get(devise_affichee, Decimal('1.0'))

    # Pr√©parer les produits avec les prix convertis
    produits_converts = []
    for produit in produits:
        try:
            if parametres and devise_affichee != devise_principale:
                prix_converti = parametres.convertir_vers_devise_affichee(
                    produit.prix_vente, devise_affichee
                )
            else:
                prix_converti = produit.prix_vente
        except ValidationError:
            prix_converti = produit.prix_vente

        produits_converts.append({
            'id': produit.id,
            'libelle': produit.libelle,
            'stock': produit.stock,
            'prix_vente': produit.prix_vente,
            'prix_converti': prix_converti,
            'categorie': produit.categorie.id if produit.categorie else None,
            'code_barre_numero': produit.code_barre_numero,
            'photo': produit.photo,
        })

    context = {
        'categories': categories,
        'produits': produits_converts,
        'today': today.strftime("%Y-%m-%d"),
        'devise_principale': devise_principale,
        'devise_affichee': devise_affichee,
        'devises_acceptees': devises_acceptees,
        'devises_formatees': devises_formatees,
        'taux_change': taux_change,
        'taux_affiche': taux_affiche,
        'parametre': parametres,
    }

    # Traitement de la commande POST
    if request.method == 'POST':
        try:
            client, _ = Client.objects.get_or_create(
                nom="Client Comptoir",
                defaults={'email': 'comptoir@example.com', 'telephone': '0000000000'}
            )

            commande = Commande.objects.create(
                client=client,
                paiement=request.POST.get('paiement', 'cash'),
                expiration=today + timezone.timedelta(days=30),
                vendeur=request.user,
                vente_au_comptoir=True,
                statut="en_attente",
                devise_utilisee=devise_affichee,
                taux_change=taux_affiche
            )

            produits_ids = request.POST.getlist('produit[]')
            quantites = request.POST.getlist('quantite[]')
            prix_unitaire = request.POST.getlist('prix[]')

            for i, produit_id in enumerate(produits_ids):
                produit = Produit.objects.get(id=produit_id)
                quantite = int(quantites[i])

                if produit.stock < quantite:
                    messages.error(request, f"Stock insuffisant pour {produit.libelle}")
                    commande.delete()
                    return redirect('vente_au_comptoir')

                LigneCommande.objects.create(
                    commande=commande,
                    produit=produit,
                    quantite=quantite,
                    prix_unitaire=Decimal(prix_unitaire[i]),
                    devise=devise_affichee
                )

                produit.stock -= quantite
                produit.save()

            commande.calculer_total()
            if commande.valider_commande():
                messages.success(request, f"Vente #{commande.id} enregistr√©e avec succ√®s!")
                return redirect('ticket_pdf', commande_id=commande.id)
            else:
                messages.error(request, "Erreur lors de la validation de la commande")
                return redirect('vente_au_comptoir')

        except Exception as e:
            messages.error(request, f"Erreur lors de la vente: {str(e)}")
            if 'commande' in locals():
                commande.delete()
            return redirect('vente_au_comptoir')

    return render(request, 'vente/vente_comptoire.html', context)

@login_required
def change_currency(request):
    if request.method == 'POST':
        try:
            data = json.loads(request.body)
            currency = data.get('currency')
            
            # V√©rifier que la devise est accept√©e
            parametres = request.user.parametre
            if currency in parametres.devises_acceptees:
                request.session['devise_affichee'] = currency
                return JsonResponse({'success': True})
            else:
                return JsonResponse({'success': False, 'error': 'Devise non accept√©e'})
                
        except Exception as e:
            return JsonResponse({'success': False, 'error': str(e)})
    return JsonResponse({'success': False})

@login_required
def change_currency(request):
    if request.method == 'POST':
        try:
            data = json.loads(request.body)
            currency = data.get('currency')
            if currency in request.user.parametre.devises_acceptees:
                request.session['devise_affichee'] = currency
                return JsonResponse({'success': True})
        except Exception as e:
            return JsonResponse({'success': False, 'error': str(e)})
    return JsonResponse({'success': False})
#creer ticker
def generer_pdf(template_src, context_dict):
    html = render_to_string(template_src, context_dict)
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = 'attachment; filename="document.pdf"'
    pisa_status = pisa.CreatePDF(html, dest=response)
    if pisa_status.err:
        return HttpResponse('Une erreur est survenue lors de la g√©n√©ration du PDF')
    return response
    
    #vente du jour
    
def ventes_du_jour(request):
    ventes = Commande.objects.filter(date_commande__date=timezone.now().date(), vente_confirmee=True)
    return render(request, 'vente/ventes_du_jour.html', {'ventes': ventes})



def ticket_pdf(request, commande_id):
    commande = get_object_or_404(Commande, id=commande_id)
    parametre = getattr(commande, 'parametre', None)
    if not parametre:
        parametre = Parametre.objects.first() # Assure-toi que ce champ existe sur le mod√®le Commande

    # Pr√©paration du contexte
    context = {
        'commande': commande,
        'parametre': parametre
    }

    # Rendu HTML √† partir du template
    template = get_template('vente/ticket_pdf.html')
    html_string = template.render(context)

    # Cr√©ation du PDF via WeasyPrint
    html = HTML(string=html_string, base_url=request.build_absolute_uri('/'))

    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = f'inline; filename="ticket_{commande.id}.pdf"'

    html.write_pdf(response)

    return response

def bon_commande_pdf(request, commande_id):
    commande = get_object_or_404(Commande, id=commande_id)
    lignes = LigneCommande.objects.filter(commande=commande)
    context = {
        'commande': commande,
        'lignes': lignes,
    }
    return generer_pdf('pdf/bon_commande.html', context)


#code bare
def chercher_produit_par_code_barres(request):
    code = request.GET.get('code', '')
    try:
        produit = Produit.objects.get(code_barres=code)
        data = {
            'id': produit.id,
            'nom': produit.nom,
            'prix_vente': float(produit.prix_vente),
        }
        return JsonResponse(data)
    except Produit.DoesNotExist:
        return JsonResponse({'error': 'Produit non trouv√©'}, status=404)
    
    
    #historique de vente 
def historique_ventes(request):
    ventes = Commande.objects.filter(vente_confirmee=True)

    # Filtres
    date = request.GET.get('date')
    vendeur = request.GET.get('vendeur')

    if date:
        ventes = ventes.filter(date_commande__date=date)
    if vendeur:
        ventes = ventes.filter(vendeur__id=vendeur)

    total = ventes.aggregate(total_journalier=Sum('montant_total'))['total_journalier'] or 0

    vendeurs = Commande.objects.values('vendeur__id', 'vendeur__username').distinct()
    
    

    return render(request, 'vente/historique_ventes.html', {
        'ventes': ventes,
        'total': total,
        'vendeurs': vendeurs,
        'selected_date': date,
        'selected_vendeur': vendeur,
    })
    
    
    
    
    #Statistiques
def format_devise(self, montant, devise=None):
    devise = devise or self.devise_principale
    symboles = {
        'USD': '$',
        'EUR': '‚Ç¨',
        'CDF': 'FC',
        'FC': 'FC'
    }
    symbole = symboles.get(devise, devise)
    return f"{symbole} {montant:,.2f}"


def statistiques(request):
    user = request.user
    param = getattr(user, 'parametre', None)

    if not param:
        return render(request, 'erreur.html', {'message': "Aucun param√®tre configur√© pour l'utilisateur."})

    devise_source = param.devise_principale or "USD"
    devise_cible = request.GET.get("devise", devise_source)
    aujourd_hui = now().date()

    # Taux de change
    try:
        taux_change = TauxChange.get_taux(devise_source, devise_cible)
        if taux_change is None:
            taux_change = 1.0
    except ValidationError:
        taux_change = 1.0

    # 1. Nombre total d'utilisateurs
    nb_utilisateurs = User.objects.count()
    
    # 2. Nombre d'utilisateurs actifs aujourd'hui
    utilisateurs_actifs = User.objects.filter(
        last_login__date=aujourd_hui
    ).count()

    # Ventes du jour
    ventes_du_jour = Commande.objects.filter(date_commande__date=aujourd_hui)
    total_journalier_source = ventes_du_jour.aggregate(total=Sum('montant_total'))['total'] or 0
    total_journalier_converted = total_journalier_source * taux_change
    total_transactions = ventes_du_jour.count()

    ventes_jour_source = total_journalier_source
    ventes_jour_converted = ventes_jour_source * taux_change

    # Statistiques des produits
    produits_stats = (
        LigneCommande.objects
        .filter(commande__date_commande__date=aujourd_hui)
        .values(
            nom=F('produit__nom'),
            reference=F('produit__code_barre_numero')
        )
        .annotate(
            qte_totale=Sum('quantite'),
            ca_produit=Sum(F('quantite') * F('prix_unitaire'))
        )
        .order_by('-qte_totale')[:5]
    )

    total_produits_vendus = sum([p['qte_totale'] for p in produits_stats]) or 1
    total_produits = 0

    for produit in produits_stats:
        produit['ca_produit_converted'] = produit['ca_produit'] * taux_change
        produit['part_market'] = (produit['qte_totale'] / total_produits_vendus) * 100
        total_produits += produit['qte_totale']

    # Statistiques des vendeurs
    vendeurs_stats = (
        ventes_du_jour
        .values(nom=F('vendeur__username'))
        .annotate(
            total_vendeur=Sum('montant_total'),
            nb_ventes=Count('id')
        )
        .order_by('-total_vendeur')
    )

    for vendeur in vendeurs_stats:
        vendeur['total_vendeur_converted'] = vendeur['total_vendeur'] * taux_change
        vendeur['performance'] = (
            (vendeur['total_vendeur_converted'] / total_journalier_converted * 100)
            if total_journalier_converted > 0 else 0
        )

        if vendeur['performance'] >= 50:
            vendeur['perf_color'] = 'success'
            vendeur['perf_icon'] = 'arrow-up'
        elif vendeur['performance'] >= 20:
            vendeur['perf_color'] = 'warning'
            vendeur['perf_icon'] = 'arrow-right'
        else:
            vendeur['perf_color'] = 'danger'
            vendeur['perf_icon'] = 'arrow-down'

    return render(request, 'stat/statistiquesVente.html', {
        # Statistiques de base
        'total_journalier_converted': total_journalier_converted,
        'ventes_jour_converted': ventes_jour_converted,
        'total_transactions': total_transactions,
        'total_produits': total_produits,
        'produits_populaires': produits_stats,
        'performance_vendeurs': vendeurs_stats,
        
        # Nouveaux indicateurs utilisateurs
        'nb_utilisateurs': nb_utilisateurs,
        'utilisateurs_actifs': utilisateurs_actifs,
        
        # Devises et param√®tres
        'now': now(),
        'devise': devise_cible,
        'param': param,
        'taux_change': taux_change,
        
        # Pour la conversion
        'devise_symbols': {'USD': '$', 'CDF': 'FC', 'EUR': '‚Ç¨'},
        'devises_disponibles': ['USD', 'CDF', 'EUR'],
    })

def bilan_caisse_du_jour(vendeur):
    today = timezone.now().date()
    commandes = Commande.objects.filter(
        vente_au_comptoir=True,
        vente_confirmee=True,
        vendeur=vendeur,
        date_commande__date=today
    )

    total = commandes.aggregate(Sum("montant_total"))["montant_total__sum"] or 0
    nb_commandes = commandes.count()

    return {
        "total": total,
        "nb_commandes": nb_commandes,
        "commandes": commandes
    }

@login_required
def cloturer_caisse(request):
    today = timezone.now().date()
    user = request.user
    
    if ClotureCaisse.objects.filter(vendeur=user, date_jour=today).exists():
        messages.warning(request, "La caisse a d√©j√† √©t√© cl√¥tur√©e aujourd'hui.")
        return redirect('dashboard')
    
    ventes_du_jour = Commande.objects.filter(
        vendeur=user,
        vente_au_comptoir=True,
        date_commande__date=today,
        vente_confirmee=True
    )
    
    total_ventes = ventes_du_jour.aggregate(
        total=Sum('montant_total'),
        count=Count('id')
    )
    total_vendu = total_ventes['total'] or Decimal('0.00')
    
    if request.method == 'POST':
        try:
            montant_espece = Decimal(request.POST.get('montant_espece', '0'))
            montant_carte = Decimal(request.POST.get('montant_carte', '0'))
            commentaire = request.POST.get('commentaire', '')
            
            if montant_espece < 0 or montant_carte < 0:
                raise ValueError("Les montants ne peuvent pas √™tre n√©gatifs")
                
            total_declare = montant_espece + montant_carte
            tolerance = Decimal('0.01')
            
            # Cr√©ation de la cl√¥ture
            cloture = ClotureCaisse.objects.create(
                vendeur=user,
                date_jour=today,
                montant_total=total_vendu,
                nombre_ventes=total_ventes['count'] or 0,
                montant_espece=montant_espece,
                montant_carte=montant_carte,
                commentaire=commentaire,
                validee=True
            )
            
            # Gestion des √©carts
            ecart_montant = abs(total_vendu - total_declare)
            if ecart_montant > tolerance:
                type_ecart = 'manquant' if total_vendu > total_declare else 'excedent'
                
                # Enregistrement de l'√©cart
                ecart = EcartCaisse.objects.create(
                    cloture=cloture,
                    montant=ecart_montant,
                    type_ecart=type_ecart,
                    commentaire=f"√âcart d√©tect√© lors de la cl√¥ture. {commentaire}"
                )
                
                # Notification admin
                email_content = f"""
                <h3>Nouvel √©cart de caisse enregistr√©</h3>
                <p><strong>Vendeur:</strong> {user.get_full_name()} ({user.username})</p>
                <p><strong>Type:</strong> {ecart.get_type_ecart_display()}</p>
                <p><strong>Montant:</strong> {ecart.montant} FC</p>
                <p><strong>Cl√¥ture:</strong> #{cloture.id} du {cloture.date_jour}</p>
                <p><strong>D√©tails:</strong></p>
                <ul>
                    <li>Total syst√®me: {total_vendu} FC</li>
                    <li>Total d√©clar√©: {total_declare} FC</li>
                    <li>Esp√®ces: {montant_espece} FC</li>
                    <li>Carte: {montant_carte} FC</li>
                </ul>
                """
                
               # Correction de l'appel √† send_mail
                send_mail(
                    subject=f"[ECART CAISSE] {ecart.get_type_ecart_display()} de {ecart.montant}FC",
                    message="",  # message vide car on utilise html_message
                    from_email=settings.DEFAULT_FROM_EMAIL,  # Ajout de l'email exp√©diteur
                    recipient_list=[admin[1] for admin in settings.ADMINS],
                    html_message=email_content,
                    fail_silently=False,
)
                ecart.notifie_admin = True
                ecart.save()
                
                messages.warning(
                    request,
                    f"Cl√¥ture valid√©e avec √©cart {type_ecart} de {ecart_montant}FC enregistr√©."
                )
            else:
                messages.success(request, "Cl√¥ture valid√©e sans √©cart.")
            
            return redirect('rapport_cloture', pk=cloture.id)
            
        except Exception as e:
            messages.error(request, f"Erreur: {str(e)}")
            return redirect('cloturer_caisse')
    
    context = {
        'total_ventes': total_vendu,
        'nombre_ventes': total_ventes['count'] or 0,
        'today': today.strftime("%d/%m/%Y"),
    }
    
    return render(request, 'vente/cloturer_caisse.html', context)


#vue ecart

@login_required
@user_passes_test(lambda u: u.is_superuser)
def liste_ecarts(request):
    ecarts = EcartCaisse.objects.select_related('cloture').order_by('-date_decouverte')
    return render(request, 'vente/liste_ecarts.html', {'ecarts': ecarts})

#rapport

@login_required
def rapport_cloture(request, pk):
    cloture = ClotureCaisse.objects.get(pk=pk)
    return render(request, 'vente/rapport_cloture.html', {'cloture': cloture})

#bila
@login_required
def bilan_du_jour(request):
    vendeur = request.user
    today = timezone.now().date()

    commandes = Commande.objects.filter(
        vente_au_comptoir=True,
        vente_confirmee=True,
        vendeur=vendeur,
        date_commande__date=today
    )

    total = commandes.aggregate(Sum("montant_total"))["montant_total__sum"] or 0
    nb_commandes = commandes.count()

    moyen_commande = total / nb_commandes if nb_commandes > 0 else 0

    derniere_commande = commandes.order_by("-date_commande").first()

    lignes = LigneCommande.objects.filter(commande__in=commandes)

    produits_vendus = {}
    for ligne in lignes:
        produit = ligne.produit
        if produit.id not in produits_vendus:
            produits_vendus[produit.id] = {
                "nom": produit.nom,
                "quantite": 0,
                "montant": 0,
            }
        produits_vendus[produit.id]["quantite"] += ligne.quantite
        produits_vendus[produit.id]["montant"] += ligne.sous_total()

    produits_vendus_list = sorted([
        {
            "nom": infos["nom"],
            "quantite": infos["quantite"],
            "montant": infos["montant"]
        }
        for infos in produits_vendus.values()
    ], key=lambda x: x["montant"], reverse=True)

    context = {
        "vendeur": vendeur,
        "date": today,
        "total": total,
        "nb_commandes": nb_commandes,
        "moyen_commande": moyen_commande,
        "derniere_commande": derniere_commande.date_commande if derniere_commande else None,
        "commandes": commandes,
        "produits_vendus": produits_vendus_list
    }

    return render(request, "vente/bilan_du_jour.html", context)
    
def afficher_bilan(request):
    bilan = bilan_caisse_du_jour(request.user)
    nb = bilan["nb_commandes"]
    total = bilan["total"]
    bilan["moyen_commande"] = total / nb if nb > 0 else 0
    bilan["vendeur"] = request.user
    bilan["date"] = timezone.now().date()
    return render(request, "vente/bilan_du_jour.html", bilan)

    
    
def ticket_caisse(request, commande_id):
    commande = get_object_or_404(Commande, pk=commande_id)
    
    # R√©cup√©rer les param√®tres de l'entreprise
    try:
        parametre = Parametre.objects.first()
    except Parametre.DoesNotExist:
        # Cr√©er un objet par d√©faut si aucun param√®tre n'existe
        parametre = Parametre(
            nom_societe="Ma Soci√©t√©",
            adresse="Adresse non d√©finie",
            telephone="0000000000",
            email="contact@example.com"
        )
    
    context = {
        'commande': commande,
        'parametre': parametre
    }
    return render(request, 'ticket_caisse.html', context)   
from .models import Parametre

    
def ma_vue(request, commande_id):
    commande = get_object_or_404(Commande, pk=commande_id)
    parametre = Parametre.objects.first()  # ou la m√©thode appropri√©e pour r√©cup√©rer les param√®tres
    return render(request, 'template.html', {'commande': commande, 'parametre': parametre})
# def afficher_P(request):
#     parametres = Parametre.objects.first()
#     return render(request, "parametres/parametres.html", {
#         "parA": parametres
#     })

def principal(request):
    parametres = Parametre.objects.first()
    return render(request, "stat/principale.html")



#tableau de bord
def dashboard(request):
    today = timezone.now().date()

    ventes_jour = Commande.objects.filter(date__date=today)
    total_journalier = ventes_jour.aggregate(total=Sum('montant'))['total'] or 0
    total_transactions = ventes_jour.count()

    # Top vendeur
    meilleurs = ventes_jour.values('vendeur__username') \
        .annotate(total=Sum('montant')) \
        .order_by('-total')
    meilleur_vendeur = {'nom': meilleurs[0]['vendeur__username']} if meilleurs else {'nom': 'Aucun'}

    # Produits populaires
    produits_populaires = ventes_jour.values('produit__nom') \
        .annotate(total_vendu=Sum('quantite')) \
        .order_by('-total_vendu')[:5]

    context = {
        'total_journalier': total_journalier,
        'total_transactions': total_transactions,
        'meilleur_vendeur': meilleur_vendeur,
        'produits_populaires': [{'nom': p['produit__nom'], 'total_vendu': p['total_vendu']} for p in produits_populaires],
        'now': timezone.now(),
    }
    return render(request, 'stat/dashboard.html', context)



def dashboard(request):
    return render(request, 'stat/statistiquesVente.html')

# def logout_view(request):
#     logout(request)
#     messages.info(request, "Vous √™tes maintenant conn√©ct√© ")
#     return redirect('login')  # Redirection vers la page de login


# #role

# Fonctions de v√©rification de r√¥le
def est_admin(user):
    return user.groups.filter(name='Admin').exists()

def est_caissier(user):
    return user.groups.filter(name='Caissier').exists()

def est_stock(user):
    return user.groups.filter(name='Stock').exists()

# Vue pour les caissiers
@login_required
@user_passes_test(est_caissier)
def vue_pour_caissier(request):
    return render(request, "vente/vente_comptoire.html")

# Vue pour le responsable stock
@login_required
@user_passes_test(est_stock)
def vue_stock(request):
    return render(request, "stock/liste_produits.html")

#vue utilisateurs
def is_admin(user):
    return user.groups.filter(name="Admin").exists()

@user_passes_test(is_admin)
def liste_utilisateurs(request):
    utilisateurs = User.objects.all()
    return render(request, 'utilisateurs/liste.html', {'utilisateurs': utilisateurs})

#modifier article
@user_passes_test(is_admin)
def modifier_utilisateur(request, user_id):
    user = User.objects.get(pk=user_id)
    groupes = Group.objects.all()

    if request.method == "POST":
        selected_group_id = request.POST.get("groupe")
        group = Group.objects.get(id=selected_group_id)
        user.groups.clear()
        user.groups.add(group)
        user.save()
        return redirect('liste_utilisateurs')

    return render(request, 'utilisateurs/modifier.html', {'user': user, 'groupes': groupes})

@user_passes_test(is_admin)
def desactiver_utilisateur(request, user_id):
    user = User.objects.get(pk=user_id)
    user.is_active = False
    user.save()
    return redirect('liste_utilisateurs')

@user_passes_test(is_admin)
def activer_utilisateur(request, user_id):
    user = User.objects.get(pk=user_id)
    user.is_active = True
    user.save()
    return redirect('liste_utilisateurs')


def reset_password(request, user_id):
    user = User.objects.get(pk=user_id)
    nouveau_mot_de_passe = get_random_string(10)

    user.password = make_password(nouveau_mot_de_passe)
    user.save()

    sujet = "R√©initialisation de votre mot de passe"
    message = f"""
Bonjour {user.get_full_name() or user.username},

Votre mot de passe a √©t√© r√©initialis√©.

Nom d'utilisateur : {user.username}
Mot de passe : {nouveau_mot_de_passe}

Merci de changer votre mot de passe apr√®s connexion.

Cordialement,
L'√©quipe support
    """.strip()

    send_mail(sujet, message, settings.DEFAULT_FROM_EMAIL, [user.email])

    messages.success(request, f"Mot de passe r√©initialis√© et envoy√© √† {user.email}")
    return redirect('liste_utilisateurs')

#ajouter user
def ajouter_utilisateur(request):
    groupes = Group.objects.all()

    if request.method == 'POST':
        username = request.POST.get('username')
        email = request.POST.get('email')
        password = request.POST.get('password')
        groupe_id = request.POST.get('groupe')

        if User.objects.filter(username=username).exists():
            messages.error(request, "Ce nom d'utilisateur existe d√©j√†.")
            return redirect('ajouter_utilisateur')

        user = User.objects.create(
            username=username,
            email=email,
            password=make_password(password),
        )

        if groupe_id:
            group = Group.objects.get(id=groupe_id)
            user.groups.add(group)

        messages.success(request, "Utilisateur cr√©√© avec succ√®s.")
        return redirect('liste_utilisateurs')

    return render(request, 'utilisateurs/ajouter_utilisateur.html', {'groupes': groupes})

#categorie par commande
def nouvelle_commande(request):
    # R√©cup√©rer tous les produits et cat√©gories
    produits = Produit.objects.select_related('categorie').all()
    categories = Categorie.objects.all()
    clients = Client.objects.all()
    
    context = {
        'produits': produits,
        'categories': categories,
        'clients': clients,
    }
    
    return render(request, 'commande/creer_commande.html', context)


#statistique des produits
def tableau_de_bord(request):
    # P√©riode du mois en cours
    aujourdhui = datetime.now()
    debut_mois = aujourdhui.replace(day=1)
    fin_mois = (debut_mois + timedelta(days=32)).replace(day=1) - timedelta(days=1)
    
    # Correction ici : remplacement de 'lignes_commandes' par 'lignecommande'
    produits = Produit.objects.annotate(
        quantite_vendue=Sum('lignecommande__quantite',
            filter=Q(lignecommande__commande__date_commande__range=[debut_mois, fin_mois])),
        montant_vendu=Sum(F('lignecommande__quantite') * F('lignecommande__prix_unitaire'),
            filter=Q(lignecommande__commande__date_commande__range=[debut_mois, fin_mois]))
    ).select_related('categorie').order_by('-montant_vendu')

    total_ventes = sum(p.quantite_vendue or 0 for p in produits)
    total_ca = sum(p.montant_vendu or 0 for p in produits)
    Produit.objects.filter(stock__lte=F('seuil_alerte')).count(),

    # Stats par cat√©gorie
    categories = Categorie.objects.annotate(
        total_ventes=Sum('produit__lignecommande__quantite',
            filter=Q(produit__lignecommande__commande__date_commande__range=[debut_mois, fin_mois])),
        total_ca=Sum(F('produit__lignecommande__quantite') * F('produit__lignecommande__prix_unitaire'),
            filter=Q(produit__lignecommande__commande__date_commande__range=[debut_mois, fin_mois]))
    ).filter(total_ventes__gt=0)

    context = {
        'stats': produits,
        'categories': categories,
        'total_produits': Produit.objects.count(),
        'total_ventes': total_ventes,
        'total_ca': total_ca,
        'produits_alerte': Produit.objects.filter(stock__lte=F('seuil_alerte')).count(),
        'mois_courant': debut_mois.strftime("%B %Y")
    }
    
    return render(request, 'stat/produits.html', context)

#stat commandes
# views.py - Version compl√®te


from django.contrib.auth.decorators import login_required
from django.db.models import Sum, Count, F, ExpressionWrapper, DecimalField
from django.db.models.functions import TruncMonth
from django.shortcuts import render
from django.utils import timezone
from django.core.exceptions import ValidationError
from decimal import Decimal
from datetime import timedelta
from .models import Commande, LigneCommande, TauxChange, Parametre

@login_required
def commande_stats(request):
    # Filtres
    period = request.GET.get('period', 'month')
    status = request.GET.get('status')
    sale_type = request.GET.get('sale_type')

    user = request.user
    param = getattr(user, 'parametre', None)

    if not param:
        return render(request, 'erreur.html', {'message': "Aucun param√®tre configur√© pour l'utilisateur."})

    # Gestion de la devise
    devise_source = param.devise_principale or "USD"
    devise_cible = request.GET.get("devise", request.session.get('devise_affichee', devise_source))

    # V√©rifier que la devise cible est autoris√©e
    devises_acceptees = getattr(param, 'devises_acceptees', ['USD', 'EUR', 'CDF', 'XOF', 'FC'])
    if devise_cible not in devises_acceptees:
        devise_cible = devise_source

    # Sauvegarder en session si nouvelle devise valide
    if 'devise' in request.GET and devise_cible in devises_acceptees:
        request.session['devise_affichee'] = devise_cible

    # Taux de change
    try:
        taux_change = TauxChange.get_taux(devise_source, devise_cible)
        taux_change = Decimal(str(taux_change)) if taux_change is not None else Decimal('1.0')
    except ValidationError:
        taux_change = Decimal('1.0')

    # Filtrage des commandes
    queryset = Commande.objects.all()
    if status:
        queryset = queryset.filter(statut=status)
    if sale_type == 'comptoir':
        queryset = queryset.filter(vente_au_comptoir=True)
    elif sale_type == 'normal':
        queryset = queryset.filter(vente_au_comptoir=False)

    today = timezone.now().date()
    if period == 'today':
        queryset = queryset.filter(date_commande__date=today)
    elif period == 'week':
        queryset = queryset.filter(date_commande__date__gte=today - timedelta(days=7))
    elif period == 'month':
        queryset = queryset.filter(date_commande__date__gte=today - timedelta(days=30))
    elif period == 'year':
        queryset = queryset.filter(date_commande__date__gte=today - timedelta(days=365))

    # Calculs statistiques
    total_commandes = queryset.count()
    total_montant_source = queryset.aggregate(total=Sum('montant_total'))['total'] or Decimal('0')
    total_montant = total_montant_source * taux_change
    commandes_annulees = queryset.filter(statut='annulee').count()

    # Formater les montants principaux
    total_montant_formatted = param.format_devise(total_montant, devise_cible)
    total_montant_source_formatted = param.format_devise(total_montant_source, devise_source)

    # Donn√©es mensuelles pour graphiques
    monthly_data = (
        queryset.annotate(month=TruncMonth('date_commande'))
               .values('month')
               .annotate(total=Count('id'), amount=Sum('montant_total'))
               .order_by('month')
    )

    months = [entry['month'].strftime("%b") for entry in monthly_data]
    monthly_totals = [entry['total'] for entry in monthly_data]
    monthly_amounts = [
        float((Decimal(str(entry['amount'] or 0)) * taux_change) / Decimal('1000'))
        for entry in monthly_data
    ]

    # Top produits (avec montant format√©)
    top_produits = LigneCommande.objects.filter(
        commande__in=queryset
    ).annotate(
        montant_ligne=ExpressionWrapper(
            F('quantite') * F('prix_unitaire'),
            output_field=DecimalField()
        )
    ).values(
        'produit__nom', 'produit__code_barre_numero'
    ).annotate(
        quantite=Sum('quantite'),
        montant=Sum('montant_ligne')
    ).order_by('-quantite')[:5]

    for produit in top_produits:
        produit['montant_converted'] = Decimal(str(produit['montant'] or 0)) * taux_change
        produit['montant_formatted'] = param.format_devise(produit['montant_converted'], devise_cible)

    # Top clients (avec montant format√©)
    top_clients = queryset.values('client__nom', 'client__id').annotate(
        commandes=Count('id'),
        montant=Sum('montant_total')
    ).order_by('-montant')[:5]

    for client in top_clients:
        client['montant_converted'] = Decimal(str(client['montant'] or 0)) * taux_change
        client['montant_formatted'] = param.format_devise(client['montant_converted'], devise_cible)

    # Commandes r√©centes (avec montant format√©)
    recent_orders = queryset.select_related('client').order_by('-date_commande')[:10]
    for commande in recent_orders:
        commande.montant_formatted = param.format_devise(commande.montant_total, devise_cible)

    # Pr√©paration des devises pour le template
    noms_devises = {
        'USD': 'Dollar am√©ricain ($)',
        'EUR': 'Euro (‚Ç¨)',
        'CDF': 'Franc congolais (FC)',
        'XOF': 'Franc CFA (XOF)',
        'FC': 'Franc congolais (FC)'
    }
    
    devises = {code: noms_devises.get(code, code) for code in devises_acceptees}

    # Contexte
    context = {
        'today': today,
        'total_commandes': total_commandes,
        'total_montant': total_montant,
        'total_montant_formatted': total_montant_formatted,
        'total_montant_source': total_montant_source,
        'total_montant_source_formatted': total_montant_source_formatted,
        'commandes_annulees': commandes_annulees,
        'statuts': queryset.values('statut').annotate(total=Count('id')).order_by('-total'),
        'monthly_labels': months,
        'monthly_totals': monthly_totals,
        'monthly_amounts': monthly_amounts,
        'devise': devise_cible,
        'taux_change': taux_change,
        'param': param,
        'devises': devises,
        'top_clients': top_clients,
        'top_produits': top_produits,
        'recent_orders': recent_orders,
        'active_filters': {
            'period': period,
            'status': status,
            'sale_type': sale_type,
            'devise': devise_cible
        }
    }

    return render(request, 'stat/commande_stats.html', context)
    
def inventaire(request):
    return render(request,"inventaire/inventaire.html")

def etat_stock(request):
    produits = Produit.objects.all()
    categories = Categorie.objects.all()
    fournisseurs = Fournisseur.objects.all()

    # Filtres
    cat = request.GET.get('categorie')
    frs = request.GET.get('fournisseur')
    seuil = request.GET.get('alerte')  # ex: "1" pour alerte activ√©e

    if cat:
        produits = produits.filter(categorie_id=cat)

    if frs:
        produits = produits.filter(fournisseur_id=frs)

    if seuil == "1":
        produits = produits.filter(stock__lte=F('seuil_alerte'))

    context = {
        'produits': produits,
        'categories': categories,
        'fournisseurs': fournisseurs,
        'cat_selected': cat,
        'frs_selected': frs,
        'seuil_selected': seuil,
    }

    return render(request, 'inventaire/etat_stock.html', context)


#mouvement stock
@login_required
def ajouter_mouvement_stock(request):
    produits = Produit.objects.all()

    if request.method == "POST":
        produit_id = request.POST.get("produit")
        type_mouvement = request.POST.get("type")
        quantite = int(request.POST.get("quantite"))
        commentaire = request.POST.get("commentaire")

        produit = Produit.objects.get(id=produit_id)

        # V√©rification du stock pour les sorties
        if type_mouvement == "sortie" and quantite > produit.stock:
            messages.error(request, "Stock insuffisant pour cette sortie.")
            return redirect("ajouter_mouvement_stock")

        # Cr√©ation du mouvement
        mouvement = MouvementStock.objects.create(
            produit=produit,
            type_mouvement=type_mouvement,
            quantite=quantite,
            utilisateur=request.user,
            commentaire=commentaire
        )

        # Mise √† jour manuelle du stock (si save() ne le fait pas)
        if type_mouvement == "entree":
            produit.stock += quantite
        elif type_mouvement == "sortie":
            produit.stock -= quantite
        produit.save()

        messages.success(request, "Mouvement enregistr√© avec succ√®s.")
        return redirect("ajouter_mouvement_stock")

    return render(request, "inventaire/ajouter_mouvement.html", {"produits": produits})



#liste mouvement
from django.utils.dateparse import parse_date

@login_required
def liste_mouvements_stock(request):
    mouvements = MouvementStock.objects.select_related('produit', 'utilisateur').order_by('-date_mouvement')

    # Filtres
    produit_id = request.GET.get("produit")
    type_mouvement = request.GET.get("type")
    utilisateur_id = request.GET.get("utilisateur")
    date_debut = request.GET.get("date_debut")
    date_fin = request.GET.get("date_fin")

    if produit_id:
        mouvements = mouvements.filter(produit_id=produit_id)
    if type_mouvement:
        mouvements = mouvements.filter(type_mouvement=type_mouvement)
    if utilisateur_id:
        mouvements = mouvements.filter(utilisateur_id=utilisateur_id)
    if date_debut:
        mouvements = mouvements.filter(date_mouvement__gte=parse_date(date_debut))
    if date_fin:
        mouvements = mouvements.filter(date_mouvement__lte=parse_date(date_fin))

    produits = Produit.objects.all()
    utilisateurs = User.objects.all()

    context = {
        'mouvements': mouvements,
        'produits': produits,
        'utilisateurs': utilisateurs,
        'filtres': {
            'produit': produit_id,
            'type': type_mouvement,
            'utilisateur': utilisateur_id,
            'date_debut': date_debut,
            'date_fin': date_fin,
        }
    }
    return render(request, "inventaire/liste_mouvements.html", context)

# üî¢ Saisie de l'inventaire physique
@login_required
def saisie_inventaire(request):
    produits = Produit.objects.all()

    if request.method == "POST":
        for produit in produits:
            field_name = f"physique_{produit.id}"
            try:
                stock_physique = int(request.POST.get(field_name, 0))
            except ValueError:
                stock_physique = 0

            stock_theorique = produit.stock
            ecart = stock_physique - stock_theorique

            InventairePhysique.objects.create(
                produit=produit,
                stock_theorique=stock_theorique,
                stock_physique=stock_physique,
                ecart=ecart,
                utilisateur=request.user
            )

        messages.success(request, "Inventaire enregistr√© avec succ√®s. Passez √† la validation.")
        return redirect("liste_inventaires")

    return render(request, "inventaire/saisir_inventaire.html", {"produits": produits})


# üìã Liste des inventaires non valid√©s
@login_required
def liste_inventaires(request):
    inventaires = InventairePhysique.objects.filter(valide=False).select_related("produit")

    if request.method == "POST":
        for inv in inventaires:
            produit = inv.produit
            produit.stock = inv.stock_physique
            produit.save()

            inv.valide = True
            inv.save()

            MouvementStock.objects.create(
                produit=produit,
                type_mouvement="ajustement",
                quantite=abs(inv.ecart),
                commentaire=f"Ajustement suite √† inventaire (√©cart : {inv.ecart:+})",
                utilisateur=request.user
            )

        messages.success(request, "Stocks ajust√©s avec succ√®s.")
        return redirect("liste_inventaires")

    return render(request, "inventaire/liste_inventaires.html", {"inventaires": inventaires})


# ‚úÖ Validation manuelle d‚Äôun inventaire (option alternative)
@require_POST
@login_required
def valider_inventaire(request):
    for key, value in request.POST.items():
        if key.startswith("quantite_physique_"):
            produit_id = key.split("_")[-1]
            try:
                produit = Produit.objects.get(id=produit_id)
                quantite_physique = int(value)
                ecart = quantite_physique - produit.stock

                if ecart != 0:
                    produit.stock = quantite_physique
                    produit.save()

                    MouvementStock.objects.create(
                        produit=produit,
                        type_mouvement="ajustement",
                        quantite=abs(ecart),
                        commentaire=f"Ajustement suite √† inventaire (√©cart : {ecart:+})",
                        utilisateur=request.user
                    )

            except (Produit.DoesNotExist, ValueError):
                continue

    messages.success(request, "Inventaire valid√© et stocks mis √† jour.")
    return redirect("liste_inventaires")




# partie 1 selection 



#rapport mouvement
@login_required
def rapport_mouvements(request):
    mouvements = MouvementStock.objects.select_related('produit', 'utilisateur').order_by('-date_mouvement')

    # Filtres
    date_debut = request.GET.get("date_debut")
    date_fin = request.GET.get("date_fin")
    type_mouvement = request.GET.get("type")

    if date_debut:
        mouvements = mouvements.filter(date_mouvement__date__gte=parse_date(date_debut))
    if date_fin:
        mouvements = mouvements.filter(date_mouvement__date__lte=parse_date(date_fin))
    if type_mouvement:
        mouvements = mouvements.filter(type_mouvement=type_mouvement)

    # Export CSV
    if request.GET.get("export") == "csv":
        return export_mouvements_csv(mouvements)
    
    # Impression sp√©cifique
    if request.GET.get("print") == "1":
        context = {
            "mouvements": mouvements,
            "date_debut": date_debut,
            "date_fin": date_fin,
            "type_mouvement": type_mouvement,
            "print_mode": True  # Nouveau contexte pour le mode impression
        }
        return render(request, "rapports/rapport_mouvements_print.html", context)

    context = {
        "mouvements": mouvements,
        "date_debut": date_debut,
        "date_fin": date_fin,
        "type_mouvement": type_mouvement,
    }
    return render(request, "rapports/rapport_mouvements.html", context)

def export_mouvements_csv(mouvements):
    response = HttpResponse(content_type="text/csv")
    response["Content-Disposition"] = "attachment; filename=mouvements_stock.csv"

    writer = csv.writer(response)
    writer.writerow(["Date", "Produit", "Type", "Quantit√©", "Commentaire", "Utilisateur"])

    for m in mouvements:
        writer.writerow([
            m.date_mouvement.strftime("%Y-%m-%d %H:%M"),
            m.produit.nom,
            m.get_type_mouvement_display(),
            m.quantite,
            m.commentaire,
            m.utilisateur.username,
        ])

    return response

#rapport d'alert
@login_required
def rapport_alertes_pdf(request):
    produits_alertes = Produit.objects.filter(stock__lte=F('seuil_alerte'))
    infos = Parametre.objects.first()

    template = get_template("rapports/rapport_alertes_pdf.html")
    html = template.render({
        "produits_alertes": produits_alertes,
        "entreprise": infos,
        "user": request.user
    })

    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = 'attachment; filename="produits_en_alerte.pdf"'
    
    pisa.CreatePDF(BytesIO(html.encode("UTF-8")), dest=response)
    return response

def rapport(request):
    return render(request,"rapports/rapport.html")

def rapport_alert(request):
    return render(request,"rapports/rapport_alert.html")


#ecart rapport



@login_required
def rapport_ecarts_inventaire_pdf(request):
    ecarts = InventairePhysique.objects.filter(ecart__isnull=False).order_by('-date')
    template = get_template("rapports/rapport_ecarts_pdf.html")
    context = {
        "ecarts": ecarts,
        "user": request.user,
        "now": now(),
    }
    html_content = template.render(context)

    buffer = BytesIO()
    HTML(string=html_content).write_pdf(buffer)
    pdf_content = buffer.getvalue()

    response = HttpResponse(pdf_content, content_type='application/pdf')
    response['Content-Disposition'] = 'inline; filename="rapport_ecarts_inventaire.pdf"'
    response['Content-Length'] = len(pdf_content)
    return response

#liste cloture
@login_required
def clotures_du_jour(request):
    today = timezone.now().date()
    clotures = ClotureCaisse.objects.filter(date_jour=today)

    return render(request, "cloture/clotures_du_jour.html", {
        "clotures": clotures,
        "aujourd_hui": today
    })

#pdf cloture
def telecharger_rapport_cloture_pdf(request):
    cloture = ClotureCaisse.objects.filter(vendeur=request.user, date_jour=timezone.now().date()).first()
    if not cloture:
        return HttpResponse("Aucune cl√¥ture trouv√©e pour aujourd‚Äôhui.")

    html_string = render_to_string("cloture/rapport_cloture_pdf.html", {"cloture": cloture})
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = 'attachment; filename="rapport_cloture.pdf"'

    HTML(string=html_string).write_pdf(response)
    return response


from django.shortcuts import render
from django.http import JsonResponse
from django.core.files.base import ContentFile
from .models import Produit, Categorie
import base64, json

def ajout_multiple_produits(request):
    if request.method == 'GET':
        categories = Categorie.objects.all()
        return render(request, 'produit/ajout_multiple.html', {'categories': categories})

    elif request.method == 'POST':
        try:
            if not request.POST.get('produits_data'):
                return JsonResponse({'success': False, 'error': 'Aucune donn√©e re√ßue'}, status=400)

            produits_data = json.loads(request.POST['produits_data'])
            categorie_id = request.POST.get('categorie')

            produits_crees = []

            for produit_data in produits_data:
                if not all(key in produit_data for key in ['nom', 'prix_achat', 'prix_vente']):
                    continue

                produit = Produit(
                    nom=produit_data['nom'],
                    description=produit_data.get('description', ''),
                    prix_achat=float(produit_data['prix_achat']),
                    prix_vente=float(produit_data['prix_vente']),
                    stock=int(produit_data.get('stock', 0)),
                    seuil_alerte=int(produit_data.get('seuil_alerte', 10))
                )

                if categorie_id:
                    try:
                        produit.categorie = Categorie.objects.get(id=categorie_id)
                    except Categorie.DoesNotExist:
                        pass

                if produit_data.get('photo_data'):
                    try:
                        format, imgstr = produit_data['photo_data'].split(';base64,')
                        ext = format.split('/')[-1]
                        photo_data = base64.b64decode(imgstr)
                        produit.photo.save(
                            f"{produit_data['nom']}_{produit_data['prix_vente']}.{ext}",
                            ContentFile(photo_data),
                            save=False
                        )
                    except Exception as e:
                        print(f"Erreur traitement photo: {str(e)}")

                produit.save()
                produits_crees.append(produit.id)

            return JsonResponse({
                'success': True,
                'message': f'{len(produits_crees)} produits cr√©√©s avec succ√®s',
                'produits_ids': produits_crees
            })

        except json.JSONDecodeError as e:
            return JsonResponse({'success': False, 'error': f'Donn√©es JSON invalides: {str(e)}'}, status=400)
        except Exception as e:
            return JsonResponse({'success': False, 'error': str(e)}, status=500)

    return JsonResponse({'success': False, 'error': 'M√©thode non autoris√©e'}, status=405)


def modifier_produit(request, pk):
    produit = get_object_or_404(Produit, pk=pk)

    if request.method == 'POST':
        produit.nom = request.POST.get('nom')
        produit.reference = request.POST.get('reference')
        produit.categorie_id = request.POST.get('categorie') or None
        produit.prix_achat = request.POST.get('prix_achat') or 0
        produit.prix_vente = request.POST.get('prix_vente') or 0
        produit.stock = request.POST.get('stock') or 0
        produit.tva = request.POST.get('tva') or 0
        produit.description = request.POST.get('description')

        # Gestion de la nouvelle image si elle est envoy√©e
        if request.FILES.get('photo'):
            produit.photo = request.FILES['photo']

        produit.save()
        messages.success(request,f" Produit  {produit.nom} modifier")
        return redirect('produits_par_categorie')

    context = {
        'produit': produit,
        'categories': Categorie.objects.all(),
    }
    return render(request, 'produit/modifier_produit.html', context)

def imprimer_produit(request, pk):
    """G√©n√®re la version PDF de la fiche produit"""
    produit = get_object_or_404(Produit, pk=pk)
    parametres = Parametre.objects.first()
    
    # G√©n√©ration du code-barres (identique √† la vue HTML)
    codebarres_img = None
    if produit.code:
        try:
            code = barcode.get('code128', produit.code, writer=ImageWriter())
            buffer = BytesIO()
            code.write(buffer)
            codebarres_img = base64.b64encode(buffer.getvalue()).decode('utf-8')
        except:
            pass
    
    context = {
        'produit': produit,
        'parametres': parametres,
        'date_impression': timezone.now().strftime("%d/%m/%Y %H:%M"),
        'codebarres_img': codebarres_img
    }
    
    template = get_template('produit/fiche_produit_pdf.html')
    html_content = template.render(context)
    
    buffer_pdf = BytesIO()
    HTML(string=html_content).write_pdf(buffer_pdf)
    buffer_pdf.seek(0)
    
    identifiant = getattr(produit, 'reference', None) or produit.code or produit.id
    nom_fichier = f"Fiche_Produit_{identifiant}.pdf"
    
    return FileResponse(buffer_pdf, content_type='application/pdf', filename=nom_fichier)

from django.shortcuts import render, get_object_or_404
from django.utils import timezone
from django.http import FileResponse
from django.template.loader import get_template
from weasyprint import HTML
from io import BytesIO
import base64


from django.shortcuts import get_object_or_404, render
from django.utils import timezone
from django.db.models import Avg, F
from .models import Produit, Parametre, TauxChange, Categorie
from decimal import Decimal, InvalidOperation
import base64
from io import BytesIO

def voir_produit(request, pk):
    """Affiche la fiche produit avec gestion robuste des donn√©es"""
    try:
        # R√©cup√©ration s√©curis√©e du produit
        produit = get_object_or_404(Produit, pk=pk)
        
        # Pr√©paration des donn√©es du produit avec valeurs par d√©faut
        produit_data = {
            'id': produit.id,
            'nom': produit.nom,
            'description': produit.description or "Aucune description disponible",
            'prix_achat': float(produit.prix_achat),
            'prix_vente': float(produit.prix_vente),
            'prix_vente_suggere': float(produit.prix_vente_suggere()),
            'stock': produit.stock,
            'seuil_alerte': produit.seuil_alerte,
            'taux_tva': float(produit.taux_tva),
            'code_barre_numero': produit.code_barre_numero or "",
            'categorie': produit.categorie,
            'actif': produit.actif,
            'has_photo': bool(produit.photo),
            'has_code_barre': bool(produit.code_barre),
        }

        # Gestion du created_by si le champ existe
        if hasattr(produit, 'created_by') and produit.created_by:
            created_by_info = produit.created_by.get_full_name() or produit.created_by.username
        else:
            created_by_info = "Syst√®me"

        # Param√®tres et taux de change
        parametres = Parametre.objects.first()
        taux_usd = taux_eur = taux_produit = None
        prix_achat_usd = prix_vente_usd = None
        date_taux = timezone.now().date().strftime("%d/%m/%Y")

        if parametres:
            try:
                # Taux de change USD
                if parametres.devise_principale != 'USD':
                    taux_usd = TauxChange.get_taux('USD', parametres.devise_principale)
                    if taux_usd:
                        prix_achat_usd = produit_data['prix_achat'] / float(taux_usd)
                        prix_vente_usd = produit_data['prix_vente'] / float(taux_usd)
                
                # Taux de change EUR
                if parametres.devise_principale not in ['USD', 'EUR']:
                    taux_eur = TauxChange.get_taux('EUR', parametres.devise_principale)
            except (TypeError, InvalidOperation, AttributeError) as e:
                print(f"Erreur conversion devise: {e}")

        # Gestion des images
        photo_base64 = None
        code_barre_base64 = None
        
        if produit.photo:
            try:
                with produit.photo.open('rb') as photo_file:
                    photo_base64 = base64.b64encode(photo_file.read()).decode('utf-8')
            except Exception as e:
                print(f"Erreur lecture photo: {e}")

        if produit.code_barre:
            try:
                with produit.code_barre.open('rb') as barcode_file:
                    code_barre_base64 = base64.b64encode(barcode_file.read()).decode('utf-8')
            except Exception as e:
                print(f"Erreur lecture code-barres: {e}")

        # Calcul de la marge
        marge_brute = produit_data['prix_vente'] - produit_data['prix_achat']
        try:
            pourcentage_marge = (marge_brute / produit_data['prix_achat']) * 100
        except ZeroDivisionError:
            pourcentage_marge = 0

        # Pr√©paration du contexte final
        context = {
            'produit': produit_data,
            'parametres': parametres,
            'photo_base64': photo_base64,
            'code_barre_base64': code_barre_base64,
            'taux_usd': float(taux_usd) if taux_usd else None,
            'taux_eur': float(taux_eur) if taux_eur else None,
            'prix_achat_usd': round(prix_achat_usd, 2) if prix_achat_usd else None,
            'prix_vente_usd': round(prix_vente_usd, 2) if prix_vente_usd else None,
            'marge_brute': round(marge_brute, 2),
            'pourcentage_marge': round(pourcentage_marge, 2),
            'created_by_info': created_by_info,
            'date_impression': timezone.now().strftime("%d/%m/%Y √† %H:%M"),
            'date_taux': date_taux,
        }

        return render(request, 'produit/fiche_produit.html', context)

    except Exception as e:
        # Contexte minimal en cas d'erreur grave
        context = {
            'error': str(e),
            'produit_id': pk,
            'produit': {
                'nom': 'Produit non trouv√©',
                'description': 'Impossible de charger les d√©tails du produit',
                'prix_achat': 0,
                'prix_vente': 0,
                'stock': 0,
                'seuil_alerte': 0,
            },
            'created_by_info': "Syst√®me",
            'photo_base64': None,
            'code_barre_base64': None,
        }
        return render(request, 'produit/fiche_produit.html', context, status=500)
def imprimer_produit(request, pk):
    """G√©n√®re la version PDF"""
    try:
        produit = get_object_or_404(Produit, pk=pk)
        parametres = Parametre.objects.first()
        
        context = {
            'produit': produit,
            'parametres': parametres,
            'date_impression': timezone.now().strftime("%d/%m/%Y %H:%M"),
            'code_barre_img': None
        }
        
        if produit.code_barre:
            try:
                with open(produit.code_barre.path, "rb") as image_file:
                    context['code_barre_img'] = base64.b64encode(image_file.read()).decode('utf-8')
            except Exception as e:
                print(f"Erreur lecture code-barres PDF: {e}")
        
        template = get_template('produit/fiche_produit.html')
        html_content = template.render(context)
        
        buffer = BytesIO()
        HTML(string=html_content).write_pdf(buffer)
        buffer.seek(0)
        
        nom_fichier = f"Fiche_Produit_{produit.nom.replace(' ', '_')}_{produit.id}.pdf"
        return FileResponse(buffer, content_type='application/pdf', filename=nom_fichier)
        
    except Exception as e:
        return render(request, 'produit/fiche_produit.html', {'error': str(e)}, status=500)
    
    

from openpyxl.styles import Font


import openpyxl
from openpyxl.styles import Font
from django.http import HttpResponse
from .models import Produit

def exporter_produits_excel(request):
    wb = openpyxl.Workbook()
    ws = wb.active
    ws.title = "Produits en stock"

    # En-t√™tes
    headers = ['ID', 'Nom', 'Cat√©gorie', 'Prix Achat', 'Prix Vente', 'Stock','Seuil_alerte']
    ws.append(headers)

    # Style pour l'ent√™te
    for col in range(1, len(headers) + 1):
        ws.cell(row=1, column=col).font = Font(bold=True)

    # Donn√©es
    produits = Produit.objects.filter(stock__gt=0)

    for p in produits:
        ws.append([
            p.id,
            p.nom,
            p.categorie.nom if p.categorie else 'Non class√©',
            p.prix_achat,
            p.prix_vente,
            p.stock,
            p.seuil_alerte,
        ])

    # G√©n√©ration du fichier
    response = HttpResponse(
        content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    )
    response['Content-Disposition'] = 'attachment; filename=produits_en_stock.xlsx'
    wb.save(response)
    return response
import io
def exporter_produits_pdf(request):
    categorie_id = request.GET.get('categorie')

    produits = Produit.objects.all()
    if categorie_id:
        produits = produits.filter(categorie_id=categorie_id)

    context = {
        'produits': produits,
        'parametres': Parametre.objects.first(),
        'user': request.user,
        'now': timezone.now(),
    }

    html = render_to_string("produit/produits_pdf.html", context)
    response = HttpResponse(content_type="application/pdf")
    response['Content-Disposition'] = 'attachment; filename="liste_produits.pdf"'  # Chang√© de 'inline' √† 'attachment'
    HTML(string=html).write_pdf(response)
    return response




#export bd
from django.http import HttpResponse
from django.core.management import call_command
import io
from datetime import datetime
from django.contrib.admin.views.decorators import staff_member_required

@staff_member_required
def telecharger_sauvegarde(request):
    now = datetime.now().strftime('%Y-%m-%d_%H-%M')
    buffer = io.StringIO()
    call_command('dumpdata', indent=2, stdout=buffer)
    response = HttpResponse(buffer.getvalue(), content_type='application/json')
    response['Content-Disposition'] = f'attachment; filename=backup_{now}.json'
    return response
#facture

def creer_facture(request, commande_id):
    commande = get_object_or_404(Commande, pk=commande_id)
    
    if request.method == 'POST':
        numero = request.POST.get('numero')
        if not numero:
            numero = f"FACT-{commande.id}-{commande.date_commande.year}"
        
        facture = Facture.objects.create(
            commande=commande,
            numero=numero,
            montant_total=commande.montant_total
        )
        messages.success(request, 'Facture cr√©√©e avec succ√®s!')
        return redirect('detail_facture', pk=facture.id)
    
    return render(request, 'factures/creer_facture.html', {'commande': commande})

from django.views.decorators.http import require_http_methods
from django.contrib import messages

@require_http_methods(["POST"])
def enregistrer_paiement(request, facture_id):
    facture = get_object_or_404(Facture, id=facture_id)
    
    try:
        montant = Decimal(request.POST.get('montant', 0))
        methode = request.POST.get('methode', 'especes')
        
        if montant <= 0:
            messages.error(request, "Le montant doit √™tre positif")
            return redirect('detail_facture', pk=facture.id)
            
        # Cr√©e le paiement (qui mettra √† jour la facture automatiquement)
        Paiement.objects.create(
            facture=facture,
            montant=montant,
            methode=methode
        )
        
        messages.success(request, "Paiement enregistr√© avec succ√®s !")
        return redirect('detail_facture', pk=facture.id)
        
    except (ValueError, InvalidOperation):
        messages.error(request, "Montant invalide")
        return redirect('detail_facture', pk=facture.id)
    
    
def detail_facture(request, pk):
    facture = get_object_or_404(Facture, pk=pk)
    parametres = Parametre.objects.first()
    context = {
        'facture': facture,
        'paiements': facture.paiement_set.all(),
        'reste': facture.reste_a_payer(),
        'parametres': parametres
    }
    return render(request, 'factures/detail_facture.html', context)

from reportlab.pdfgen import canvas
def facture_pdf(request, pk):
    facture = get_object_or_404(Facture, pk=pk)
    response = HttpResponse(content_type='application/pdf')
    p = canvas.Canvas(response)
    p.drawString(100, 750, f"Facture {facture.numero}")
    p.showPage()
    p.save()
    return response

# Dans views.py
from django.views.generic import CreateView

class AjoutPaiement(CreateView):
    model = Paiement
    fields = ['montant', 'methode']
    template_name = 'factures/ajout_paiement.html'

    def form_valid(self, form):
        form.instance.facture = get_object_or_404(Facture, pk=self.kwargs['pk'])
        return super().form_valid(form)

def liste_paiements(request):
    # R√©cup√©ration des param√®tres de l'entreprise
    parametres = Parametre.objects.first()
    
    # R√©cup√©ration de tous les paiements avec les relations optimis√©es
    paiements = Paiement.objects.select_related(
        'facture', 
        'facture__commande', 
        'facture__commande__client'
    ).order_by('-date')

    # Calcul des statistiques globales
    stats = paiements.aggregate(
        total=Sum('montant'),
        count=Count('id'),
        moyenne=Avg('montant')
    )

    # Pr√©paration du contexte
    context = {
        'parametres': parametres,
        'paiements': paiements,
        'methodes': Paiement.methodes_disponibles(),
        'total_paiements': stats['total'] or 0,
        'moyenne_paiements': stats['moyenne'] or 0,
    }
    
    return render(request, 'factures/liste_paiements.html', context)


from django.shortcuts import render, get_object_or_404, redirect
from django.contrib import messages


def liste_factures(request):
    factures = Facture.objects.all().order_by('-date')
    context = {'factures': factures}
    return render(request, 'factures/liste_factures.html', context)

def liste_paiements(request):
    paiements = Paiement.objects.select_related('facture').order_by('-date')
    context = {'paiements': paiements}
    return render(request, 'factures/liste_paiements.html', context)

def actions_facture(request, facture_id):
    facture = get_object_or_404(Facture, pk=facture_id)
    
    if request.method == 'POST':
        action = request.POST.get('action')
        
        if action == 'marquer_payee' and facture.reste_a_payer() <= 0:
            facture.statut = 'payee'
            facture.save()
            messages.success(request, "Facture marqu√©e comme pay√©e")
        
        elif action == 'annuler':
            facture.statut = 'annulee'
            facture.save()
            messages.warning(request, "Facture annul√©e")
            
        return redirect('liste_factures')
    
    return render(request, 'factures/actions_facture.html', {'facture': facture})








from django.views.generic import ListView, CreateView, UpdateView, DetailView
from django.urls import reverse_lazy
from django.contrib.messages.views import SuccessMessageMixin

class FournisseurListView(ListView):
    model = Fournisseur
    template_name = 'achats/fournisseur_list.html'
    context_object_name = 'fournisseurs'
    paginate_by = 10

    def get_queryset(self):
        queryset = super().get_queryset()
        search_query = self.request.GET.get('search')
        type_filter = self.request.GET.get('type')
        
        if search_query:
            queryset = queryset.filter(Q(nom__icontains=search_query) | Q(telephone__icontains=search_query))
        if type_filter:
            queryset = queryset.filter(type=type_filter)
            
        return queryset

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['search_query'] = self.request.GET.get('search', '')
        context['selected_type'] = self.request.GET.get('type', '')
        return context

class FournisseurCreateView(SuccessMessageMixin, CreateView):
    model = Fournisseur
    template_name = 'achats/fournisseur_form.html'
    fields = ['nom', 'type', 'telephone', 'email', 'adresse', 'notes']
    success_url = reverse_lazy('fournisseur_list')
    success_message = "Fournisseur cr√©√© avec succ√®s"
    
    
class FournisseurDetailView(DetailView):
    model = Fournisseur
    template_name = 'achats/fournisseur_detail.html'
    context_object_name = 'fournisseur'

class FournisseurUpdateView(SuccessMessageMixin, UpdateView):
    model = Fournisseur
    template_name = 'achats/fournisseur_form.html'
    fields = ['nom', 'type', 'telephone', 'email', 'adresse', 'notes']
    success_url = reverse_lazy('fournisseur_list')
    success_message = "Fournisseur modifi√© avec succ√®s"

from django.views.generic.edit import DeleteView
from django.urls import reverse_lazy
from django.contrib import messages
from django.db.models import ProtectedError
from django.shortcuts import redirect
from .models import Fournisseur

class FournisseurDeleteView(DeleteView):
    model = Fournisseur
    template_name = 'achats/fournisseur_confirm_delete.html'
    success_url = reverse_lazy('fournisseur_list')

    def post(self, request, *args, **kwargs):
        self.object = self.get_object()
        try:
            self.object.delete()
            messages.success(request, "Fournisseur supprim√© avec succ√®s.")
        except ProtectedError:
            messages.error(request, "Ce fournisseur ne peut pas √™tre supprim√© car il est li√© √† un ou plusieurs achats.")
        return redirect(self.success_url)



class AchatCreateView(SuccessMessageMixin, CreateView):
    model = Achat
    template_name = 'achats/achat_form.html'
    fields = ['fournisseur', 'produit', 'quantite', 'prix_unitaire', 'date_achat', 'numero_facture', 'notes']
    success_message = "Achat enregistr√© avec succ√®s"

    def form_valid(self, form):
        form.instance.created_by = self.request.user
        return super().form_valid(form)

    def get_success_url(self):
        return reverse_lazy('achat_detail', kwargs={'pk': self.object.pk})

class AchatDetailView(DetailView):
    model = Achat
    template_name = 'achats/achat_detail.html'

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        achat = self.object

        # ‚úÖ V√©rifie que l'objet Parametre existe dans ta base de donn√©es
        context['parametres'] = Parametre.objects.first()

        # ‚úÖ Stock avant achat
        context['stock_avant'] = achat.produit.stock - achat.quantite if achat.quantite else achat.produit.stock

        # ‚úÖ Auteur de l'achat
        context['auteur_achat'] = achat.created_by if achat.created_by else None

        return context
    
    
    
from weasyprint import HTML, CSS  
    
 #impression    
def achat_pdf_view(request, pk):
    achat = get_object_or_404(Achat, pk=pk)
    parametres = Parametre.objects.first()
    
    # Calcul des montants
    taux_tva = Decimal(parametres.taux_tva) if parametres else Decimal(0)
    total_ttc = Decimal(achat.quantite) * Decimal(achat.prix_unitaire)
    
    # Calcul HT et TVA
    if taux_tva:
        total_ht = total_ttc / (1 + taux_tva/100)
        montant_tva = total_ttc - total_ht
    else:
        total_ht = total_ttc
        montant_tva = Decimal(0)

    # Conversion devise
    taux_change = Decimal(1)
    montant_converti = None
    if achat.devise != parametres.devise_principale:
        taux_change = TauxChange.get_taux(achat.devise, parametres.devise_principale) or Decimal(1)
        montant_converti = total_ttc * taux_change

    context = {
        'achat': achat,
        'parametres': parametres,
        'total_ttc': total_ttc,  # Le total TTC principal
        'total': total_ttc,      # Alias pour compatibilit√© template
        'total_ht': total_ht,
        'montant_tva': montant_tva,
        'taux_tva': taux_tva,
        'taux_change': taux_change,
        'montant_converti': montant_converti,
        'stock_avant': achat.produit.stock - achat.quantite,
        'auteur': achat.created_by,
        'date_generation': timezone.now(),
    }
    
    if parametres.logo:
        context['logo_path'] = parametres.logo.path

    template = get_template("achats/achat_pdf.html")
    html = template.render(context)
    
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = f'inline; filename="facture_achat_{achat.id}.pdf"'
    HTML(string=html).write_pdf(response)
    return response


from django.contrib.auth.mixins import LoginRequiredMixin

from django.views.generic import ListView
from django.db.models import DecimalField
from decimal import Decimal
from django.core.exceptions import ValidationError
from django.contrib.auth.mixins import LoginRequiredMixin


class AchatListView(LoginRequiredMixin, ListView):
    model = Achat
    template_name = 'achats/achat_list.html'
    context_object_name = 'achats'
    paginate_by = 15

    def get_queryset(self):
        queryset = super().get_queryset().select_related('fournisseur', 'produit')

        date_debut = self.request.GET.get('date_debut')
        date_fin = self.request.GET.get('date_fin')
        fournisseur_id = self.request.GET.get('fournisseur')

        if date_debut:
            queryset = queryset.filter(date_achat__gte=date_debut)
        if date_fin:
            queryset = queryset.filter(date_achat__lte=date_fin)
        if fournisseur_id:
            queryset = queryset.filter(fournisseur_id=fournisseur_id)

        return queryset.order_by('-date_achat')

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)

        try:
            parametres = Parametre.objects.get(user=self.request.user)
            devise_principale = parametres.devise_principale
            devises_acceptees = parametres.devises_acceptees or ['USD', 'CDF']
        except Parametre.DoesNotExist:
            devise_principale = 'USD'
            devises_acceptees = ['USD', 'CDF']

        devise_affichee = self.request.session.get('devise_affichee', devise_principale)
        if devise_affichee not in devises_acceptees:
            devise_affichee = devise_principale
            self.request.session['devise_affichee'] = devise_affichee

        devise_symbols = {
            'USD': '$',
            'EUR': '‚Ç¨',
            'CDF': 'FC',
            'XOF': 'CFA',
            'FC': 'FC',
        }

        achats = context['achats']
        total_achats = Decimal('0.00')
        total_quantite = Decimal('0.00')

        for achat in achats:
            try:
                if achat.devise != devise_affichee:
                    taux = TauxChange.get_taux(achat.devise, devise_affichee)
                    if taux is None:
                        raise ValidationError(f"Taux non disponible entre {achat.devise} et {devise_affichee}")
                    achat.prix_unitaire_converti = achat.prix_unitaire * taux
                    achat.total_converti = achat.total_achat * taux
                else:
                    achat.prix_unitaire_converti = achat.prix_unitaire
                    achat.total_converti = achat.total_achat

                total_achats += achat.total_converti
                total_quantite += achat.quantite

            except (ValidationError, Exception) as e:
                print(f"Erreur conversion devise pour achat {achat.id}: {str(e)}")
                achat.prix_unitaire_converti = achat.prix_unitaire
                achat.total_converti = achat.total_achat
                total_achats += achat.total_achat
                total_quantite += achat.quantite

        context.update({
            'total_achats': total_achats,
            'total_quantite': total_quantite,
            'achats_count': achats.count(),
            'devise_affichee': devise_affichee,
            'devises_disponibles': devises_acceptees,
            'devise_symbols': devise_symbols,
            'fournisseurs': Fournisseur.objects.all().order_by('nom'),
            'selected_fournisseur': self.request.GET.get('fournisseur', ''),
            'date_debut': self.request.GET.get('date_debut', ''),
            'date_fin': self.request.GET.get('date_fin', ''),
            'devise_principale': devise_principale,
        })

        return context


   

@login_required
def liste_notifications(request):
    notifications = request.user.notifications.all().order_by('-date_creation')
    return render(request, 'notifications/liste.html', {'notifications': notifications})


def notifier_facture_impayee(facture):
    if not facture.est_payee:
        for utilisateur in User.objects.filter(is_staff=True):
            Notification.objects.create(
                utilisateur=utilisateur,
                message=f"Facture #{facture.id} non pay√©e pour {facture.client.nom}.",
                url=f"/factures/{facture.id}/"
            )


#facture pdf 
from django.http import HttpResponse, Http404
from django.template.loader import get_template
from django.views import View
from django.contrib.auth.mixins import LoginRequiredMixin
from xhtml2pdf import pisa
from io import BytesIO
import logging
import os
logger = logging.getLogger(__name__)

class FacturePDFView(LoginRequiredMixin, View):
    def get(self, request, pk):
        try:
            facture = Facture.objects.select_related(
                'commande__client',
                'commande__vendeur'
            ).prefetch_related(
                'commande__lignes__produit'
            ).get(pk=pk)
        except Facture.DoesNotExist:
            raise Http404("Facture non trouv√©e.")
        
        parametres = Parametre.objects.first()
        
        context = {
            "facture": facture,
            "parametres": parametres,
            "user": request.user,
        }

        try:
            template = get_template("factures/facture_pdf.html")
            html = template.render(context)
            
            result = BytesIO()
            
            # Configuration suppl√©mentaire pour xhtml2pdf
            pdf = pisa.pisaDocument(
                BytesIO(html.encode("UTF-8")),
                result,
                encoding='UTF-8',
                link_callback=self.link_callback
            )
            
            if not pdf.err:
                response = HttpResponse(result.getvalue(), content_type='application/pdf')
                filename = f"facture_{facture.numero or facture.id}.pdf"
                response['Content-Disposition'] = f'inline; filename="{filename}"'
                return response
            else:
                logger.error(f"Erreur PDF: {pdf.err}")
                return HttpResponse("Erreur lors de la g√©n√©ration du PDF", status=500)
                
        except Exception as e:
            logger.error(f"Erreur g√©n√©ration facture: {str(e)}")
            return HttpResponse(f"Erreur serveur: {str(e)}", status=500)

    def link_callback(self, uri, rel):
        """
        Callback pour g√©rer les ressources (images, CSS)
        """
        # Chemin absolu pour les m√©dias
        if uri.startswith(settings.MEDIA_URL):
            path = os.path.join(settings.MEDIA_ROOT, uri.replace(settings.MEDIA_URL, ""))
        # Chemin absolu pour les fichiers statiques
        elif uri.startswith(settings.STATIC_URL):
            path = os.path.join(settings.STATIC_ROOT, uri.replace(settings.STATIC_URL, ""))
        else:
            path = None
            
        if path and os.path.isfile(path):
            return path
        return None
    
    
 
  #retour mses 
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.http import JsonResponse
from django.db import transaction

from .models import RetourProduit, LigneRetour



@login_required
def liste_retours(request):
    retours = RetourProduit.objects.select_related('commande', 'responsable').order_by('-date_creation')
    context = {
        'retours': retours,
        'statuts': dict(RetourProduit.STATUT_RETOUR)
    }
    return render(request, 'retours/liste.html', context)


@login_required
def creer_retour(request, commande_id):
    commande = get_object_or_404(Commande, id=commande_id)
    
    if request.method == 'POST':
        try:
            with transaction.atomic():
                retour = RetourProduit.objects.create(
                    commande=commande,
                    responsable=request.user,
                    motif=request.POST.get('motif'),
                    notes=request.POST.get('notes', '')
                )
                
                for ligne in commande.lignes.all():
                    quantite = int(request.POST.get(f'quantite_{ligne.id}', 0))
                    if quantite > 0:
                        LigneRetour.objects.create(
                            retour=retour,
                            produit=ligne.produit,
                            quantite=quantite,
                            prix_unitaire=ligne.prix_unitaire
                        )
                
                messages.success(request, "Retour cr√©√© avec succ√®s.")
                return redirect('detail_retour', retour.id)
                
        except Exception as e:
            messages.error(request, f"Erreur lors de la cr√©ation : {str(e)}")
    
    context = {
        'commande': commande,
        'motifs': dict(RetourProduit.MOTIF_RETOUR)
    }
    return render(request, 'retours/creer.html', context)


@login_required
def detail_retour(request, retour_id):
    retour = get_object_or_404(
        RetourProduit.objects.select_related('commande__client', 'responsable')
                             .prefetch_related('lignes__produit'),
        id=retour_id
    )

    parametre = Parametre.objects.first()  # On suppose qu'il n'y a qu'un seul enregistrement

    context = {
        'retour': retour,
        'user': request.user,
        'is_responsable': retour.responsable == request.user,
        'is_admin': request.user.is_superuser,
        'parametre': parametre,  # informations de l'entreprise
    }

    return render(request, 'retours/detail.html', context)

@login_required
def traiter_retour(request, retour_id):
    retour = get_object_or_404(RetourProduit, id=retour_id)
    
    if not hasattr(retour, 'peut_etre_traite') or not retour.peut_etre_traite():
        messages.warning(request, "Ce retour ne peut pas √™tre trait√©.")
        return redirect('detail_retour', retour.id)
    
    if request.method == 'POST':
        if retour.traiter(request.user):
            messages.success(request, "Retour trait√© avec succ√®s. Stock mis √† jour.")
        else:
            messages.error(request, "Erreur lors du traitement.")
        
        return redirect('detail_retour', retour.id)
    
    return render(request, 'retours/traiter.html', {'retour': retour})


@login_required
def get_lignes_commande(request, commande_id):
    commande = get_object_or_404(Commande, id=commande_id)
    lignes = LigneCommande.objects.filter(commande=commande).select_related('produit')
    
    data = [{
        'id': ligne.id,
        'produit_id': ligne.produit.id,
        'nom': ligne.produit.nom,
        'reference': ligne.produit.code_barre_numero or '-',
        'quantite_max': ligne.quantite,
        'prix': str(ligne.prix_unitaire),
    } for ligne in lignes]
    
    return JsonResponse({'data': data}, safe=False)

def parametre(request):
    return render(request,'paramettre/paramettre.html')


#remises et promotions
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth.decorators import login_required, permission_required
from django.contrib import messages
from django.http import JsonResponse
from django.db import transaction
from django.utils import timezone
from .models import Promotion, RemiseCommande

@login_required
@permission_required('promotions.can_manage_promotions', raise_exception=True)
def liste_promotions(request):
    """Liste toutes les promotions avec filtres"""
    now = timezone.now()
    
    try:
        entreprise = Parametre.objects.get(user=request.user)
    except Parametre.DoesNotExist:
        messages.error(request, "Aucune entreprise associ√©e √† cet utilisateur.")
        return redirect('dashboard')  # ou autre

    promotions = Promotion.objects.select_related('produit', 'categorie', 'created_by') \
                                  .filter(entreprise=entreprise) \
                                  .order_by('-date_creation')
    
    # Filtres
    statut = request.GET.get('statut')
    if statut == 'actives':
        promotions = promotions.filter(actif=True, date_debut__lte=now, date_fin__gte=now)
    elif statut == 'inactives':
        promotions = promotions.filter(actif=False)
    elif statut == 'futures':
        promotions = promotions.filter(date_debut__gt=now)
    elif statut == 'expirees':
        promotions = promotions.filter(date_fin__lt=now)
    
    type_remise = request.GET.get('type_remise')
    if type_remise in ['pourcentage', 'montant_fixe']:
        promotions = promotions.filter(type_remise=type_remise)
    
    return render(request, 'promotions/liste.html', {
        'promotions': promotions,
        'now': now,
        'filtres': {
            'statut': statut,
            'type_remise': type_remise
        }
    })


@login_required
@permission_required('promotions.can_manage_promotions', raise_exception=True)
def creer_promotion(request):
    """Cr√©e une nouvelle promotion"""
    if request.method == 'POST':
        try:
            with transaction.atomic():
                # R√©cup√©rer l'entreprise li√©e √† l'utilisateur
                entreprise = Parametre.objects.get(user=request.user)
                
                # Activer la promotion par d√©faut sauf si explicitement d√©sactiv√©e
                actif = 'actif' not in request.POST or request.POST.get('actif') == 'on'
                
                # Validation des donn√©es
                type_remise = request.POST.get('type_remise')
                if type_remise not in dict(Promotion.TypeRemise.choices):
                    raise ValidationError("Type de remise invalide")
                
                promotion = Promotion.objects.create(
                    nom=request.POST.get('nom'),
                    description=request.POST.get('description', ''),
                    type_remise=type_remise,
                    valeur=Decimal(request.POST.get('valeur')),  # Conversion en Decimal
                    appliquer_a=request.POST.get('appliquer_a'),
                    produit_id=request.POST.get('produit') or None,
                    categorie_id=request.POST.get('categorie') or None,
                    date_debut=request.POST.get('date_debut'),
                    date_fin=request.POST.get('date_fin'),
                    actif=actif,
                    code_promo=request.POST.get('code_promo') or None,
                    usage_unique=request.POST.get('usage_unique') == 'on',
                    utilisations_max=int(request.POST.get('utilisations_max', 1)),
                    created_by=request.user,
                    entreprise=entreprise
                )
                
                messages.success(request, "Promotion cr√©√©e avec succ√®s")
                return redirect('liste_promotions')
        
        except Parametre.DoesNotExist:
            messages.error(request, "Aucune entreprise associ√©e √† votre compte")
        except ValidationError as e:
            messages.error(request, f"Erreur de validation: {str(e)}")
        except ValueError as e:
            messages.error(request, f"Valeur incorrecte: {str(e)}")
        except Exception as e:
            messages.error(request, f"Erreur lors de la cr√©ation: {str(e)}")
            logger.error(f"Erreur cr√©ation promotion: {str(e)}", exc_info=True)
    
    # Pr√©paration des donn√©es pour le template
    produits = Produit.objects.filter(actif=True).order_by('nom')
    categories = Categorie.objects.all().order_by('nom')
    
    return render(request, 'promotions/creer.html', {
        'produits': produits,
        'categories': categories,
        'type_remise_choices': Promotion.TypeRemise.choices,
        'appliquer_a_choices': Promotion.TypeApplication.choices,
        'defaults': {
            'actif': True,
            'utilisations_max': 1,
            'type_remise': Promotion.TypeRemise.POURCENTAGE,
        }
    })
@login_required
def appliquer_promotion_commande(request, commande_id):
    commande = get_object_or_404(Commande, id=commande_id)
    if request.method == 'POST':
        code_promo = request.POST.get('code_promo', '').strip()

        try:
            promotion = Promotion.objects.get(code_promo=code_promo)

            if not promotion.est_valide():
                messages.error(request, "Cette promotion n'est plus valide.")
            elif RemiseCommande.objects.filter(commande=commande, promotion=promotion).exists():
                messages.error(request, "Cette promotion a d√©j√† √©t√© appliqu√©e √† cette commande.")
            else:
                total_ht = commande.lignes.aggregate(
                    total=Sum(
                        ExpressionWrapper(
                            F('quantite') * F('produit__prix_vente'),
                            output_field=DecimalField()
                        )
                    )
                )['total'] or 0

                montant_remise = promotion.appliquer_remise(total_ht)

                RemiseCommande.objects.create(
                    commande=commande,
                    promotion=promotion,
                    montant_remise=montant_remise
                )

                promotion.incrementer_utilisation()

                messages.success(request, f"Promotion '{promotion.nom}' appliqu√©e avec succ√®s.")

        except Promotion.DoesNotExist:
            messages.error(request, "Code promo invalide.")
        except ValidationError as e:
            messages.error(request, str(e))
        return redirect('detail_commande', commande_id=commande.id)


    promotions_actives = Promotion.objects.filter(
        actif=True,
        date_debut__lte=timezone.now(),
        date_fin__gte=timezone.now()
    ).exclude(
        utilisations_actuelles__gte=F('utilisations_max')
    )

    return render(request, 'promotions/appliquer.html', {
        'commande': commande,
        'promotions_actives': promotions_actives
    })


@login_required
def _appliquer_promotion_valide(request, commande, promotion):
    with transaction.atomic():
        # Recalculer le total avant remise
        commande.calculer_totaux()
        total_initial = commande.total_ht
        
        # Calculer la remise
        if promotion.type_remise == 'pourcentage':
            montant_remise = total_initial * (promotion.valeur / 100)
        else:
            montant_remise = min(promotion.valeur, total_initial)
        
        # Cr√©er la remise
        RemiseCommande.objects.create(
            commande=commande,
            promotion=promotion,
            montant_remise=montant_remise
        )
        
        # Pas besoin de sauvegarder la commande ici, 
        # car calculer_totaux() est appel√© dans save() de RemiseCommande
        
        promotion.incrementer_utilisation()
        messages.success(request, f"Remise de {montant_remise:.2f} appliqu√©e")
    
    return redirect('detail_commande', commande_id=commande.id)



def _appliquer_promotion_produit(request, commande, promotion):
    with transaction.atomic():
        # V√©rifier que la promotion a un produit associ√©
        if not promotion.produit:
            messages.error(request, "Cette promotion n√©cessite un produit sp√©cifique")
            return redirect('detail_commande', commande_id=commande.id)
            
        # Trouver les lignes de commande concern√©es
        lignes = commande.lignes_commande.filter(produit=promotion.produit)
        
        if not lignes.exists():
            messages.error(request, f"Aucun produit '{promotion.produit.nom}' dans cette commande")
            return redirect('detail_commande', commande_id=commande.id)
            
        # Appliquer la remise √† chaque ligne concern√©e
        montant_total_remise = Decimal('0.00')
        for ligne in lignes:
            prix_initial = ligne.prix_unitaire * ligne.quantite
            prix_remise = promotion.appliquer_remise(prix_initial)
            montant_remise = prix_initial - prix_remise
            
            ligne.remise = montant_remise
            ligne.prix_total = prix_remise
            ligne.save()
            
            montant_total_remise += montant_remise
        
        # Enregistrer la remise globale
        RemiseCommande.objects.create(
            commande=commande,
            promotion=promotion,
            montant_remise=montant_total_remise
        )
        
        # Mettre √† jour le total de la commande
        commande.montant_total = commande.calculer_total()
        commande.save()
        
        # Incr√©menter l'utilisation de la promotion
        promotion.incrementer_utilisation()
        
        messages.success(
            request, 
            f"Remise de {montant_total_remise:.2f} FC appliqu√©e sur le produit {promotion.produit.nom}"
        )
    
    return redirect('detail_commande', commande_id=commande.id)


def _appliquer_promotion_categorie(request, commande, promotion):
    with transaction.atomic():
        # V√©rifier que la promotion a une cat√©gorie associ√©e
        if not promotion.categorie:
            messages.error(request, "Cette promotion n√©cessite une cat√©gorie sp√©cifique")
            return redirect('detail_commande', commande_id=commande.id)
            
        # Trouver les lignes de commande concern√©es
        lignes = commande.lignes_commande.filter(produit__categorie=promotion.categorie)
        
        if not lignes.exists():
            messages.error(request, f"Aucun produit de la cat√©gorie '{promotion.categorie.nom}' dans cette commande")
            return redirect('detail_commande', commande_id=commande.id)
            
        # Appliquer la remise √† chaque ligne concern√©e
        montant_total_remise = Decimal('0.00')
        for ligne in lignes:
            prix_initial = ligne.prix_unitaire * ligne.quantite
            prix_remise = promotion.appliquer_remise(prix_initial)
            montant_remise = prix_initial - prix_remise
            
            ligne.remise = montant_remise
            ligne.prix_total = prix_remise
            ligne.save()
            
            montant_total_remise += montant_remise
        
        # Enregistrer la remise globale
        RemiseCommande.objects.create(
            commande=commande,
            promotion=promotion,
            montant_remise=montant_total_remise
        )
        
        # Mettre √† jour le total de la commande
        commande.montant_total = commande.calculer_total()
        commande.save()
        
        # Incr√©menter l'utilisation de la promotion
        promotion.incrementer_utilisation()
        
        messages.success(
            request, 
            f"Remise de {montant_total_remise:.2f} FC appliqu√©e sur la cat√©gorie {promotion.categorie.nom}"
        )
    
    return redirect('detail_commande', commande_id=commande.id)

@login_required
@permission_required('promotions.can_manage_promotions', raise_exception=True)
def toggle_promotion(request, promotion_id):
    """Active/d√©sactive une promotion"""
    promotion = get_object_or_404(Promotion, id=promotion_id)
    promotion.actif = not promotion.actif
    promotion.save()
    
    action = "activ√©e" if promotion.actif else "d√©sactiv√©e"
    messages.success(request, f"Promotion {action} avec succ√®s")
    return redirect('liste_promotions')

@login_required
@permission_required('promotions.can_manage_promotions', raise_exception=True)
def supprimer_promotion(request, promotion_id):
    """Supprime une promotion"""
    promotion = get_object_or_404(Promotion, id=promotion_id)
    
    if request.method == 'POST':
        promotion.delete()
        messages.success(request, "Promotion supprim√©e avec succ√®s")
        return redirect('liste_promotions')
    
    return render(request, 'promotions/supprimer.html', {
        'promotion': promotion
    })
    
    
    
def appliquer_promotion(commande, code_promo):
    try:
        promotion = Promotion.objects.get(code_promo=code_promo)
        
        if not promotion.est_valide():
            return False, "Promotion invalide"
            
        if promotion.appliquer_a == 'commande':
            total_avant = commande.total_avant_remise
            total_apres = promotion.appliquer_remise(total_avant)
            remise = total_avant - total_apres
            
            RemiseCommande.objects.create(
                commande=commande,
                promotion=promotion,
                montant_remise=remise,
                details={
                    'total_avant': str(total_avant),
                    'total_apres': str(total_apres)
                }
            )
            
            promotion.incrementer_utilisation()
            return True, f"Remise de {remise} appliqu√©e"
            
        # G√©rer les autres cas (produit/cat√©gorie)
        
    except Promotion.DoesNotExist:
        return False, "Code promo invalide"   
    
    
    


@login_required
def modifier_parametres(request):
    # R√©cup√®re ou cr√©e les param√®tres en associant l'utilisateur
    param, created = Parametre.objects.get_or_create(
        user=request.user,
        defaults={
            'nom_societe': 'Nom par d√©faut',
            'adresse': 'Adresse par d√©faut',
            'telephone': '+0000000000',
            'email': 'contact@example.com',
            'taux_tva': 20.0,
            'devise_principale': 'FC',  # Chang√© de 'devise' √† 'devise_principale'
            'devises_acceptees': ['USD', 'EUR', 'CDF'],  # Ajout√©
            'taux_change_auto': False  # Ajout√©
        }
    )

    if request.method == 'POST':
        form_data = request.POST
        param.nom_societe = form_data.get('nom_societe', param.nom_societe)
        param.adresse = form_data.get('adresse', param.adresse)
        param.telephone = form_data.get('telephone', param.telephone)
        param.email = form_data.get('email', param.email)
        param.taux_tva = Decimal(form_data.get('taux_tva', param.taux_tva))  # Chang√© en Decimal
        
        # Gestion des devises
        param.devise_principale = form_data.get('devise_principale', param.devise_principale)  # Chang√© ici
        
        # Gestion des devises accept√©es (convertir la cha√Æne en liste)
        devises_acceptees = form_data.get('devises_acceptees', '')
        if devises_acceptees:
            param.devises_acceptees = [d.strip() for d in devises_acceptees.split(',')]
        
        param.taux_change_auto = form_data.get('taux_change_auto') == 'on'  # Pour les checkbox
        
        if 'logo' in request.FILES:
            param.logo = request.FILES['logo']

        param.save()
        
        messages.success(request, "Param√®tres mis √† jour avec succ√®s")
        return redirect('afficher_parametres')

    return render(request, 'parametres/edit_parametres.html', {'param': param})


def afficher_parametres(request):
    parametre, created = Parametre.objects.get_or_create(
        user=request.user,
        defaults={
            'nom_societe': 'Ma Soci√©t√©',
            # ... valeurs par d√©faut ...
        }
    )
    return render(request, 'parametres/parametres.html', {'parametre': parametre}) 




#IA PREDICATION
from django.shortcuts import render
from STOCK.ml.reapprovisionnement import generer_suggestions_reapprovisionnement

def suggestions_reapprovisionnement(request):
    suggestions = generer_suggestions_reapprovisionnement()
    return render(request, 'stock/suggestions.html', {'suggestions': suggestions})


def historique_suggestions(request):
    produit_id = request.GET.get('produit')
    date = request.GET.get('date')

    suggestions = SuggestionReapprovisionnement.objects.select_related('produit')

    if produit_id:
        suggestions = suggestions.filter(produit_id=produit_id)

    if date:
        suggestions = suggestions.filter(date_suggestion=date)

    paginator = Paginator(suggestions, 20)  # 20 suggestions par page
    page = request.GET.get('page')
    suggestions_page = paginator.get_page(page)

    produits = Produit.objects.all()

    return render(request, 'stock/historique_suggestions.html', {
        'suggestions': suggestions_page,
        'produits': produits,
        'produit_id': produit_id,
        'date': date,
    })

from django.http import HttpResponse

def export_historique_reappro(request):
    # Ton code d'export ici
    return HttpResponse("Export OK")


def FoctionnalitesIA(request):
    return render(request,"IA/Ia.html")


# # STOCK/views.py
# from django.shortcuts import render, redirect
# from django.contrib.auth.decorators import login_required

# from STOCK.ml.chatbot import repondre_au_message  # ‚úÖ Import correct

# @login_required
# def chatbot_view(request):
#     if request.method == "POST":
#         texte = request.POST.get("message")

#         # Cr√©e ou r√©cup√®re une conversation pour l'utilisateur connect√©
#         conversation, _ = Conversation.objects.get_or_create(utilisateur=request.user)

#         # Sauvegarde le message utilisateur
#         Message.objects.create(conversation=conversation, contenu=texte, role="user")

#         # Construit l'historique pour l'envoi √† ChatGPT
#         historique = [{"role": msg.role, "content": msg.contenu} for msg in conversation.messages.all()]

#         # Appelle GPT pour g√©n√©rer une r√©ponse
#         reponse = repondre_au_message(texte, historique)


#         # Sauvegarde la r√©ponse de l'assistant
#         Message.objects.create(conversation=conversation, contenu=reponse, role="assistant")

#         return redirect('chatbot')

#     # Affiche la conversation existante si elle existe
#     conversation = Conversation.objects.filter(utilisateur=request.user).first()
#     messages = conversation.messages.all() if conversation else []

#     return render(request, "IA/chatbot.html", {"messages": messages})

from django.http import JsonResponse
from django.views.decorators.http import require_POST
from django.contrib.auth.decorators import login_required
from STOCK.ml.chatbot_engine import *


@csrf_exempt
@login_required
@require_http_methods(["POST"])
def chatbot_query(request):
    try:
        query = request.POST.get('query', '').strip()
        if not query:
            return JsonResponse({'error': 'Requ√™te vide'}, status=400)
        
        engine = ChatbotEngine(request.user)
        response = engine.process_query(query)
        
        # Enregistrer la conversation
        ChatbotConversation.objects.create(
            user=request.user,
            context={'last_query': query, 'last_response': response}
        )
        
        return JsonResponse({'response': response})
    
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)
    
    

@login_required
def chatbot_view(request):
    conversations = ChatbotConversation.objects.filter(user=request.user)
    return render(request, 'IA/chatbot.html', {'conversations': conversations})




import logging
from django.shortcuts import get_object_or_404
from django.http import JsonResponse
from django.utils import timezone
from datetime import timedelta
from django.conf import settings
from django.core.cache import cache
from django.db.models import Avg, Sum
from decimal import Decimal
import json
import pandas as pd
from prophet import Prophet

def forecast_view(request, pk):
    produit = get_object_or_404(Produit, pk=pk)
    
    config = {
        'min_data_points': max(7, getattr(settings, 'FORECAST_MIN_DATA', 7)),
        'forecast_days': getattr(settings, 'FORECAST_DAYS', 30),
        'confidence_interval': getattr(settings, 'FORECAST_CONFIDENCE', 0.8),
    }
    
    try:
        # 1. V√©rification des donn√©es historiques
        commandes = LigneCommande.objects.filter(
            produit=produit,
            commande__vente_confirmee=True,
            quantite__gt=0
        ).values('commande__date_commande').annotate(
            total_quantite=Sum('quantite')
        ).order_by('commande__date_commande')
        
        data_points = len(commandes)
        
        # 2. Gestion du fallback si donn√©es insuffisantes
        if data_points < config['min_data_points']:
            fallback_reason = (
                f"Donn√©es insuffisantes (n√©cessaire: {config['min_data_points']}, "
                f"disponible: {data_points})"
            )
            return handle_forecast_fallback(
                request, 
                produit, 
                config,
                fallback_reason,
                data_points
            )
        
        # 3. Pr√©paration des donn√©es pour Prophet
        try:
            df = pd.DataFrame([{
                'ds': cmd['commande__date_commande'].strftime('%Y-%m-%d'),
                'y': float(cmd['total_quantite'])
            } for cmd in commandes])
            
            df['ds'] = pd.to_datetime(df['ds'])
            
            # V√©rification des dates uniques
            if df['ds'].nunique() < config['min_data_points']:
                raise ValueError("Pas assez de dates uniques pour l'analyse")
                
        except Exception as e:
            logger.error(f"Erreur pr√©paration donn√©es: {str(e)}", exc_info=True)
            return handle_forecast_fallback(
                request,
                produit,
                config,
                f"Erreur pr√©paration donn√©es: {str(e)}",
                data_points
            )
        
        # 4. G√©n√©ration de la pr√©vision avec Prophet
        try:
            model = Prophet(
                interval_width=config['confidence_interval'],
                daily_seasonality=False,
                weekly_seasonality=True,
                yearly_seasonality=False,
                changepoint_prior_scale=0.05  # R√©duit la sensibilit√© aux changements
            )
            
            with warnings.catch_warnings():
                warnings.simplefilter("ignore")
                model.fit(df)
            
            future = model.make_future_dataframe(
                periods=config['forecast_days'],
                freq='D'
            )
            forecast = model.predict(future)
            
            # Filtre seulement les futures pr√©visions
            last_historical_date = df['ds'].max()
            forecast = forecast[forecast['ds'] > last_historical_date]
            
            # 5. Calcul des m√©triques de performance
            try:
                from prophet.diagnostics import cross_validation, performance_metrics
                initial_days = max(30, len(df)-7)  # Correction ici
                df_cv = cross_validation(
                    model,
                    initial=f'{initial_days} days',  # Syntaxe corrig√©e
                    period='7 days',
                    horizon='7 days'
                )
                df_p = performance_metrics(df_cv)
                performance = {
                    'mdape': float(df_p['mdape'].mean()),
                    'mape': float(df_p['mape'].mean()),
                    'rmse': float(df_p['rmse'].mean()),
                    'interval': f"{int(config['confidence_interval']*100)}%"
                }
            except Exception as e:
                logger.warning(f"Erreur calcul performance: {str(e)}")
                performance = {'interval': f"{int(config['confidence_interval']*100)}%"}
            
            # 6. Formatage et enregistrement des r√©sultats
            forecast_data = []
            for _, row in forecast.iterrows():
                forecast_data.append({
                    'date': row['ds'].strftime('%Y-%m-%d'),  # Format coh√©rent
                    'pred': round(float(row['yhat']), 2),
                    'min': round(float(row['yhat_lower']), 2),
                    'max': round(float(row['yhat_upper']), 2)
                })
                
              
                
                # Enregistrement en base si la date est dans le futur
                if row['ds'].date() > timezone.now().date():
                    HistoriquePrevision.objects.update_or_create(
                        produit=produit,
                        date_prevision=row['ds'].date(),
                        defaults={
                            'quantite_predite': pred,
                            'modele_utilise': 'prophet',
                            'parametres': {
                                'confidence': config['confidence_interval'],
                                'data_points': data_points,
                                'performance': performance
                            },
                            'precision': performance.get('mdape')
                        }
                    )
            
            # 7. R√©cup√©ration de l'historique actualis√©
            historique_previsions = HistoriquePrevision.objects.filter(
                produit=produit
            ).order_by('-date_prevision')[:30]
            
            return render(request, 'IA/forecast.html', {
                'produit': produit,
                'forecast_data': forecast_data,
                'performance': performance,
                'data_points': data_points,
                'historique_previsions': historique_previsions,
                'is_fallback': False
            })
            
        except Exception as e:
            logger.error(f"Erreur Prophet: {str(e)}", exc_info=True)
            return handle_forecast_fallback(
                request,
                produit,
                config,
                f"Erreur mod√©lisation: {str(e)}",
                data_points
            )
            
    except Exception as e:
        logger.error(f"Erreur g√©n√©rale: {str(e)}", exc_info=True)
        return handle_forecast_fallback(
            request,
            produit,
            config,
            f"Erreur syst√®me: {str(e)}",
            0
        )
        
        
def handle_forecast_fallback(request, produit, config, reason, data_points):
    try:
        # 1. Calcul des statistiques de base
        stats = LigneCommande.objects.filter(
            produit=produit,
            commande__vente_confirmee=True
        ).aggregate(
            avg=Avg('quantite'),
            total=Sum('quantite'),
            count=Count('id')
        )
        
        # 2. Calcul des ventes quotidiennes moyennes
        if stats['count'] > 3 and stats['avg']:
            daily_sales = float(stats['avg'])
        else:
            # Fallback bas√© sur le stock si pas assez de donn√©es
            daily_sales = max(
                0.1,  # Minimum de 0.1 unit√©/jour
                float(produit.stock) / 30.0 if produit.stock else 1.0
            )
        
        # 3. G√©n√©ration des pr√©visions basiques
        forecast_data = []
        for i in range(1, config['forecast_days'] + 1):
            date = (timezone.now() + timedelta(days=i)).strftime('%Y-%m-%d')
            pred = round(daily_sales, 2)
            min_val = round(max(0.1, daily_sales * 0.7), 2)  # -30% avec minimum de 0.1
            max_val = round(daily_sales * 1.3, 2)            # +30%
            
            forecast_data.append((date, pred, min_val, max_val))
            
            # Enregistrement en base
            if i <= 30:  # Limite √† 30 jours pour √©viter la surcharge
                HistoriquePrevision.objects.update_or_create(
                    produit=produit,
                    date_prevision=timezone.now().date() + timedelta(days=i),
                    defaults={
                        'quantite_predite': pred,
                        'modele_utilise': 'moyenne',
                        'parametres': {
                            'fallback': True,
                            'avg_sales': daily_sales,
                            'data_points': data_points
                        }
                    }
                )
        
        # 4. R√©cup√©ration de l'historique
        historique_previsions = HistoriquePrevision.objects.filter(
            produit=produit
        ).order_by('-date_prevision')[:30]
        
        return render(request, 'IA/forecast.html', {
            'produit': produit,
            'forecast_data': forecast_data,
            'performance': {'interval': '70-130%'},
            'data_points': data_points,
            'historique_previsions': historique_previsions,
            'is_fallback': True,
            'fallback_reason': reason,
            'daily_sales': daily_sales
        })
        
    except Exception as e:
        logger.critical(f"Erreur critique dans fallback: {str(e)}", exc_info=True)
        return render(request, 'IA/forecast.html', {
            'produit': produit,
            'error': "Erreur critique dans le syst√®me de pr√©vision",
            'show_system_error': True
        })
        

# STOCK/views.py
def product_detail(request, pk):
    produit = get_object_or_404(Produit, pk=pk)
    return render(request, 'STOCK/product_detail.html', {'produit': produit})






#Retours d'achat fournisseurs
def retour_fournisseur(request, achat_id):
    achat = get_object_or_404(Achat, pk=achat_id)

    if request.method == 'POST':
        quantite_retournee = request.POST.get('quantite_retournee')
        motif = request.POST.get('motif')

        # Validation
        try:
            quantite_retournee = int(quantite_retournee)
            if quantite_retournee <= 0 or quantite_retournee > achat.quantite:
                raise ValueError
        except ValueError:
            messages.error(request, "Quantit√© invalide")
            return redirect('retour_fournisseur', achat_id=achat.id)

        try:
            # La cr√©ation du retour va automatiquement mettre √† jour les quantit√©s
            RetourFournisseur.objects.create(
                achat=achat,
                quantite_retournee=quantite_retournee,
                motif=motif,
                created_by=request.user
            )
            messages.success(request, f"Retour de {quantite_retournee} unit√©s enregistr√©")
        except Exception as e:
            messages.error(request, f"Erreur: {str(e)}")

        return redirect('retour_fournisseur', achat_id=achat.id)

    # GET - Affichage du formulaire
    context = {
        'achat': achat,
        'quantite_retournee_totale': achat.quantite_retournee,
        'quantite_disponible': achat.quantite,
        'retours_existants': achat.retours.all().order_by('-date_retour'),
        'quantite_effective': achat.quantite_effective,
        'montant_effectif': achat.montant_effectif
    }
    
    return render(request, 'achats/retour_fournisseur.html', context)

def delete(self, *args, **kwargs):
    """R√©ajuste tout lors de la suppression d'un retour"""
    with transaction.atomic():
        # R√©augmente le stock
        self.achat.produit.stock = F('stock') + self.quantite_retournee
        self.achat.produit.save(update_fields=['stock'])
        super().delete(*args, **kwargs)

@login_required
def supprimer_retour(request, retour_id):
    retour = get_object_or_404(RetourFournisseur, id=retour_id)
    achat_id = retour.achat.id
    
    if request.method == 'POST':
        retour.delete()
        messages.success(request, "Le retour a √©t√© supprim√© avec succ√®s")
        return redirect('retour_fournisseur', achat_id=achat_id)
    
    return redirect('retour_fournisseur', achat_id=achat_id)




class RetourFournisseurDetailPDF(DetailView):
    model = RetourFournisseur
    template_name = 'achats/retour_fournisseur_pdf.html'
    context_object_name = 'retour'

    def get(self, request, *args, **kwargs):
        retour = self.get_object()
        parametre = Parametre.objects.first()
        
        # Calcul du taux de change si n√©cessaire
        taux_change = Decimal('1.0')
        if retour.achat.devise != parametre.devise_principale:
            taux = TauxChange.get_taux(retour.achat.devise, parametre.devise_principale)
            taux_change = taux if taux is not None else Decimal('1.0')
        
        context = {
            'retour': retour,
            'parametre': parametre,
            'taux_change': taux_change,
            'request': request  # Ajout crucial de la requ√™te au contexte
        }
        
        # Rendu du template HTML
        html_string = render_to_string(self.template_name, context=context, request=request)  # Passage du request ici aussi
        
        # Cr√©ation du PDF
        html = HTML(string=html_string, base_url=request.build_absolute_uri())
        result = html.write_pdf()
        
        # Cr√©ation de la r√©ponse HTTP pour affichage dans le navigateur
        response = HttpResponse(content_type='application/pdf')
        response['Content-Disposition'] = 'inline; filename="retour_fournisseur_{}.pdf"'.format(retour.id)
        response.write(result)
        
        return response





#vue bon de commande



def generer_bon_livraison(request, commande_id):
    commande = get_object_or_404(Commande, id=commande_id)

    if hasattr(commande, 'bon_livraison'):
        messages.warning(request, "Un Bon de Livraison existe d√©j√† pour cette commande.")
        return redirect('liste_bons_livraison')

    parametre = Parametre.objects.first()  # ou filtre si plusieurs
    bon_livraison = BonLivraison.objects.create(
        commande=commande,
        client=commande.client,
        cree_par=request.user,
        parametre=parametre,
    )

    messages.success(request, "Bon de Livraison cr√©√© avec succ√®s.")
    return redirect('detail_bon_livraison', bl_id=bon_livraison.id)



def liste_bons_livraison(request):
    bons = BonLivraison.objects.order_by('-date_creation')
    return render(request, 'bons_livraison/liste.html', {'bons': bons})

def detail_bon_livraison(request, bl_id):
    bon = get_object_or_404(BonLivraison, id=bl_id)

    if request.method == 'POST':
        livre = request.POST.get('livre') == 'true'
        date_livraison = request.POST.get('date_livraison') or None

        bon.livre = livre
        bon.date_livraison = date_livraison
        bon.save()

        messages.success(request, "Statut du Bon de Livraison mis √† jour.")
        return redirect('liste_bons_livraison')  # ‚úÖ Pas de bl_id ici

    return render(request, 'bons_livraison/detail_bon_livraison.html', {'bon': bon})


def bon_livraison_pdf(request, bl_id):
    bon = get_object_or_404(BonLivraison, id=bl_id)

    # Calcul des totaux
    lignes = bon.commande.lignes.all()
    quantite_totale = sum([ligne.quantite for ligne in lignes])
    montant_total = sum([ligne.quantite * ligne.prix_unitaire for ligne in lignes])

    context = {
        'bon': bon,
        'parametre': bon.parametre,
        'quantite_totale': quantite_totale,
        'montant_total': montant_total
    }

    # Rendu HTML
    template = get_template('bons_livraison/pdf.html')
    html_string = template.render(context)

    # G√©n√©ration PDF
    html = HTML(string=html_string, base_url=request.build_absolute_uri('/'))
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = f'inline; filename="BL-{bon.id}.pdf"'
    html.write_pdf(response)

    return response


#comptabilites

@login_required
def liste_comptes(request):
    try:
        # Essayez d'obtenir les param√®tres de l'entreprise
        entreprise = getattr(request.user, 'parametre', None)
        
        if entreprise is None:
            # Si aucun param√®tre n'est associ√©, utilisez une entreprise par d√©faut
            entreprise = Parametre.objects.first()  # ou une autre logique
            
        comptes = Compte.objects.filter(entreprise=entreprise)
        
        for compte in comptes:
            compte.solde = compte.solde_actuel()
            
        return render(request, 'tresorerie/comptes/liste.html', {
            'comptes': comptes,
            'entreprise': entreprise
        })
        
    except Exception as e:
        # Journalisez l'erreur pour le d√©bogage
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f"Erreur dans liste_comptes: {str(e)}")
        
        # Retournez une r√©ponse vide ou une page d'erreur
        return render(request, 'tresorerie/comptes/liste.html', {
            'comptes': [],
            'error': "Une erreur s'est produite lors du chargement des comptes."
        })

@login_required
def ajouter_compte(request):
    if request.method == 'POST':
        nom = request.POST.get('nom')
        type_compte = request.POST.get('type_compte')
        solde_initial = request.POST.get('solde_initial', 0)
        
        compte = Compte(
            nom=nom,
            type_compte=type_compte,
            solde_initial=solde_initial,
            entreprise=request.user.parametre
        )
        compte.save()
        return redirect('liste_comptes')
    
    return render(request, 'tresorerie/comptes/ajouter.html')

from django.contrib.auth.decorators import login_required
from django.db.models import Q, F, Sum, Case, When, DecimalField
from django.core.paginator import Paginator
from django.shortcuts import render
from .models import Transaction, TauxChange
from django.utils import timezone


@login_required
def liste_transactions(request):
    entreprise = request.user.parametre
    transactions_list = Transaction.objects.filter(compte__entreprise=entreprise).order_by('-date_transaction')

    devise_affichee = request.session.get('devise_affichee', entreprise.devise_principale)

    devises_disponibles = set()
    devises_taux = TauxChange.objects.values_list('devise_source', 'devise_cible')
    for source, cible in devises_taux:
        devises_disponibles.add(source)
        devises_disponibles.add(cible)

    devises_disponibles.add(entreprise.devise_principale)
    if entreprise.devises_acceptees:
        devises_disponibles.update(entreprise.devises_acceptees)

    if devise_affichee not in devises_disponibles:
        devise_affichee = entreprise.devise_principale
        request.session['devise_affichee'] = devise_affichee

    search_query = request.GET.get('q', '')
    type_filter = request.GET.get('type', '')
    date_filter = request.GET.get('date', '')

    if search_query:
        transactions_list = transactions_list.filter(
            Q(description__icontains=search_query) |
            Q(compte__nom__icontains=search_query) |
            Q(categorie__nom__icontains=search_query)
        )

    if type_filter:
        transactions_list = transactions_list.filter(type_transaction=type_filter)

    if date_filter:
        transactions_list = transactions_list.filter(date_transaction__date=date_filter)

    paginator = Paginator(transactions_list, 25)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)

    solde_total_principal = transactions_list.aggregate(
        total=Sum(
            Case(
                When(type_transaction='ENTREE', then=F('montant')),
                When(type_transaction='SORTIE', then=-F('montant')),
                default=0,
                output_field=DecimalField()
            )
        )
    )['total'] or 0

    transactions_formatted = []
    for transaction in page_obj.object_list:
        try:
            if devise_affichee == entreprise.devise_principale:
                montant_affiche = transaction.montant
            else:
                montant_affiche = entreprise.convertir_vers_devise_affichee(transaction.montant, devise_affichee)

            transactions_formatted.append({
                'obj': transaction,
                'montant_affiche': entreprise.format_devise(montant_affiche, devise_affichee),
                'montant_original': entreprise.format_devise(transaction.montant, entreprise.devise_principale)
                    if devise_affichee != entreprise.devise_principale else None
            })
        except Exception as e:
            print(f"Erreur conversion transaction {transaction.id}: {e}")
            transactions_formatted.append({
                'obj': transaction,
                'montant_affiche': entreprise.format_devise(transaction.montant, entreprise.devise_principale),
                'montant_original': None
            })

    try:
        if devise_affichee == entreprise.devise_principale:
            solde_total = solde_total_principal
        else:
            solde_total = entreprise.convertir_vers_devise_affichee(solde_total_principal, devise_affichee)
    except Exception as e:
        print(f"Erreur conversion solde: {e}")
        solde_total = solde_total_principal
        devise_affichee = entreprise.devise_principale

    solde_total_formatted = entreprise.format_devise(solde_total, devise_affichee)
    solde_total_principal_formatted = (
        entreprise.format_devise(solde_total_principal, entreprise.devise_principale)
        if devise_affichee != entreprise.devise_principale else None
    )

    return render(request, 'tresorerie/transactions/liste.html', {
        'page_obj': page_obj,
        'transactions': transactions_formatted,
        'solde_total_formatted': solde_total_formatted,
        'solde_total_principal_formatted': solde_total_principal_formatted,
        'devise_affichee': devise_affichee,
        'devises_disponibles': sorted(devises_disponibles),
        'devise_principale': entreprise.devise_principale,
        'search_query': search_query,
        'type_filter': type_filter,
        'date_filter': date_filter,
    })



@login_required
def ajouter_transaction(request):
    entreprise = request.user.parametre
    if request.method == 'POST':
        compte_id = request.POST.get('compte')
        type_transaction = request.POST.get('type_transaction')
        categorie_id = request.POST.get('categorie')
        montant = request.POST.get('montant')
        mode_paiement = request.POST.get('mode_paiement')
        description = request.POST.get('description', '')
        
        transaction = Transaction(
            compte_id=compte_id,
            type_transaction=type_transaction,
            categorie_id=categorie_id,
            montant=montant,
            mode_paiement=mode_paiement,
            description=description,
            utilisateur=request.user
        )
        
        if 'piece_jointe' in request.FILES:
            transaction.piece_jointe = request.FILES['piece_jointe']
        
        transaction.save()
        return redirect('liste_transactions')
    
    comptes = Compte.objects.filter(entreprise=entreprise)
    categories = CategorieTransaction.objects.filter(entreprise=entreprise)
    return render(request, 'tresorerie/transactions/ajouter.html', {
        'comptes': comptes,
        'categories': categories
    })


@login_required
def journal_caisse(request):
    entreprise = request.user.parametre
    transactions_list = Transaction.objects.filter(
        compte__entreprise=entreprise
    ).order_by('-date_transaction')
    
    # Filtres
    date_debut = request.GET.get('date_debut', (datetime.now() - timedelta(days=30)).strftime('%Y-%m-%d'))
    date_fin = request.GET.get('date_fin', datetime.now().strftime('%Y-%m-%d'))
    compte_id = request.GET.get('compte')
    devise_affichee = request.GET.get('devise', entreprise.devise_principale)
    
    transactions_list = transactions_list.filter(
        date_transaction__date__gte=date_debut,
        date_transaction__date__lte=date_fin
    )
    
    if compte_id:
        transactions_list = transactions_list.filter(compte_id=compte_id)
    
    # Pr√©parer les transactions avec les montants convertis
    transactions_converted = []
    for transaction in transactions_list:
        montant_converti = entreprise.convertir_vers_devise_affichee(
            transaction.montant, 
            devise_affichee
        )
        transactions_converted.append({
            'original': transaction,
            'montant_converti': montant_converti,
            'devise_affichee': devise_affichee
        })
    
    # Pagination
    paginator = Paginator(transactions_converted, 25)  # Utiliser la liste convertie
    page_number = request.GET.get('page')
    transactions_page = paginator.get_page(page_number)
    
    # Conversion des totaux (reste inchang√©)
    total_entrees = transactions_list.filter(type_transaction='ENTREE').aggregate(
        total=Sum('montant')
    )['total'] or 0
    total_entrees = entreprise.convertir_vers_devise_affichee(total_entrees, devise_affichee)
    
    total_sorties = transactions_list.filter(type_transaction='SORTIE').aggregate(
        total=Sum('montant')
    )['total'] or 0
    total_sorties = entreprise.convertir_vers_devise_affichee(total_sorties, devise_affichee)
    
    return render(request, 'tresorerie/rapports/journal_caisse.html', {
        'transactions_page': transactions_page,  # Utiliser la page convertie
        'total_entrees': total_entrees,
        'total_sorties': total_sorties,
        'date_debut': date_debut,
        'date_fin': date_fin,
        'comptes': Compte.objects.filter(entreprise=entreprise),
        'devises_disponibles': entreprise.devises_acceptees if entreprise.devises_acceptees else [entreprise.devise_principale],
        'devise_affichee': devise_affichee,
        'devise_principale': entreprise.devise_principale
    })

@receiver(post_save, sender=Paiement)
def creer_transaction_paiement(sender, instance, created, **kwargs):
    if created:
        compte = Compte.objects.filter(type_compte='ESP').first()  # √Ä adapter selon votre logique
        if compte:
            Transaction.objects.create(
                compte=compte,
                type_transaction='ENTREE',
                montant=instance.montant,
                mode_paiement=instance.methode[:3].upper(),
                description=f"Paiement facture {instance.facture.numero}",
                commande=instance.facture.commande,
                utilisateur=instance.facture.commande.vendeur
            )

from django.db import transaction as db_transaction
from django.db import transaction as db_transaction

from django.db import transaction as db_transaction


@require_POST
@csrf_exempt  # Temporaire pour debug - √† retirer en production
def creer_transaction_achat(request, achat_id):
    try:
        with db_transaction.atomic():
            # V√©rification de l'authentification
            if not request.user.is_authenticated:
                return JsonResponse({
                    'success': False, 
                    'message': 'Authentification requise'
                }, status=401)

            achat = Achat.objects.select_related('produit', 'transaction').get(id=achat_id)
            
            # V√©rification de l'existence d'une transaction
            if achat.transaction:
                return JsonResponse({
                    'success': False, 
                    'message': 'Une transaction existe d√©j√† pour cet achat'
                }, status=400)

            compte = Compte.objects.filter(type_compte='ESP').first()
            if not compte:
                return JsonResponse({
                    'success': False, 
                    'message': 'Aucun compte de caisse disponible'
                }, status=400)

            # Cr√©ation de la transaction
            transaction = Transaction.objects.create(
                compte=compte,
                type_transaction='SORTIE',
                montant=achat.total_achat,
                montant_original=achat.total_achat,
                mode_paiement='VIR',
                description=f"Achat {achat.produit.nom}",
                utilisateur=request.user,
                devise=achat.devise,
                taux_change=achat.taux_change
            )

            # Liaison de la transaction √† l'achat
            achat.transaction = transaction
            achat.save()

            return JsonResponse({
                'success': True,
                'transaction_id': transaction.id,
                'message': 'Transaction cr√©√©e avec succ√®s'
            })

    except Achat.DoesNotExist:
        return JsonResponse({
            'success': False,
            'message': 'Achat non trouv√©'
        }, status=404)
    except Exception as e:
        return JsonResponse({
            'success': False,
            'message': f'Erreur serveur: {str(e)}'
        }, status=500)

@login_required
def voir_transaction_achat(request, achat_id):
    achat = get_object_or_404(Achat, id=achat_id)
    if not achat.transaction:
        raise Http404("Aucune transaction pour cet achat")
    
    return render(request, 'transactions/detail.html', {
        'transaction': achat.transaction,
        'achat': achat
    })       
        
        

@login_required
def detail_compte(request, pk):
    compte = get_object_or_404(Compte, pk=pk, entreprise=request.user.parametre)
    transactions = Transaction.objects.filter(compte=compte).order_by('-date_transaction')[:10]
    return render(request, 'tresorerie/comptes/detail.html', {
        'compte': compte,
        'transactions': transactions,
        'solde_actuel': compte.solde_actuel()
    })






@login_required
def detail_transaction(request, pk):
    transaction = get_object_or_404(Transaction, pk=pk, compte__entreprise=request.user.parametre)
    return render(request, 'tresorerie/transactions/detail.html', {'transaction': transaction})

@login_required
def liste_categories(request):
    categories = CategorieTransaction.objects.filter(entreprise=request.user.parametre)
    return render(request, 'tresorerie/categories/liste.html', {'categories': categories})

@login_required
def ajouter_categorie(request):
    if request.method == 'POST':
        nom = request.POST.get('nom')
        type_categorie = request.POST.get('type_categorie')
        description = request.POST.get('description', '')
        
        categorie = CategorieTransaction(
            nom=nom,
            type_categorie=type_categorie,
            description=description,
            entreprise=request.user.parametre
        )
        categorie.save()
        return redirect('liste_categories')
    
    return render(request, 'tresorerie/categories/ajouter.html')

@login_required
def balance_comptes(request):
    entreprise = request.user.parametre
    date_debut = request.GET.get('date_debut', (datetime.now() - timedelta(days=30)).strftime('%Y-%m-%d'))
    date_fin = request.GET.get('date_fin', datetime.now().strftime('%Y-%m-%d'))
    
    comptes = Compte.objects.filter(entreprise=entreprise)
    balance = []
    
    for compte in comptes:
        transactions = Transaction.objects.filter(
            compte=compte,
            date_transaction__date__range=[date_debut, date_fin]
        )
        
        entree = transactions.filter(type_transaction='ENTREE').aggregate(total=Sum('montant'))['total'] or 0
        sortie = transactions.filter(type_transaction='SORTIE').aggregate(total=Sum('montant'))['total'] or 0
        
        balance.append({
            'compte': compte,
            'entree': entree,
            'sortie': sortie,
            'solde': entree - sortie
        })
    
    return render(request, 'tresorerie/rapports/balance.html', {
        'balance': balance,
        'date_debut': date_debut,
        'date_fin': date_fin
    })

@login_required
def bilan_simplifie(request):
    entreprise = request.user.parametre
    date_fin = request.GET.get('date_fin', datetime.now().strftime('%Y-%m-%d'))
    
    # Actifs (comptes avec solde positif)
    actifs = Compte.objects.filter(
        entreprise=entreprise
    ).annotate(
        solde=Sum(
            Case(
                When(transaction__type_transaction='ENTREE', then='transaction__montant'),
                When(transaction__type_transaction='SORTIE', then=-F('transaction__montant')),
                default=0,
                output_field=DecimalField()
            )
        ) + F('solde_initial')
    ).filter(solde__gt=0)
    
    # Passifs (comptes avec solde n√©gatif)
    passifs = Compte.objects.filter(
        entreprise=entreprise
    ).annotate(
        solde=Sum(
            Case(
                When(transaction__type_transaction='ENTREE', then='transaction__montant'),
                When(transaction__type_transaction='SORTIE', then=-F('transaction__montant')),
                default=0,
                output_field=DecimalField()
            )
        ) + F('solde_initial')
    ).filter(solde__lt=0).annotate(
        solde_abs=Abs(F('solde'))
    )
    
    total_actifs = actifs.aggregate(total=Sum('solde'))['total'] or 0
    total_passifs = - (passifs.aggregate(total=Sum('solde'))['total'] or 0)
    
    return render(request, 'tresorerie/rapports/bilan.html', {
        'actifs': actifs,
        'passifs': passifs,
        'total_actifs': total_actifs,
        'total_passifs': total_passifs,
        'date_fin': date_fin
    })
    


import openpyxl
from django.http import HttpResponse
from django.utils import timezone
from datetime import datetime
from django.contrib.auth.decorators import login_required
from openpyxl.styles import Font, PatternFill

@login_required
def export_journal_excel(request):
    entreprise = request.user.parametre
    
    # R√©cup√©rer les m√™mes filtres que dans journal_caisse
    date_debut = request.GET.get('date_debut', (timezone.now() - timezone.timedelta(days=30)).strftime('%Y-%m-%d'))
    date_fin = request.GET.get('date_fin', timezone.now().strftime('%Y-%m-%d'))
    compte_id = request.GET.get('compte')
    
    transactions = Transaction.objects.filter(
        compte__entreprise=entreprise,
        date_transaction__date__gte=date_debut,
        date_transaction__date__lte=date_fin
    ).order_by('-date_transaction')
    
    if compte_id:
        transactions = transactions.filter(compte_id=compte_id)
    
    # Cr√©er un nouveau classeur Excel
    wb = openpyxl.Workbook()
    ws = wb.active
    ws.title = "Journal de Caisse"
    
    # En-t√™tes
    headers = [
        "Date", 
        "Compte", 
        "Type", 
        "Cat√©gorie", 
        "Description", 
        "Mode Paiement", 
        "Montant"
    ]
    ws.append(headers)
    
    # Donn√©es
    for t in transactions:
        ws.append([
            t.date_transaction.strftime("%d/%m/%Y %H:%M"),
            t.compte.nom,
            t.get_type_transaction_display(),
            t.categorie.nom if t.categorie else "-",
            t.description,
            t.get_mode_paiement_display(),
            t.montant
        ])
    
    # Style des en-t√™tes
    for cell in ws[1]:
        cell.font = Font(bold=True)
        cell.fill = PatternFill(start_color="DDDDDD", end_color="DDDDDD", fill_type="solid")
    
    # Ajuster la largeur des colonnes
    for column in ws.columns:
        max_length = 0
        column_letter = column[0].column_letter
        for cell in column:
            try:
                if len(str(cell.value)) > max_length:
                    max_length = len(cell.value)
            except:
                pass
        adjusted_width = (max_length + 2) * 1.2
        ws.column_dimensions[column_letter].width = adjusted_width
    
    # Format de la date
    for row in ws.iter_rows(min_row=2):
        row[0].number_format = 'DD/MM/YYYY HH:MM'
    
    # Format mon√©taire
    for row in ws.iter_rows(min_row=2):
        row[6].number_format = '#,##0.00'
    
    # Ajouter les totaux
    ws.append([])  # Ligne vide
    
    # Calcul des totaux
    total_entrees = sum(t.montant for t in transactions if t.type_transaction == 'ENTREE')
    total_sorties = sum(t.montant for t in transactions if t.type_transaction == 'SORTIE')
    solde_net = total_entrees - total_sorties
    
    # Ajout des totaux
    ws.append(["", "", "", "", "", "Total Entr√©es:", total_entrees])
    ws.append(["", "", "", "", "", "Total Sorties:", total_sorties])
    ws.append(["", "", "", "", "", "Solde Net:", solde_net])
    
    # Style des totaux
    for row in ws.iter_rows(min_row=ws.max_row-2, max_row=ws.max_row):
        for cell in row[5:]:
            cell.font = Font(bold=True)
        row[-1].number_format = '#,##0.00'
    
    # Pr√©parer la r√©ponse
    response = HttpResponse(
        content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    )
    filename = f"journal_caisse_{datetime.now().strftime('%Y%m%d_%H%M%S')}.xlsx"
    response['Content-Disposition'] = f'attachment; filename={filename}'
    
    wb.save(response)
    return responses





from django.shortcuts import render
from django.db.models import Sum, Count
from datetime import datetime, timedelta
from .models import Transaction, Compte, CategorieTransaction

def dashboard_tresorerie(request):
    # Param√®tre de p√©riode
    jours = int(request.GET.get('jours', 30))
    date_debut = datetime.now() - timedelta(days=jours)
    
    # 1. Flux de tr√©sorerie (entr√©es/sorties par jour)
    transactions = Transaction.objects.filter(
        date_transaction__gte=date_debut
    ).values('date_transaction__date').annotate(
        entieres=Sum('montant', filter=Q(type_transaction='ENTREE')),
        sorties=Sum('montant', filter=Q(type_transaction='SORTIE'))
    ).order_by('date_transaction__date')
    
    dates_flux = []
    entieres_flux = []
    sorties_flux = []
    
    for t in transactions:
        dates_flux.append(t['date_transaction__date'].strftime('%d/%m'))
        entieres_flux.append(float(t['entieres'] or 0))
        sorties_flux.append(float(t['sorties'] or 0))
    
    # 2. R√©partition des d√©penses par cat√©gorie
    categories_depenses = CategorieTransaction.objects.filter(
        type_categorie='DEP'
    ).annotate(
        total=Sum('transaction__montant', filter=Q(
            transaction__type_transaction='SORTIE',
            transaction__date_transaction__gte=date_debut
        ))
    ).exclude(total=None).order_by('-total')
    
    labels_depenses = []
    data_depenses = []
    colors_depenses = []
    color_palette = [
        '#e74a3b', '#f6c23e', '#36b9cc', '#858796', 
        '#1cc88a', '#4e73df', '#5a5c69', '#fd7e14'
    ]
    
    for i, categorie in enumerate(categories_depenses):
        labels_depenses.append(categorie.nom)
        data_depenses.append(float(categorie.total))
        colors_depenses.append(color_palette[i % len(color_palette)])
    
    # 3. Soldes des comptes
    comptes = Compte.objects.all().annotate(
        solde=Sum(
            Case(
                When(transaction__type_transaction='ENTREE', then='transaction__montant'),
                When(transaction__type_transaction='SORTIE', then=-F('transaction__montant')),
                default=0,
                output_field=DecimalField()
            )
        ) + F('solde_initial')
    ).order_by('-solde')
    
    labels_comptes = [c.nom for c in comptes]
    data_comptes = [float(c.solde) for c in comptes]
    
    # 4. R√©partition des moyens de paiement
    modes_paiement = Transaction.objects.filter(
        date_transaction__gte=date_debut
    ).values('mode_paiement').annotate(
        total=Sum('montant'),
        count=Count('id')
    ).order_by('-total')
    
    labels_paiements = []
    data_paiements = []
    colors_paiements = []
    mode_colors = {
        'ESP': '#4e73df',  # Esp√®ces - bleu
        'MM': '#1cc88a',   # Mobile Money - vert
        'CHQ': '#f6c23e',  # Ch√®que - jaune
        'VIR': '#36b9cc',  # Virement - cyan
        'CRD': '#e74a3b'   # Carte - rouge
    }
    
    for mode in modes_paiement:
        labels_paiements.append(dict(Transaction.MODE_PAIEMENT).get(mode['mode_paiement']))
        data_paiements.append(float(mode['total']))
        colors_paiements.append(mode_colors.get(mode['mode_paiement'], '#858796'))
    
    return render(request, 'tresorerie/dashboard.html', {
        'dates_flux': dates_flux,
        'entieres_flux': entieres_flux,
        'sorties_flux': sorties_flux,
        'categories_depenses': zip(categories_depenses, colors_depenses),
        'labels_depenses': labels_depenses,
        'data_depenses': data_depenses,
        'colors_depenses': colors_depenses,
        'labels_comptes': labels_comptes,
        'data_comptes': data_comptes,
        'labels_paiements': labels_paiements,
        'data_paiements': data_paiements,
        'colors_paiements': colors_paiements,
        'modes_paiement': [{'mode': m[1], 'color': mode_colors.get(m[0], '#858796')} 
                          for m in Transaction.MODE_PAIEMENT]
    })
    
    
def liste_paiements(request):
    paiements = Paiement.objects.all().order_by('-date').select_related('facture', 'facture__commande')
    for paiement in paiements:
        paiement.transaction = Transaction.objects.filter(
            commande=paiement.facture.commande,
            montant=paiement.montant
        ).first()
    return render(request, 'tresorerie/paiements/liste.html', {'paiements': paiements})

def detail_paiement(request, pk):
    paiement = get_object_or_404(Paiement, pk=pk)
    transaction = paiement.transaction_set.first()
    return render(request, 'tresorerie/paiements/detail.html', {
        'paiement': paiement,
        'transaction': transaction
    })
from django.shortcuts import render, redirect, get_object_or_404
from STOCK.forms import AchatForm
from STOCK.models import Achat, Parametre, TauxChange, Compte, CategorieTransaction, Transaction


# views.py
from django.shortcuts import render
from .models import Achat, Parametre, TauxChange
from decimal import Decimal, InvalidOperation

def get_devise_affichee():
    """Retourne la devise principale depuis les param√®tres."""
    parametre = Parametre.objects.first()
    return parametre.devise_principale if parametre else 'CDF'


def get_taux(source, cible):
    """Retourne le taux de conversion entre deux devises."""
    if source == cible:
        return Decimal('1.0')

    try:
        # Taux direct
        taux = (
            TauxChange.objects
            .filter(devise_source=source, devise_cible=cible)
            .order_by('-date_mise_a_jour')
            .first()
        )
        if taux:
            return taux.taux

        # Taux inverse si le direct n'existe pas
        taux_inverse = (
            TauxChange.objects
            .filter(devise_source=cible, devise_cible=source)
            .order_by('-date_mise_a_jour')
            .first()
        )
        if taux_inverse and taux_inverse.taux != 0:
            return Decimal('1.0') / taux_inverse.taux

    except (TauxChange.DoesNotExist, InvalidOperation):
        pass

    return Decimal('1.0')  # Valeur de secours


@login_required
def liste_achats(request):
    achats = Achat.objects.all()

    # R√©cup√©rer les param√®tres utilisateur
    try:
        parametres = Parametre.objects.get(user=request.user)
        devise_principale = parametres.devise_principale
        devises_disponibles = parametres.devises_acceptees
    except Parametre.DoesNotExist:
        devise_principale = "USD"
        devises_disponibles = ["USD", "CDF", "EUR"]

    # G√©rer la devise affich√©e
    devise_affichee = request.session.get('devise_affichee', devise_principale)
    if devise_affichee not in devises_disponibles:
        devise_affichee = devise_principale

    total_general = Decimal('0.00')

    for achat in achats:
        devise_source = achat.devise
        montant = achat.total_achat

        try:
            if devise_source == devise_affichee:
                achat.montant_converti = montant
                achat.taux_applique = Decimal('1.0')
            else:
                achat.montant_converti = TauxChange.convertir(
                    montant, 
                    devise_source, 
                    devise_affichee
                )
                achat.taux_applique = TauxChange.get_taux(devise_source, devise_affichee)
                
            total_general += achat.montant_converti
        except Exception as e:
            print(f"Erreur conversion: {e}")
            achat.montant_converti = Decimal('0.00')
            achat.taux_applique = None

    context = {
        "achats": achats,
        "devise_affichee": devise_affichee,
        "devises_disponibles": devises_disponibles,
        "total_general": total_general,
        "devise_principale": devise_principale,
        "devise_symbols": {"USD": "$", "CDF": "FC", "EUR": "‚Ç¨"},
    }

    return render(request, "tresorerie/achats/liste.html", context)
# Dans vos views.py
from django.views.decorators.http import require_POST
from django.http import JsonResponse

@require_POST
@login_required
def set_devise(request):
    devise = request.POST.get('devise')
    print(f"Devise re√ßue: {devise}")  # Debug
    try:
        parametres = Parametre.objects.get(user=request.user)
        if devise in parametres.devises_acceptees:
            request.session['devise_affichee'] = devise
            print("Devise enregistr√©e en session")  # Debug
            return JsonResponse({'status': 'success'})
    except Parametre.DoesNotExist:
        if devise in ["USD", "CDF"]:  # Simplifi√©
            request.session['devise_affichee'] = devise
            return JsonResponse({'status': 'success'})
    
    return JsonResponse({'status': 'error', 'message': 'Devise non autoris√©e'}, status=400)





@login_required
def obtenir_taux_change(request):
    devise_cible = request.GET.get('devise')
    parametres = Parametre.objects.first()

    if not parametres or not devise_cible:
        return JsonResponse({'status': 'error', 'message': 'Param√®tres manquants'})

    try:
        devise_source = parametres.devise_principale
        taux = TauxChange.get_taux(devise_source, devise_cible)

        if taux is None:
            return JsonResponse({'status': 'error', 'message': f"Aucun taux de change disponible pour {devise_source} vers {devise_cible}"})

        return JsonResponse({'status': 'success', 'taux': str(taux)})
    except Exception as e:
        return JsonResponse({'status': 'error', 'message': str(e)})






def detail_achat(request, pk):
    achat = get_object_or_404(Achat, pk=pk)
    return render(request, 'tresorerie/achats/detail.html', {'achat': achat})


def ajouter_achat(request):
    if request.method == 'POST':
        form = AchatForm(request.POST)
        if form.is_valid():
            achat = form.save(commit=False)
            achat.created_by = request.user

            # R√©cup√©rer les param√®tres globaux
            param = Parametre.objects.first()
            devise_principale = param.devise_principale if param else 'FC'

            achat.devise = devise_principale
            achat.montant_original = achat.prix_unitaire  # Pas besoin de conversion
            achat.taux_change = 1.0

            achat.save()

            # Cr√©er la transaction automatiquement (SANS lien avec achat)
            try:
                compte = Compte.objects.first()
                categorie = CategorieTransaction.objects.get(nom__iexact='Achats')

                Transaction.objects.create(
                    compte=compte,
                    montant=achat.total_achat_devise_principale,
                    type_transaction='SORTIE',
                    categorie=categorie,
                    mode_paiement='ESP',
                    description=f"Achat automatique : {achat.quantite} x {achat.produit.nom}"
                )
            except Exception as e:
                print(f"Erreur lors de la cr√©ation de la transaction : {e}")

            return redirect('liste_achats')
    else:
        form = AchatForm()

    return render(request, 'tresorerie/achats/ajouter.html', {
        'form': form,
        'devise': request.user.parametre.devise_principale if hasattr(request.user, 'parametre') else 'FC'
    })

    
    
    
    
    
    #Module tresorerie
    
def Tresorerie(request):
    return render(request,"tresorerie/module_tresorerie.html")

import requests
class MettreAJourTauxChange(View):
    def get(self, request):
        parametres = Parametre.objects.first()
        if not parametres or not parametres.devises_acceptees:
            return JsonResponse({'status': 'error', 'message': 'Configuration manquante'})
        
        try:
            # Exemple avec une API fictive - √† remplacer par une vraie API
            response = requests.get(
                f"https://api.exemple.com/taux?devises={','.join(parametres.devises_acceptees)}"
            )
            data = response.json()
            
            for devise in parametres.devises_acceptees:
                if devise == parametres.devise_principale:
                    continue
                
                taux, created = TauxChange.objects.update_or_create(
                    devise_source=devise,
                    devise_cible=parametres.devise_principale,
                    defaults={
                        'taux': Decimal(str(data['rates'][devise])),
                        'est_manuel': False
                    }
                )
            
            return JsonResponse({
                'status': 'success',
                'message': f'Taux mis √† jour le {datetime.now().strftime("%Y-%m-%d %H:%M")}'
            })
        except Exception as e:
            return JsonResponse({'status': 'error', 'message': str(e)})
        
        
        
        
        
from django.shortcuts import render, redirect
from django.contrib import messages
from django.views.generic import ListView, CreateView, UpdateView
from django.urls import reverse_lazy
from .models import Parametre, TauxChange
from .forms import DeviseForm, TauxChangeForm
import requests
from decimal import Decimal
from django.http import JsonResponse

class ListeDevisesView(ListView):
    model = TauxChange
    template_name = 'tresorerie/devises/liste.html'
    context_object_name = 'taux_list'
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['parametres'] = Parametre.objects.first()
        return context

def ajouter_devise(request):
    parametres = Parametre.objects.first()
    if request.method == 'POST':
        form = DeviseForm(request.POST, instance=parametres)
        if form.is_valid():
            form.save()
            messages.success(request, "Devises mises √† jour avec succ√®s")
            return redirect('liste_devises')
    else:
        form = DeviseForm(instance=parametres)
    
    return render(request, 'tresorerie/devises/ajouter_devise.html', {'form': form})

from django.urls import reverse_lazy

def ajouter_taux(request):
    # R√©cup√©rer les devises disponibles
    parametres = Parametre.objects.first()
    devises_disponibles = []
    if parametres:
        devises_disponibles = sorted(set(
            parametres.devises_acceptees + [parametres.devise_principale]
        ))

    if request.method == 'POST':
        # R√©cup√©rer les donn√©es du formulaire
        devise_source = request.POST.get('devise_source')
        devise_cible = request.POST.get('devise_cible')
        taux_str = request.POST.get('taux')

        # Validation manuelle
        errors = []
        if not devise_source or not devise_cible or not taux_str:
            errors.append("Tous les champs sont obligatoires")
        
        if devise_source == devise_cible:
            errors.append("Les devises source et cible doivent √™tre diff√©rentes")

        try:
            taux = Decimal(taux_str)
            if taux <= 0:
                errors.append("Le taux doit √™tre positif")
        except:
            errors.append("Le taux doit √™tre un nombre valide")

        # V√©rifier si le taux existe d√©j√†
        if TauxChange.objects.filter(
            devise_source=devise_source,
            devise_cible=devise_cible
        ).exists():
            errors.append("Ce taux de change existe d√©j√†")

        if not errors:
            # Cr√©er et sauvegarder le nouveau taux
            TauxChange.objects.create(
                devise_source=devise_source,
                devise_cible=devise_cible,
                taux=taux,
                est_manuel=True
            )
            messages.success(
                request,
                f"Taux de change {devise_source}/{devise_cible} ajout√© avec succ√®s"
            )
            return redirect(reverse_lazy('liste_devises'))

        # Si erreurs, les afficher
        for error in errors:
            messages.error(request, error)

    context = {
        'devises_disponibles': devises_disponibles,
        'page_title': "Ajouter un Taux de Change",
        'active_menu': 'tresorerie'
    }
    return render(request, 'tresorerie/devises/ajouter_taux.html', context)


from django.core.paginator import Paginator

def historique_taux(request):
    """
    Affiche l'historique des modifications des taux de change
    avec pagination et filtres possibles.
    """
    # R√©cup√©rer les param√®tres de filtrage
    devise_source = request.GET.get('devise_source')
    devise_cible = request.GET.get('devise_cible')
    
    # Construire la requ√™te de base
    queryset = TauxChange.objects.all().order_by('-date_mise_a_jour')
    
    # Appliquer les filtres
    if devise_source:
        queryset = queryset.filter(devise_source=devise_source)
    if devise_cible:
        queryset = queryset.filter(devise_cible=devise_cible)
    
    # Pagination (10 √©l√©ments par page)
    paginator = Paginator(queryset, 10)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    # R√©cup√©rer les devises disponibles pour les filtres
    parametres = Parametre.objects.first()
    devises_disponibles = []
    if parametres:
        devises_disponibles = parametres.devises_acceptees + [parametres.devise_principale]
    
    context = {
        'page_obj': page_obj,
        'devises_disponibles': sorted(set(devises_disponibles)),
        'selected_devise_source': devise_source,
        'selected_devise_cible': devise_cible,
        'page_title': "Historique des Taux de Change",
        'active_menu': 'tresorerie'
    }
    
    return render(request, 'tresorerie/devises/historique_taux.html', context)
    
    
    
    


from django.shortcuts import render
from django.http import JsonResponse
from django.views.decorators.http import require_http_methods
from django.core.cache import cache
from .models import Parametre, TauxChange
import requests
import json
from decimal import Decimal

def get_available_currencies(parametres):
    """
    R√©cup√®re les devises disponibles depuis l'API ou le cache
    """
    if not parametres.openexchangerates_app_id:
        return {}

    cache_key = f'oer_currencies_{parametres.user.id}'
    currencies = cache.get(cache_key)
    
    if not currencies:
        try:
            response = requests.get(
                'https://openexchangerates.org/api/currencies.json',
                params={'app_id': parametres.openexchangerates_app_id},
                timeout=5
            )
            currencies = response.json()
            cache.set(cache_key, currencies, timeout=86400)  # Cache 24h
        except Exception:
            currencies = {}

    return currencies


#modif taux
def modifier_taux(request, taux_id):
    taux = get_object_or_404(TauxChange, id=taux_id)
    parametres = Parametre.objects.first()  # R√©cup√©ration des param√®tres
    
    if request.method == 'POST':
        # R√©cup√©ration des donn√©es du formulaire
        devise_source = request.POST.get('devise_source')
        devise_cible = request.POST.get('devise_cible')
        taux_value = request.POST.get('taux')
        
        # Validation basique
        errors = []
        if not devise_source or not devise_cible or not taux_value:
            errors.append("Tous les champs sont obligatoires")
        
        if devise_source == devise_cible:
            errors.append("Les devises source et cible doivent √™tre diff√©rentes")

        try:
            taux_decimal = Decimal(taux_value)
            if taux_decimal <= 0:
                errors.append("Le taux doit √™tre positif")
        except:
            errors.append("Le taux doit √™tre un nombre valide")

        if not errors:
            try:
                taux.devise_source = devise_source
                taux.devise_cible = devise_cible
                taux.taux = taux_decimal
                taux.save()
                messages.success(request, "Taux mis √† jour avec succ√®s")
                return redirect('liste_devises')
            except Exception as e:
                messages.error(request, f"Erreur: {str(e)}")
        else:
            for error in errors:
                messages.error(request, error)
    
    # Pr√©parer les devises disponibles
    devises_disponibles = []
    if parametres:
        devises_disponibles = sorted(set(
            parametres.devises_acceptees + [parametres.devise_principale]
        ))
    
    context = {
        'taux': taux,
        'devises_disponibles': devises_disponibles,
        'page_title': "Modifier Taux de Change",
        'parametres': parametres  # Ajout des param√®tres au contexte
    }
    return render(request, 'tresorerie/devises/modifier_taux.html', context)


def supprimer_taux(request, taux_id):
    taux = get_object_or_404(TauxChange, id=taux_id)
    
    if request.method == 'POST':
        taux.delete()
        messages.success(request, "Taux supprim√© avec succ√®s")
        return redirect('liste_devises')
    
    context = {
        'taux': taux,
        'page_title': "Confirmer la suppression"
    }
    return render(request, 'tresorerie/devises/confirmer_suppression.html', context)


def obtenir_devises_disponibles(request):
    if request.method == 'GET':
        try:
            parametres = Parametre.objects.first()
            if not parametres or not parametres.openexchangerates_app_id:
                return JsonResponse({'status': 'error', 'message': 'Configuration manquante'})
            
            response = requests.get(
                f"https://openexchangerates.org/api/currencies.json",
                params={'app_id': parametres.openexchangerates_app_id}
            )
            
            if response.status_code == 200:
                return JsonResponse({
                    'status': 'success',
                    'devises': response.json()
                })
            else:
                return JsonResponse({
                    'status': 'error',
                    'message': 'Erreur lors de la r√©cup√©ration des devises'
                })
        except Exception as e:
            return JsonResponse({'status': 'error', 'message': str(e)})
    
    return JsonResponse({'status': 'error', 'message': 'M√©thode non autoris√©e'})



@csrf_exempt  # n√©cessaire si tu n'utilises pas {% csrf_token %}, mais tu l'utilises donc √† retirer si non requis
def changer_devise(request):
    if request.method == 'POST':
        try:
            data = json.loads(request.body)
            nouvelle_devise = data.get('devise')

            if nouvelle_devise in ['USD', 'EUR', 'CDF']:  # s√©curise les entr√©es
                parametre = Parametre.objects.first()
                if parametre:
                    parametre.devise_principale = nouvelle_devise
                    parametre.save()
                else:
                    Parametre.objects.create(devise_principale=nouvelle_devise)

                return JsonResponse({'success': True})
            else:
                return JsonResponse({'success': False, 'message': 'Devise invalide'})

        except Exception as e:
            return JsonResponse({'success': False, 'message': str(e)})

    return JsonResponse({'success': False, 'message': 'M√©thode non autoris√©e'})



def liste_devises(request):
    try:
        parametres, _ = Parametre.objects.get_or_create(
            user=request.user,
            defaults={
                "nom_societe": "Ma Soci√©t√©",
                "devise_principale": "USD",
                "devises_acceptees": ["USD", "EUR", "CDF"],
                "openexchangerates_app_id": "",
                "openexchangerates_base_devise": "USD"
            }
        )
    except Exception as e:
        messages.error(request, str(e))
        return redirect('home')

    taux_list = TauxChange.objects.all()

    context = {
        'parametres': parametres,
        'taux_list': taux_list,
        'page_title': "Gestion des Devises",
        'devises_disponibles': json.dumps(get_available_currencies(parametres))
    }

    if request.headers.get('x-requested-with') == 'XMLHttpRequest':
        return render(request, 'tresorerie/devises/partials/rates_table.html', context)

    return render(request, 'tresorerie/devises/liste_devises.html', context)


from django.views.decorators.http import require_http_methods
from django.http import JsonResponse
from django.utils import timezone
from decimal import Decimal
import requests
from .models import Parametre, TauxChange

@require_http_methods(["POST"])
def maj_taux_auto(request):
    if not request.user.is_authenticated:
        return JsonResponse({'status': 'error', 'message': 'Non authentifi√©'}, status=403)

    try:
        parametres = Parametre.objects.get(user=request.user)
        if not parametres.openexchangerates_app_id:
            return JsonResponse({'status': 'error', 'message': 'Cl√© API non d√©finie'}, status=400)

        response = requests.get(
            'https://openexchangerates.org/api/latest.json',
            params={
                'app_id': parametres.openexchangerates_app_id,
                'base': parametres.openexchangerates_base_devise,
                'symbols': ','.join(set(parametres.devises_acceptees + [parametres.devise_principale]))
            },
            timeout=10
        )

        if response.status_code != 200:
            return JsonResponse({'status': 'error', 'message': 'Erreur API'}, status=400)

        data = response.json()

        # Si on veut juste tester l‚ÄôAPI sans modifier la base
        if request.POST.get("test_only"):
            return JsonResponse({'status': 'success', 'message': 'Connexion API r√©ussie'})

        base_rate = data['rates'].get(parametres.devise_principale, 1)
        updated_count = 0

        for devise, taux in data['rates'].items():
            if devise == parametres.devise_principale:
                continue

            taux_converti = Decimal(str(base_rate / taux)) \
                if parametres.openexchangerates_base_devise != parametres.devise_principale \
                else Decimal(str(taux))

            TauxChange.objects.update_or_create(
                devise_source=devise,
                devise_cible=parametres.devise_principale,
                defaults={'taux': taux_converti, 'est_manuel': False}
            )
            updated_count += 1

        return JsonResponse({
            'status': 'success',
            'message': f"{updated_count} taux mis √† jour",
            'last_update': timezone.now().isoformat()
        })

    except requests.Timeout:
        return JsonResponse({'status': 'error', 'message': 'D√©lai API d√©pass√©'}, status=408)
    except Exception as e:
        return JsonResponse({'status': 'error', 'message': str(e)}, status=500)

def modifier_taux(request, taux_id):
    taux = get_object_or_404(TauxChange, id=taux_id)
    parametres = Parametre.objects.first()

    if request.method == 'POST':
        devise_source = request.POST.get('devise_source')
        devise_cible = request.POST.get('devise_cible')
        taux_value = request.POST.get('taux')

        errors = []
        if not devise_source or not devise_cible or not taux_value:
            errors.append("Tous les champs sont obligatoires")
        if devise_source == devise_cible:
            errors.append("Les devises doivent √™tre diff√©rentes")

        try:
            taux_decimal = Decimal(taux_value)
            if taux_decimal <= 0:
                errors.append("Le taux doit √™tre positif")
        except:
            errors.append("Taux invalide")

        if not errors:
            taux.devise_source = devise_source
            taux.devise_cible = devise_cible
            taux.taux = taux_decimal
            taux.est_manuel = True
            taux.save()
            messages.success(request, "Taux mis √† jour avec succ√®s")
            return redirect('liste_devises')
        else:
            for err in errors:
                messages.error(request, err)

    context = {
        'taux': taux,
        'devises_disponibles': sorted(set(parametres.devises_acceptees + [parametres.devise_principale])),
        'page_title': "Modifier Taux de Change"
    }
    return render(request, 'tresorerie/devises/modifier_taux.html', context)

def supprimer_taux(request, taux_id):
    taux = get_object_or_404(TauxChange, id=taux_id)
    if request.method == 'POST':
        taux.delete()
        messages.success(request, "Taux supprim√© avec succ√®s")
        return redirect('liste_devises')
    return render(request, 'tresorerie/devises/confirmer_suppression.html', {'taux': taux})




#reception de stocks
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.forms import formset_factory
from django.http import JsonResponse
from decimal import Decimal
from .models import Reception, LigneReception, Parametre, TauxChange
from .forms import ReceptionForm, LigneReceptionForm

@login_required
def liste_receptions(request):
    receptions = Reception.objects.all().order_by('-date_reception')
    
    # Filtres
    status = request.GET.get('status')
    if status:
        receptions = receptions.filter(status=status)
    
    fournisseur = request.GET.get('fournisseur')
    if fournisseur:
        receptions = receptions.filter(fournisseur__id=fournisseur)
    
    date_debut = request.GET.get('date_debut')
    date_fin = request.GET.get('date_fin')
    if date_debut and date_fin:
        receptions = receptions.filter(date_reception__range=[date_debut, date_fin])
    
    return render(request, 'stock/liste_receptions.html', {
        'receptions': receptions,
        'status_choices': Reception.STATUS_CHOICES,
    })

@login_required
def creer_reception(request):
    LigneFormSet = formset_factory(LigneReceptionForm, extra=1)
    parametres = Parametre.objects.first()

    if request.method == 'POST':
        form = ReceptionForm(request.POST)
        formset = LigneFormSet(request.POST)
        
        if form.is_valid() and formset.is_valid():
            reception = form.save(commit=False)
            reception.created_by = request.user
            
            devise = form.cleaned_data.get('devise') or parametres.devise_principale
            reception.devise = devise
            
            # Correction taux change
            if devise != parametres.devise_principale:
                taux = TauxChange.get_taux(devise, parametres.devise_principale)
                reception.taux_change = taux or 1.0  # Si pas de taux -> 1.0
            else:
                reception.taux_change = 1.0

            reception.save()

            for ligne_form in formset:
                if ligne_form.cleaned_data.get('produit'):
                    ligne = ligne_form.save(commit=False)
                    ligne.reception = reception
                    ligne.save()

            messages.success(request, 'R√©ception cr√©√©e avec succ√®s!')
            return redirect('detail_reception', pk=reception.pk)
    else:
        form = ReceptionForm(initial={
            'devise': parametres.devise_principale,
        })
        formset = LigneFormSet()

    return render(request, 'stock/creer_reception.html', {
        'form': form,
        'formset': formset,
        'devises': parametres.devises_acceptees,
    })


@login_required
def modifier_reception(request, pk):
    reception = get_object_or_404(Reception, pk=pk)
    parametres = get_object_or_404(Parametre, user=request.user)
    LigneFormSet = formset_factory(LigneReceptionForm, extra=1)
    
    if reception.status != 'B':
        messages.error(request, "Seules les r√©ceptions brouillon peuvent √™tre modifi√©es")
        return redirect('detail_reception', pk=reception.pk)

    if request.method == 'POST':
        form = ReceptionForm(request.POST, instance=reception)
        formset = LigneFormSet(request.POST, prefix='lignes')
        
        if form.is_valid() and formset.is_valid():
            try:
                with transaction.atomic():
                    # Mise √† jour des informations de base
                    reception = form.save(commit=False)
                    
                    # Gestion du taux de change
                    nouvelle_devise = form.cleaned_data.get('devise')
                    if nouvelle_devise != reception.devise:
                        taux = TauxChange.get_taux(nouvelle_devise, parametres.devise_principale)
                        if taux is None:
                            raise ValueError(f"Aucun taux de change disponible pour {nouvelle_devise} vers {parametres.devise_principale}")
                        reception.taux_change = taux
                    
                    reception.save()
                    
                    # Suppression des anciennes lignes
                    reception.lignes.all().delete()
                    
                    # Cr√©ation des nouvelles lignes
                    for ligne_form in formset:
                        if ligne_form.cleaned_data.get('produit'):
                            ligne = ligne_form.save(commit=False)
                            ligne.reception = reception
                            ligne.save()
                    
                    messages.success(request, 'R√©ception modifi√©e avec succ√®s!')
                    return redirect('detail_reception', pk=reception.pk)
            
            except Exception as e:
                messages.error(request, f"Erreur lors de la modification: {str(e)}")
                # On laisse le formulaire avec les donn√©es saisies pour correction
    else:
        form = ReceptionForm(instance=reception, initial={
            'devise': reception.devise,
            'taux_change': reception.taux_change
        })
        formset = LigneFormSet(
            prefix='lignes',
            initial=[
                {
                    'produit': l.produit, 
                    'quantite': l.quantite, 
                    'prix_unitaire': l.prix_unitaire,
                    'lot': l.lot, 
                    'date_peremption': l.date_peremption
                } for l in reception.lignes.all()
            ]
        )

    context = {
        'form': form,
        'formset': formset,
        'reception': reception,
        'devises': parametres.devises_acceptees,
        'devise_principale': parametres.devise_principale,
    }
    return render(request, 'stock/modifier_reception.html', context)

@login_required
def supprimer_reception(request, pk):
    reception = get_object_or_404(Reception, pk=pk)
    
    if request.method == 'POST':
        if reception.status != 'B':
            messages.error(request, "Seules les r√©ceptions brouillon peuvent √™tre supprim√©es")
        else:
            reception.delete()
            messages.success(request, 'R√©ception supprim√©e avec succ√®s!')
        return redirect('liste_receptions')
    
    return render(request, 'stock/supprimer_reception.html', {'reception': reception})


@login_required
def detail_reception(request, pk):
    reception = get_object_or_404(Reception, pk=pk)
    parametres = Parametre.objects.first()

    devise_source = reception.devise
    devise_cible = parametres.devise_principale

    taux_change = TauxChange.get_taux(devise_source, devise_cible) or Decimal('1.0')

    # Pr√©parer les montants convertis pour chaque ligne
    lignes_converties = []
    for ligne in reception.lignes.all():
        montant_origine = ligne.prix_unitaire * ligne.quantite
        montant_converti = parametres.convertir_en_devise_principale(montant_origine, devise_source)

        lignes_converties.append({
            'produit': ligne.produit,
            'quantite': ligne.quantite,
            'prix_unitaire': ligne.prix_unitaire,
            'montant_devise_origine': montant_origine,
            'montant_devise_principale': montant_converti,
        })

    # Totaux
    total_origine = sum(l['montant_devise_origine'] for l in lignes_converties)
    total_principale = sum(l['montant_devise_principale'] for l in lignes_converties)

    return render(request, 'stock/detail_reception.html', {
        'reception': reception,
        'parametres': parametres,
        'taux_change': taux_change,
        'lignes_converties': lignes_converties,
        'total_devise_origine': total_origine,
        'total_devise_principale': total_principale,
    })

@login_required
def valider_reception(request, pk):
    reception = get_object_or_404(Reception, pk=pk)
    if reception.status == 'B':
        reception.valider()
        messages.success(request, 'R√©ception valid√©e avec succ√®s!')
    else:
        messages.warning(request, 'Cette r√©ception a d√©j√† √©t√© trait√©e.')
    return redirect('detail_reception', pk=reception.pk)

@login_required
def generer_bon_reception(request, pk):
    reception = get_object_or_404(Reception, pk=pk)
    parametres = Parametre.objects.first()
    
    return render(request, 'stock/bon_reception.html', {
        'reception': reception,
        'parametres': parametres,
    })
    
    
# views.py (ou wherever se trouve ta vue manual_backup)
import os
import json
import io
import zipfile
from datetime import datetime
from django.conf import settings
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from django.core.management import call_command

@csrf_exempt
def manual_backup(request):
    if request.method == 'POST':
        try:
            # Cr√©er le r√©pertoire de sauvegarde s‚Äôil n'existe pas
            backup_dir = settings.BACKUP_DIR
            os.makedirs(backup_dir, exist_ok=True)

            # Nom du fichier de sauvegarde
            now = datetime.now().strftime("%Y%m%d_%H%M%S")
            backup_filename = f"backup_{now}.zip"
            backup_path = os.path.join(backup_dir, backup_filename)

            # Buffer pour les donn√©es JSON
            json_buffer = io.StringIO()

            # Ex√©cuter dumpdata en excluant django_apscheduler
            call_command('dumpdata',
                         '--natural-foreign',
                         '--natural-primary',
                         '--indent', '2',
                         '--exclude', 'django_apscheduler',
                         stdout=json_buffer)

            json_data = json_buffer.getvalue().encode('utf-8')

            # Cr√©er le fichier zip contenant le dump
            with zipfile.ZipFile(backup_path, 'w', zipfile.ZIP_DEFLATED) as zip_file:
                zip_file.writestr('backup.json', json_data)

            return JsonResponse({
                'status': 'success',
                'message': 'Sauvegarde cr√©√©e avec succ√®s',
                'filename': backup_filename
            })

        except Exception as e:
            return JsonResponse({
                'status': 'error',
                'message': str(e)
            }, status=500)

    return JsonResponse({'error': 'M√©thode non autoris√©e'}, status=405)


@csrf_exempt
def restore_backup(request):
    if request.method == 'POST':
        filename = request.POST.get('filename')
        if not filename:
            return JsonResponse({'status': 'error', 'message': 'Nom de fichier manquant'}, status=400)

        backup_path = os.path.join(settings.BACKUP_DIR, filename)
        if not os.path.exists(backup_path):
            return JsonResponse({'status': 'error', 'message': 'Fichier introuvable'}, status=404)

        try:
            call_command('loaddata', backup_path)
            return JsonResponse({'status': 'success', 'message': 'Sauvegarde restaur√©e avec succ√®s'})
        except Exception as e:
            return JsonResponse({'status': 'error', 'message': str(e)}, status=500)

from django.shortcuts import render

def home(request):
    return render(request, 'home.html')  # Cr√©e un fichier home.html simple pour l‚Äôinstant


@login_required
def backup_management(request):
    if not request.user.is_superuser:
        return HttpResponseForbidden("Acc√®s r√©serv√© aux administrateurs")

    try:
        backup_dir = os.path.join(settings.BASE_DIR, 'backups')
        if not os.path.exists(backup_dir):
            os.makedirs(backup_dir)

        backups = []
        for filename in os.listdir(backup_dir):
            if filename.endswith('.zip'):
                filepath = os.path.join(backup_dir, filename)
                stat = os.stat(filepath)

                backups.append({
                    'filename': filename,
                    'path': filepath,
                    'size': stat.st_size,
                    'date': stat.st_mtime,
                    'human_size': sizeof_fmt(stat.st_size),
                    'formatted_date': datetime.fromtimestamp(stat.st_mtime).strftime("%d/%m/%Y %H:%M")
                })

        backups.sort(key=lambda x: x['date'], reverse=True)

        return render(request, 'backup/backup_management.html', {
            'backups': backups,
            'backup_dir': backup_dir,
            'title': 'Gestion des sauvegardes'
        })

    except Exception as e:
        logger.error(f"Erreur dans backup_management : {str(e)}")
        return render(request, 'backup/backup_management.html', {
            'backups': [],
            'error': str(e)
        })


@login_required
def download_backup(request, filename):
    if not request.user.is_superuser:
        return JsonResponse({'status': 'error', 'message': 'Permission refus√©e'}, status=403)

    backup_path = os.path.join(settings.BASE_DIR, 'backups', filename)
    if not os.path.exists(backup_path):
        return JsonResponse({'status': 'error', 'message': 'Fichier non trouv√©'}, status=404)

    response = FileResponse(open(backup_path, 'rb'))
    response['Content-Disposition'] = f'attachment; filename="{filename}"'
    return response


@login_required
def delete_backup(request):
    if not request.user.is_superuser:
        return JsonResponse({'status': 'error', 'message': 'Permission refus√©e'}, status=403)

    filename = request.GET.get('filename')
    if not filename:
        return JsonResponse({'status': 'error', 'message': 'Nom de fichier manquant'}, status=400)

    backup_path = os.path.join(settings.BASE_DIR, 'backups', filename)
    if not os.path.exists(backup_path):
        return JsonResponse({'status': 'error', 'message': 'Fichier non trouv√©'}, status=404)

    try:
        os.remove(backup_path)
        return JsonResponse({'status': 'success', 'message': 'Sauvegarde supprim√©e'})
    except Exception as e:
        return JsonResponse({'status': 'error', 'message': str(e)}, status=500)


def sizeof_fmt(num, suffix='o'):
    """Convertit une taille en format lisible (Ko, Mo, Go, etc.)"""
    for unit in ['','K','M','G','T','P','E','Z']:
        if abs(num) < 1024.0:
            return "%3.1f %s%s" % (num, unit, suffix)
        num /= 1024.0
    return "%.1f %s%s" % (num, 'Y', suffix)

