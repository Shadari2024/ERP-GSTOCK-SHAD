from django.shortcuts import render,redirect,get_object_or_404
from django.views import View
from .models import *
from django.db.models.functions import TruncMonth
from django.views.decorators.csrf import csrf_exempt
import json
from django.db.models.functions import Abs
from django.db.models import Case, When, F, Sum
from django.http import FileResponse
from django.views.decorators.http import require_POST
from django.core.mail import send_mail
from django.contrib.auth.hashers import make_password
from django.utils.crypto import get_random_string
from django.contrib import messages
from django.http import HttpResponse
from django.template.loader import get_template
from xhtml2pdf import pisa
from collections import defaultdict
import tempfile
from weasyprint import HTML
from decimal import Decimal
from django.core.mail import mail_admins
from io import BytesIO
from django.contrib.auth.hashers import make_password
from django.contrib.auth.models import Group
from .utils import envoyer_mail_bienvenue 
from django.core.mail import EmailMultiAlternatives
from django.template.loader import render_to_string
from django.conf import settings
import openpyxl
from openpyxl.styles import Font, Alignment, Border, Side
from django.core.mail import EmailMessage
from django.core.paginator import Paginator
from django.http import JsonResponse
from django.contrib.auth.decorators import login_required,user_passes_test
from django.db import transaction
from decimal import Decimal
import csv
import tempfile
from django.utils.timezone import now
from django.db.models import Q
from django.db.models import Sum,F,Count
from .utils import bilan_caisse_du_jour
from django.contrib.auth import logout
from django.contrib.auth.decorators import login_required, user_passes_test
from datetime import datetime, timedelta
from weasyprint import HTML
from django.template.loader import get_template
from django.http import HttpResponse
from weasyprint import HTML
import tempfile
from .models import InventairePhysique
from django.contrib.auth.decorators import login_required
import json
import base64
from django.views.generic.edit import DeleteView
from django.urls import reverse_lazy
from STOCK.notifications import *
from STOCK.ml.prophet_utils import *
# Create your views here.





from django.http import JsonResponse
from .models import TauxChange, Parametre  # ajuste l'import selon ton app
from django.contrib.auth.decorators import login_required

@login_required
def taux_change_api(request):
    devise_cible = request.GET.get('devise', 'USD').upper()  # sécurité : normalise la saisie
    try:
        parametres = Parametre.objects.get(user=request.user)
        devise_principale = parametres.devise_principale.upper()
    except Parametre.DoesNotExist:
        devise_principale = 'FC'  # valeur par défaut

    # Si la devise demandée est identique à la devise principale
    if devise_cible == devise_principale:
        return JsonResponse({'taux': 1.0})

    try:
        # Chercher un taux direct
        taux = TauxChange.objects.get(
            devise_source=devise_principale,
            devise_cible=devise_cible
        ).taux
        return JsonResponse({'taux': float(taux)})

    except TauxChange.DoesNotExist:
        try:
            # Chercher un taux inverse et l'inverser
            taux_inverse = TauxChange.objects.get(
                devise_source=devise_cible,
                devise_cible=devise_principale
            ).taux
            return JsonResponse({'taux': round(1.0 / float(taux_inverse), 6)})

        except TauxChange.DoesNotExist:
            return JsonResponse({'error': 'Taux non disponible entre %s et %s' % (
                devise_principale, devise_cible)}, status=404)



class ClientView(View):
    template_name ='clients/liste.html'
    
    def get(self,request):
        Clients = Client.objects.all()
        context ={
        'Clients':Clients
    }
        paginate_by = 5
    
        return render(request,self.template_name,context)
    
      
      
    def post(self,request):
        
        return redirect("ClientTableau")
    
#ajout client
class FormulaireViewClient(View):
    template_name = "clients/formulaire_client.html"
    
    def get(self, request):
        return render(request, self.template_name)
    
    def post(self, request):
        nom = request.POST.get('nom')
        email = request.POST.get('email')
        telephone = request.POST.get('telephone')
        adresse = request.POST.get('adresse')

        # Vérifier les doublons
        if Client.objects.filter(email=email).exists():
            messages.error(request, "Cet e-mail est déjà enregistré.")
            return redirect('ajoute_client')

        if Client.objects.filter(telephone=telephone).exists():
            messages.error(request, "Ce numéro de téléphone existe déjà.")
            return redirect('ajoute_client')

        # Si tout est OK, on crée
        try:
            client = Client.objects.create(
                nom=nom,
                email=email,
                telephone=telephone,
                adresse=adresse
            )

            # Message de succès
            messages.success(request, "Client ajouté dans le système")
            return redirect('liste_client')
        
            # Envoi du mail de bienvenue
            subject = f"Bienvenue {client.nom} chez OBED SERVICE"
            from_email = settings.DEFAULT_FROM_EMAIL
            to_email = client.email
            context = {'nom': client.nom, 'email': client.email}
            html_content = render_to_string('emails/bienvenue.html', context)
            msg = EmailMultiAlternatives(subject, '', from_email, [to_email])
            msg.attach_alternative(html_content, "text/html")
            msg.send()

        except Exception as e:
            messages.error(request, f"Erreur lors de l'enregistrement : {e}")

        return redirect('liste_client')


class Detailsclient(View):
    template_name='clients/clientdetails.html'
    def get(self,request,my_id):
        Detaicl = get_object_or_404(Client,id=my_id)
        context = {
            'obj':Detaicl
        }
        
        return render(request,self.template_name,context)
    
    def post(self,request):
        return redirect('ClientTableau')
      
      
#suppression client
class SupClient(View):
    def get(self,request,my_id):
        sup =get_object_or_404(Client,id=my_id)
        sup.delete()
        if sup:
            try:
                messages.success(request,"supression avec succes")
            except Exception as e:
                messages.error(request,f"erreur de supression {e}")
        return redirect("liste_client")
     
    def post(self,request):
        return redirect("liste_client")
         
    
#modification client

class ModifClient(View):
    template_name = "clients/Modificatclient.html"
    
    def get(self,request,my_id):
        mod = get_object_or_404(Client,id=my_id)
        context = {
            "obj":mod
        }
        
        return render(request,self.template_name,context)
        
    def post(self,request,my_id):
        client = get_object_or_404(Client,id=my_id)
        client.nom = request.POST.get('nom')
        client.email= request.POST.get('email')
        client.telephone =request.POST.get('telephone')
        client.adresse = request.POST.get('adresse')
        client.save()
        messages.success(request,"client modifier ")
        return redirect('liste_client')
        
        
# PDF GENERATION CARTE CLIENT
def generate_pdf(request, my_id):
    client = Client.objects.get(id=my_id)
    template_path = 'Gclient/Clientpdf.html'
    context = {'obj': client}

    template = get_template(template_path)
    html = template.render(context)
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = 'attachment; filename="carte_identite.pdf"'
    
    pisa_status = pisa.CreatePDF(BytesIO(html.encode('utf-8')), dest=response)
    
    if pisa_status.err:
        return HttpResponse('Erreur lors de la génération du PDF')
    return response

    
    
# classe categorie pour affiche et voir
class CatView(View):
    template_name ='categorie/liste_cat.html'
    
    def get(self,request):
        categories = Categorie.objects.all()
        paginator = Paginator(categories, 10)  # 10 catégories par page
        page_number = request.GET.get('page')
        page_obj = paginator.get_page(page_number)
        return render(request,self.template_name, {'page_obj': page_obj})
      
    def post(self,request):
        pass
    


      
    #formulaire cat
class FormulaireCat(View):
    template_name = "categorie/form_cat.html"
    
    def get(self, request):
        cat = Categorie.objects.all()
        return render(request,self.template_name,{'cat':cat})
        
    
    def post(self, request):
        if request.method == 'POST':
            nom = request.POST.get('nom')
            photo = request.FILES.get('photo')  # Important: récupérer via FILES

            if nom and photo:
                categorie = Categorie.objects.create(nom=nom, photo=photo)
                messages.success(request, "Catégorie ajoutée avec succès !")
                return redirect('liste_cat')  # ou la page que tu veux

            messages.error(request, "Veuillez remplir tous les champs.")
        
        return render(request, 'categorie/form_cat.html')
    
    
    
    #ajouter produit 
    
class AjouterProduitView(View):
    def get(self, request):
        categories = Categorie.objects.all()
        return render(request, 'produit/ajouter_produit.html', {'categories': categories})

    def post(self, request):
        nom = request.POST['nom']
        description = request.POST.get('description', '')
        prix_achat = request.POST['prix_achat']
        prix_vente = request.POST['prix_vente']
        stock = request.POST['stock']
        seuil_alerte = request.POST['seuil_alerte']
        categorie_id = request.POST['categorie']
        photo = request.FILES.get('photo', None)

        categorie = Categorie.objects.get(id=categorie_id)

        produit = Produit(
            nom=nom,
            description=description,
            prix_achat=prix_achat,
            prix_vente=prix_vente,
            stock=stock,
            seuil_alerte=seuil_alerte,
            categorie=categorie,
            photo=photo
        )

        produit.save()

        # Générer le code-barres après la sauvegarde du produit
        produit.generate_barcode()

        # Sauvegarder après la génération du code-barres
        produit.save()

        return render(request, 'produit/ajouter_produit.html', {'categories': Categorie.objects.all(), 'produit': produit})
#etiquette

from django.shortcuts import get_object_or_404
from django.template.loader import get_template
from django.http import HttpResponse
from weasyprint import HTML
def ticket_produit_pdf(request, pk):
    produit = get_object_or_404(Produit, pk=pk)
    parametres = Parametre.objects.first()
    
    # Récupération du taux de change USD si différent de la devise principale
    taux_usd = None
    prix_vente_usd = None
    
    if parametres and parametres.devise_principale != 'USD':
        taux_usd = TauxChange.get_taux(parametres.devise_principale, 'USD')
        if taux_usd:
            try:
                prix_vente_usd = Decimal(produit.prix_vente) * Decimal(taux_usd)
            except:
                prix_vente_usd = None

    template = get_template('produit/ticket_produit.html')
    html = template.render({
        'produit': produit,
        'parametres': parametres,
        'taux_usd': taux_usd,
        'prix_vente_usd': prix_vente_usd,
    })

    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = f'filename=ticket_produit_{produit.id}.pdf'

    HTML(string=html, base_url=request.build_absolute_uri('/')).write_pdf(response)
    return response

    
    #affiche produit
from django.db.models import F
from decimal import Decimal
from STOCK.models import Parametre, TauxChange, Produit
from django.core.paginator import Paginator
from django.shortcuts import render
from django.http import JsonResponse
def produits_list(request):
    search_query = request.GET.get('search', '')
    
    # Récupération des produits avec annotation du stock réel
    produits = Produit.objects.annotate(
        stock_reel=F('stock')  # Utilise la valeur actuelle de la base
    )
    
    if search_query:
        produits = produits.filter(nom__icontains=search_query)

    # Récupération des paramètres de devise
    try:
        parametres = Parametre.objects.get(user=request.user)
        devise_principale = parametres.devise_principale
        devises_acceptees = parametres.devises_acceptees
    except Parametre.DoesNotExist:
        devise_principale = 'FC'
        devises_acceptees = ['FC']

    # Conversion des prix si nécessaire
    devise_demandee = request.GET.get('devise', devise_principale)
    
    if devise_demandee != devise_principale and devise_demandee in devises_acceptees:
        for produit in produits:
            try:
                produit.prix_vente_converti = TauxChange.convertir(
                    produit.prix_vente,
                    devise_principale, 
                    devise_demandee
                )
                produit.prix_achat_converti = TauxChange.convertir(
                    produit.prix_achat,
                    devise_principale,
                    devise_demandee
                )
                produit.devise_affichage = devise_demandee
            except Exception as e:
                print(f"Erreur conversion: {e}")
                produit.prix_vente_converti = produit.prix_vente
                produit.prix_achat_converti = produit.prix_achat
                produit.devise_affichage = devise_principale
    else:
        for produit in produits:
            produit.prix_vente_converti = produit.prix_vente
            produit.prix_achat_converti = produit.prix_achat
            produit.devise_affichage = devise_principale

    paginator = Paginator(produits, 10)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)

    return render(request, 'produit/liste_produit.html', {
        'page_obj': page_obj,
        'devise_principale': devise_principale,
        'devises_acceptees': devises_acceptees,
        'devise_active': devise_demandee,
        'devise_symbols': {'USD': '$', 'EUR': '€', 'CDF': 'FC'}
    })

def produits_search(request):
    search_query = request.GET.get('search', '')
    produits = Produit.objects.filter(nom__icontains=search_query)[:5]

    # Conversion des prix si nécessaire
    try:
        parametres = Parametre.objects.get(user=request.user)
        devise_principale = parametres.devise_principale
    except:
        devise_principale = 'FC'

    devise_demandee = request.GET.get('devise', devise_principale)

    results = []
    for p in produits:
        prix_vente = p.prix_vente
        if devise_demandee != devise_principale:
            try:
                prix_vente = TauxChange.convertir(p.prix_vente, devise_principale, devise_demandee)
            except Exception as e:
                print(f"Erreur conversion recherche: {e}")
        
        results.append({
            'id': p.id,
            'nom': p.nom,
            'prix': str(Decimal(str(prix_vente)).quantize(Decimal('0.01'))),
            'devise': devise_demandee
        })

    return JsonResponse({'results': results})
#detail produit
def produit_detail(request, id):
    produit = get_object_or_404(Produit, id=id)
    return render(request, 'produit/detail.html', {'produit': produit})

#commande et article 

@login_required
def creer_commande(request):
    if ClotureCaisse.objects.filter(vendeur=request.user, date_jour=now().date()).exists():
        return render(request, "vente/vente_bloquee.html", {"message": "La caisse est déjà clôturée pour aujourd’hui."})
    if request.method == "POST":
        client_id = request.POST.get("client")
        paiement = request.POST.get("paiement")
        expiration = request.POST.get("expiration")
        produits = request.POST.getlist("produit[]")
        quantites = request.POST.getlist("quantite[]")
        prix_unitaires = request.POST.getlist("prix_unitaire[]")

        try:
            with transaction.atomic():
                client = Client.objects.get(id=client_id)
                commande = Commande.objects.create(
                    client=client,
                    paiement=paiement,
                    expiration=expiration,
                    vendeur=request.user
                )

                for produit_id, qte, prix in zip(produits, quantites, prix_unitaires):
                    produit = Produit.objects.select_for_update().get(id=produit_id)
                    quantite = int(qte)

                    if produit.stock < quantite:
                        messages.error(request, f"❌ Stock insuffisant pour le produit **{produit.nom}**. Stock actuel : {produit.stock}")
                        raise ValueError("Stock insuffisant")

                    # Créer la ligne commande
                    LigneCommande.objects.create(
                        commande=commande,
                        produit=produit,
                        quantite=quantite,
                        prix_unitaire=Decimal(prix)
                    )

                    # Déduire le stock
                    produit.stock -= quantite
                    produit.save()

                    # Alerte seuil
                    if produit.stock <= produit.seuil_alerte:
                        messages.warning(request, f"⚠️ Le stock du produit **{produit.nom}** est bas ({produit.stock} unités restantes) !")

                        # Envoyer email à l'admin
                        send_mail(
                            subject=f"Alerte stock bas : {produit.nom}",
                            message=(
                                f"Le stock du produit '{produit.nom}' est tombé à {produit.stock} unités.\n"
                                f"Seuil d'alerte : {produit.seuil_alerte}."
                            ),
                            from_email=settings.DEFAULT_FROM_EMAIL,
                            recipient_list=[settings.ADMINS[0][1]],
                            fail_silently=False,
                        )

                # Total commande
                commande.calculer_total()
                # Juste après commande.calculer_total()
                commande.valider_commande()


                # Récupération des lignes pour PDF
                lignes = commande.lignes.select_related("produit").all()

                # Génération du PDF
                template_pdf = render_to_string("commande/commande_pdf.html", {
                    "commande": commande,
                    "lignes": lignes
                })
                pdf_buffer = BytesIO()
                pisa_status = pisa.CreatePDF(template_pdf, dest=pdf_buffer)

                if not pisa_status.err:
                    # Envoi e-mail client
                    sujet = f"Bon de commande #{commande.id}"
                    message_html = render_to_string("commande/emails_commande.html", {
                        "commande": commande,
                        "lignes": lignes
                    })

                    email = EmailMessage(
                        sujet,
                        message_html,
                        to=[commande.client.email],
                    )
                    email.content_subtype = "html"
                    email.attach(f"commande_{commande.id}.pdf", pdf_buffer.getvalue(), "application/pdf")
                    email.send()

                    messages.success(request, "✅ La commande a bien été créée et envoyée au client par e-mail.")
                else:
                    messages.warning(request, "⚠️ La commande a été créée, mais une erreur est survenue lors de la génération du PDF.")

                return redirect("liste_commandes")

        except Exception as e:
            messages.error(request, f"❌ Erreur lors de la création de la commande : {str(e)}")

    clients = Client.objects.all()
    produits = Produit.objects.all()
    return render(request, "commande/creer_commande.html", {
        "clients": clients,
        "produits": produits
    })
    
#details commande
def detail_commande(request, commande_id):
    commande = get_object_or_404(
        Commande.objects.select_related('client', 'vendeur').prefetch_related('lignes__produit', 'historiques'),
        id=commande_id
    )
    return render(request, "commande/detail_commande.html", {
        "commande": commande,
        "historiques": commande.historiques.all().order_by("-date_modification")
    })


from django.shortcuts import render, get_object_or_404
from django.contrib.auth.decorators import login_required
from django.core.paginator import Paginator
from django.db.models import Q
from decimal import Decimal
from .models import Commande, Parametre, TauxChange

@login_required
def liste_commandes(request):
    parametres = get_object_or_404(Parametre, user=request.user)
    devise_affichee = request.session.get('devise_affichee', parametres.devise_principale)

    # Récupérer le taux USD->CDF
    taux_usd = TauxChange.objects.filter(devise_source='USD', devise_cible='CDF').first()
    taux_usd = taux_usd.taux if taux_usd else 2850  # Valeur par défaut

    commandes_list = Commande.objects.select_related('client', 'vendeur').order_by('-date_commande')
    
    # Filtrage et pagination
    search_query = request.GET.get('search', '')
    if search_query:
        commandes_list = commandes_list.filter(
            Q(id__icontains=search_query) |
            Q(client__nom__icontains=search_query) |
            Q(vendeur__username__icontains=search_query) |
            Q(statut__icontains=search_query)
        )
    
    paginator = Paginator(commandes_list, 10)
    page_number = request.GET.get('page')
    commandes = paginator.get_page(page_number)

    # Pré-formater les montants dans la vue
    for commande in commandes:
        commande.montant_cdf_formate = parametres.format_devise(commande.montant_total, 'CDF')
        if devise_affichee != 'CDF':
            try:
                montant_converti = Decimal(commande.montant_total) / Decimal(taux_usd)
                commande.montant_converti_formate = parametres.format_devise(montant_converti, devise_affichee)
            except:
                commande.montant_converti_formate = "Erreur"

    return render(request, 'commande/liste_commandes.html', {
        'commandes': commandes,
        'devise_affichee': devise_affichee,
        'devise_principale': parametres.devise_principale,
        'taux_usd': taux_usd,
        'devises_acceptees': parametres.devises_acceptees or [parametres.devise_principale],
        'search_query': search_query,
        'parametres': parametres,
    })
    
    
from django.views.decorators.http import require_POST
from django.views.decorators.csrf import csrf_exempt
from django.http import JsonResponse

@require_POST
@csrf_exempt  # Temporaire pour les tests, à remplacer par une gestion CSRF appropriée
def update_taux(request):
    try:
        taux = request.POST.get('taux')
        devise_source = request.POST.get('devise_source', 'USD')
        devise_cible = request.POST.get('devise_cible', 'CDF')
        
        # Valider que le taux est un nombre positif
        taux_decimal = Decimal(taux)
        if taux_decimal <= 0:
            raise ValueError("Le taux doit être positif")

        # Mettre à jour ou créer le taux de change
        taux_obj, created = TauxChange.objects.update_or_create(
            devise_source=devise_source,
            devise_cible=devise_cible,
            defaults={
                'taux': taux_decimal,
                'est_manuel': True
            }
        )

        return JsonResponse({
            'status': 'success',
            'message': 'Taux mis à jour avec succès',
            'taux': str(taux_obj.taux)
        })

    except Exception as e:
        return JsonResponse({
            'status': 'error',
            'message': str(e)
        }, status=400)

@login_required
def convertir_devise(request):
    if request.method == 'POST':
        montant = Decimal(request.POST.get('montant', 0))
        devise_cible = request.POST.get('devise_cible', 'USD')
        
        try:
            # Récupérer le taux USD->CDF (ex: 1 USD = 2850 CDF)
            taux = TauxChange.get_taux(devise_cible, 'CDF')
            if taux:
                montant_converti = montant / taux
                return JsonResponse({
                    'success': True,
                    'montant_converti': f"{montant_converti:.2f}",
                    'devise_cible': devise_cible,
                    'taux': f"1 {devise_cible} = {taux:.6f} CDF"
                })
        except Exception as e:
            return JsonResponse({'success': False, 'error': str(e)})
    
    return JsonResponse({'success': False, 'error': 'Requête invalide'})

#imprimer commande
def commande_pdf(request, commande_id):
    commande = get_object_or_404(Commande.objects.prefetch_related('lignes__produit'), id=commande_id)

    template = render_to_string("commande/commande_pdf.html", {
        "commande": commande,
        "lignes": commande.lignes.all()
    })
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = f'inline; filename="commande_{commande.id}.pdf"'

    pisa_status = pisa.CreatePDF(BytesIO(template.encode("utf-8")), dest=response)

    if pisa_status.err:
        return HttpResponse("Erreur lors de la génération du PDF", status=500)

    return response




#Vue pour modifier le statut
@login_required
def changer_statut_commande(request, commande_id):
    commande = get_object_or_404(Commande, id=commande_id)

    if request.method == "POST":
        nouveau_statut = request.POST.get("statut")
        if nouveau_statut != commande.statut:
            HistoriqueStatut.objects.create(
                commande=commande,
                ancien_statut=commande.statut,
                nouveau_statut=nouveau_statut,
                modifie_par=request.user
            )
            commande.statut = nouveau_statut
            commande.save()
            messages.success(request, "✅ Statut mis à jour avec succès.")

        return redirect("detail_commande", commande_id=commande.id)

    return render(request, "commande/modifier_statut.html", {"commande": commande})


#importation fichier commande csv
@login_required
def export_commandes_csv(request):
    response = HttpResponse(content_type='text/csv')
    response['Content-Disposition'] = 'attachment; filename="commandes.csv"'

    writer = csv.writer(response)
    # Entêtes
    writer.writerow([
        'ID',
        'Client',
        'Email Client',
        'Paiement',
        'Expiration',
        'Vendeur',
        'Email Vendeur',
        'Montant Total',
        'Statut',
        'Date de Création',
    ])

    commandes = Commande.objects.select_related('client', 'vendeur').all()
    for commande in commandes:
        writer.writerow([
            commande.id,
            commande.client.nom if commande.client else '',
            commande.client.email if commande.client else '',
            commande.paiement,
            commande.expiration.strftime('%d/%m/%Y') if commande.expiration else '',
            commande.vendeur.get_full_name() if commande.vendeur else '',
            commande.vendeur.email if commande.vendeur else '',
            commande.montant_total,
            commande.statut,
            commande.date_commande.strftime('%d/%m/%Y %H:%M'),
        ])

    return response

#import excel

def export_commandes_excel(request):
    wb = openpyxl.Workbook()
    ws = wb.active
    ws.title = "Commandes"

    # En-têtes
    headers = [
        "ID", "Client", "Email Client", "Paiement", "Expiration",
        "Vendeur", "Montant Total (FC)", "Statut", "Date de Création"
    ]
    ws.append(headers)

    # Style des en-têtes
    header_font = Font(bold=True)
    border = Border(
        left=Side(style='thin'), right=Side(style='thin'),
        top=Side(style='thin'), bottom=Side(style='thin')
    )
    for col in range(1, len(headers) + 1):
        cell = ws.cell(row=1, column=col)
        cell.font = header_font
        cell.alignment = Alignment(horizontal='center')
        cell.border = border

    # Données
    commandes = Commande.objects.select_related("client", "vendeur").all()
    for commande in commandes:
        ws.append([
            commande.id,
            commande.client.nom,
            commande.client.email,
            commande.paiement,
            commande.expiration.strftime('%d/%m/%Y') if commande.expiration else '',
            commande.vendeur.get_full_name() if commande.vendeur else '',
            float(commande.montant_total),
            commande.statut,
            commande.date_commande.strftime('%d/%m/%Y %H:%M'),
        ])

    # Ajuster la largeur des colonnes
    for column_cells in ws.columns:
        length = max(len(str(cell.value)) if cell.value else 0 for cell in column_cells)
        ws.column_dimensions[column_cells[0].column_letter].width = length + 2

    # Réponse HTTP
    response = HttpResponse(
        content_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
    )
    response["Content-Disposition"] = "attachment; filename=commandes.xlsx"
    wb.save(response)
    return response

def gestion_stock_et_produit(request):
    return render(request,'Gestion des produits et stock/liste.html')

def vente_enligne_(request):
    return render(request,'Vente au comptoir ou en ligne/liste.html')

def Achats_gestion(request):
    return render(request,'achats/liste.html')

#suppression commande
@login_required
def supprimer_commande(request, commande_id):
    commande = get_object_or_404(Commande, id=commande_id)
    
    if request.method == 'POST':
        commande.delete()
        messages.success(request, f"🗑️ La commande #{commande_id} a été supprimée avec succès.")
        return redirect('liste_commandes')
    
    messages.warning(request, "⚠️ Suppression annulée.")
    return redirect('liste_commandes')



#vente confirme

@login_required
def confirmer_commande(request, commande_id):
    commande = get_object_or_404(Commande, id=commande_id)
    if commande.valider_commande():
        messages.success(request, "✅ Vente confirmée et stock mis à jour.")
    else:
        messages.error(request, "❌ Stock insuffisant pour confirmer la vente.")
    return redirect("liste_commandes")


#Vente au comptoire creer
from decimal import Decimal, InvalidOperation



@login_required
def vente_au_comptoir(request):
    today = timezone.now().date()

    # Vérifier si la caisse est clôturée
    if ClotureCaisse.objects.filter(vendeur=request.user, date_jour=today).exists():
        return render(request, "vente/vente_bloquee.html", {
            "message": "La caisse est déjà clôturée pour aujourd'hui."
        })

    # Récupérer les produits et catégories
    produits = Produit.objects.all()
    categories = Categorie.objects.all()

    # Récupérer les paramètres utilisateur
    try:
        parametres = request.user.parametre
        devise_principale = parametres.devise_principale
        devises_acceptees = parametres.devises_acceptees or ['USD', 'CDF']
        devises_formatees = {
            devise: parametres.format_devise(1, devise)
            for devise in devises_acceptees
        }
    except Parametre.DoesNotExist:
        parametres = None
        devise_principale = 'USD'
        devises_acceptees = ['USD', 'CDF']
        devises_formatees = {'USD': '$1.00', 'CDF': 'FC1.00'}

    # Récupérer les taux de change
    taux_change = {}
    for devise in devises_acceptees:
        if devise != devise_principale:
            try:
                taux = TauxChange.get_taux(devise_principale, devise)
                if taux:
                    taux_change[devise] = Decimal(str(taux))
            except ValidationError:
                continue

    # Déterminer la devise à afficher
    devise_affichee = request.session.get('devise_affichee', devise_principale)
    if devise_affichee not in devises_acceptees:
        devise_affichee = devise_principale

    taux_affiche = taux_change.get(devise_affichee, Decimal('1.0'))

    # Préparer les produits avec les prix convertis
    produits_converts = []
    for produit in produits:
        try:
            if parametres and devise_affichee != devise_principale:
                prix_converti = parametres.convertir_vers_devise_affichee(
                    produit.prix_vente, devise_affichee
                )
            else:
                prix_converti = produit.prix_vente
        except ValidationError:
            prix_converti = produit.prix_vente

        produits_converts.append({
            'id': produit.id,
            'libelle': produit.libelle,
            'stock': produit.stock,
            'prix_vente': produit.prix_vente,
            'prix_converti': prix_converti,
            'categorie': produit.categorie.id if produit.categorie else None,
            'code_barre_numero': produit.code_barre_numero,
            'photo': produit.photo,
        })

    context = {
        'categories': categories,
        'produits': produits_converts,
        'today': today.strftime("%Y-%m-%d"),
        'devise_principale': devise_principale,
        'devise_affichee': devise_affichee,
        'devises_acceptees': devises_acceptees,
        'devises_formatees': devises_formatees,
        'taux_change': taux_change,
        'taux_affiche': taux_affiche,
        'parametre': parametres,
    }

    # Traitement de la commande POST
    if request.method == 'POST':
        try:
            client, _ = Client.objects.get_or_create(
                nom="Client Comptoir",
                defaults={'email': 'comptoir@example.com', 'telephone': '0000000000'}
            )

            commande = Commande.objects.create(
                client=client,
                paiement=request.POST.get('paiement', 'cash'),
                expiration=today + timezone.timedelta(days=30),
                vendeur=request.user,
                vente_au_comptoir=True,
                statut="en_attente",
                devise_utilisee=devise_affichee,
                taux_change=taux_affiche
            )

            produits_ids = request.POST.getlist('produit[]')
            quantites = request.POST.getlist('quantite[]')
            prix_unitaire = request.POST.getlist('prix[]')

            for i, produit_id in enumerate(produits_ids):
                produit = Produit.objects.get(id=produit_id)
                quantite = int(quantites[i])

                if produit.stock < quantite:
                    messages.error(request, f"Stock insuffisant pour {produit.libelle}")
                    commande.delete()
                    return redirect('vente_au_comptoir')

                LigneCommande.objects.create(
                    commande=commande,
                    produit=produit,
                    quantite=quantite,
                    prix_unitaire=Decimal(prix_unitaire[i]),
                    devise=devise_affichee
                )

                produit.stock -= quantite
                produit.save()

            commande.calculer_total()
            if commande.valider_commande():
                messages.success(request, f"Vente #{commande.id} enregistrée avec succès!")
                return redirect('ticket_pdf', commande_id=commande.id)
            else:
                messages.error(request, "Erreur lors de la validation de la commande")
                return redirect('vente_au_comptoir')

        except Exception as e:
            messages.error(request, f"Erreur lors de la vente: {str(e)}")
            if 'commande' in locals():
                commande.delete()
            return redirect('vente_au_comptoir')

    return render(request, 'vente/vente_comptoire.html', context)

@login_required
def change_currency(request):
    if request.method == 'POST':
        try:
            data = json.loads(request.body)
            currency = data.get('currency')
            
            # Vérifier que la devise est acceptée
            parametres = request.user.parametre
            if currency in parametres.devises_acceptees:
                request.session['devise_affichee'] = currency
                return JsonResponse({'success': True})
            else:
                return JsonResponse({'success': False, 'error': 'Devise non acceptée'})
                
        except Exception as e:
            return JsonResponse({'success': False, 'error': str(e)})
    return JsonResponse({'success': False})

@login_required
def change_currency(request):
    if request.method == 'POST':
        try:
            data = json.loads(request.body)
            currency = data.get('currency')
            if currency in request.user.parametre.devises_acceptees:
                request.session['devise_affichee'] = currency
                return JsonResponse({'success': True})
        except Exception as e:
            return JsonResponse({'success': False, 'error': str(e)})
    return JsonResponse({'success': False})
#creer ticker
def generer_pdf(template_src, context_dict):
    html = render_to_string(template_src, context_dict)
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = 'attachment; filename="document.pdf"'
    pisa_status = pisa.CreatePDF(html, dest=response)
    if pisa_status.err:
        return HttpResponse('Une erreur est survenue lors de la génération du PDF')
    return response
    
    #vente du jour
    
def ventes_du_jour(request):
    ventes = Commande.objects.filter(date_commande__date=timezone.now().date(), vente_confirmee=True)
    return render(request, 'vente/ventes_du_jour.html', {'ventes': ventes})



def ticket_pdf(request, commande_id):
    commande = get_object_or_404(Commande, id=commande_id)
    parametre = getattr(commande, 'parametre', None)
    if not parametre:
        parametre = Parametre.objects.first() # Assure-toi que ce champ existe sur le modèle Commande

    # Préparation du contexte
    context = {
        'commande': commande,
        'parametre': parametre
    }

    # Rendu HTML à partir du template
    template = get_template('vente/ticket_pdf.html')
    html_string = template.render(context)

    # Création du PDF via WeasyPrint
    html = HTML(string=html_string, base_url=request.build_absolute_uri('/'))

    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = f'inline; filename="ticket_{commande.id}.pdf"'

    html.write_pdf(response)

    return response

def bon_commande_pdf(request, commande_id):
    commande = get_object_or_404(Commande, id=commande_id)
    lignes = LigneCommande.objects.filter(commande=commande)
    context = {
        'commande': commande,
        'lignes': lignes,
    }
    return generer_pdf('pdf/bon_commande.html', context)


#code bare
def chercher_produit_par_code_barres(request):
    code = request.GET.get('code', '')
    try:
        produit = Produit.objects.get(code_barres=code)
        data = {
            'id': produit.id,
            'nom': produit.nom,
            'prix_vente': float(produit.prix_vente),
        }
        return JsonResponse(data)
    except Produit.DoesNotExist:
        return JsonResponse({'error': 'Produit non trouvé'}, status=404)
    
    
    #historique de vente 
def historique_ventes(request):
    ventes = Commande.objects.filter(vente_confirmee=True)

    # Filtres
    date = request.GET.get('date')
    vendeur = request.GET.get('vendeur')

    if date:
        ventes = ventes.filter(date_commande__date=date)
    if vendeur:
        ventes = ventes.filter(vendeur__id=vendeur)

    total = ventes.aggregate(total_journalier=Sum('montant_total'))['total_journalier'] or 0

    vendeurs = Commande.objects.values('vendeur__id', 'vendeur__username').distinct()
    
    

    return render(request, 'vente/historique_ventes.html', {
        'ventes': ventes,
        'total': total,
        'vendeurs': vendeurs,
        'selected_date': date,
        'selected_vendeur': vendeur,
    })
    
    
    
    
    #Statistiques
def format_devise(self, montant, devise=None):
    devise = devise or self.devise_principale
    symboles = {
        'USD': '$',
        'EUR': '€',
        'CDF': 'FC',
        'FC': 'FC'
    }
    symbole = symboles.get(devise, devise)
    return f"{symbole} {montant:,.2f}"


def statistiques(request):
    user = request.user
    param = getattr(user, 'parametre', None)

    if not param:
        return render(request, 'erreur.html', {'message': "Aucun paramètre configuré pour l'utilisateur."})

    devise_source = param.devise_principale or "USD"
    devise_cible = request.GET.get("devise", devise_source)
    aujourd_hui = now().date()

    # Taux de change
    try:
        taux_change = TauxChange.get_taux(devise_source, devise_cible)
        if taux_change is None:
            taux_change = 1.0
    except ValidationError:
        taux_change = 1.0

    # 1. Nombre total d'utilisateurs
    nb_utilisateurs = User.objects.count()
    
    # 2. Nombre d'utilisateurs actifs aujourd'hui
    utilisateurs_actifs = User.objects.filter(
        last_login__date=aujourd_hui
    ).count()

    # Ventes du jour
    ventes_du_jour = Commande.objects.filter(date_commande__date=aujourd_hui)
    total_journalier_source = ventes_du_jour.aggregate(total=Sum('montant_total'))['total'] or 0
    total_journalier_converted = total_journalier_source * taux_change
    total_transactions = ventes_du_jour.count()

    ventes_jour_source = total_journalier_source
    ventes_jour_converted = ventes_jour_source * taux_change

    # Statistiques des produits
    produits_stats = (
        LigneCommande.objects
        .filter(commande__date_commande__date=aujourd_hui)
        .values(
            nom=F('produit__nom'),
            reference=F('produit__code_barre_numero')
        )
        .annotate(
            qte_totale=Sum('quantite'),
            ca_produit=Sum(F('quantite') * F('prix_unitaire'))
        )
        .order_by('-qte_totale')[:5]
    )

    total_produits_vendus = sum([p['qte_totale'] for p in produits_stats]) or 1
    total_produits = 0

    for produit in produits_stats:
        produit['ca_produit_converted'] = produit['ca_produit'] * taux_change
        produit['part_market'] = (produit['qte_totale'] / total_produits_vendus) * 100
        total_produits += produit['qte_totale']

    # Statistiques des vendeurs
    vendeurs_stats = (
        ventes_du_jour
        .values(nom=F('vendeur__username'))
        .annotate(
            total_vendeur=Sum('montant_total'),
            nb_ventes=Count('id')
        )
        .order_by('-total_vendeur')
    )

    for vendeur in vendeurs_stats:
        vendeur['total_vendeur_converted'] = vendeur['total_vendeur'] * taux_change
        vendeur['performance'] = (
            (vendeur['total_vendeur_converted'] / total_journalier_converted * 100)
            if total_journalier_converted > 0 else 0
        )

        if vendeur['performance'] >= 50:
            vendeur['perf_color'] = 'success'
            vendeur['perf_icon'] = 'arrow-up'
        elif vendeur['performance'] >= 20:
            vendeur['perf_color'] = 'warning'
            vendeur['perf_icon'] = 'arrow-right'
        else:
            vendeur['perf_color'] = 'danger'
            vendeur['perf_icon'] = 'arrow-down'

    return render(request, 'stat/statistiquesVente.html', {
        # Statistiques de base
        'total_journalier_converted': total_journalier_converted,
        'ventes_jour_converted': ventes_jour_converted,
        'total_transactions': total_transactions,
        'total_produits': total_produits,
        'produits_populaires': produits_stats,
        'performance_vendeurs': vendeurs_stats,
        
        # Nouveaux indicateurs utilisateurs
        'nb_utilisateurs': nb_utilisateurs,
        'utilisateurs_actifs': utilisateurs_actifs,
        
        # Devises et paramètres
        'now': now(),
        'devise': devise_cible,
        'param': param,
        'taux_change': taux_change,
        
        # Pour la conversion
        'devise_symbols': {'USD': '$', 'CDF': 'FC', 'EUR': '€'},
        'devises_disponibles': ['USD', 'CDF', 'EUR'],
    })

def bilan_caisse_du_jour(vendeur):
    today = timezone.now().date()
    commandes = Commande.objects.filter(
        vente_au_comptoir=True,
        vente_confirmee=True,
        vendeur=vendeur,
        date_commande__date=today
    )

    total = commandes.aggregate(Sum("montant_total"))["montant_total__sum"] or 0
    nb_commandes = commandes.count()

    return {
        "total": total,
        "nb_commandes": nb_commandes,
        "commandes": commandes
    }

@login_required
def cloturer_caisse(request):
    today = timezone.now().date()
    user = request.user
    
    if ClotureCaisse.objects.filter(vendeur=user, date_jour=today).exists():
        messages.warning(request, "La caisse a déjà été clôturée aujourd'hui.")
        return redirect('dashboard')
    
    ventes_du_jour = Commande.objects.filter(
        vendeur=user,
        vente_au_comptoir=True,
        date_commande__date=today,
        vente_confirmee=True
    )
    
    total_ventes = ventes_du_jour.aggregate(
        total=Sum('montant_total'),
        count=Count('id')
    )
    total_vendu = total_ventes['total'] or Decimal('0.00')
    
    if request.method == 'POST':
        try:
            montant_espece = Decimal(request.POST.get('montant_espece', '0'))
            montant_carte = Decimal(request.POST.get('montant_carte', '0'))
            commentaire = request.POST.get('commentaire', '')
            
            if montant_espece < 0 or montant_carte < 0:
                raise ValueError("Les montants ne peuvent pas être négatifs")
                
            total_declare = montant_espece + montant_carte
            tolerance = Decimal('0.01')
            
            # Création de la clôture
            cloture = ClotureCaisse.objects.create(
                vendeur=user,
                date_jour=today,
                montant_total=total_vendu,
                nombre_ventes=total_ventes['count'] or 0,
                montant_espece=montant_espece,
                montant_carte=montant_carte,
                commentaire=commentaire,
                validee=True
            )
            
            # Gestion des écarts
            ecart_montant = abs(total_vendu - total_declare)
            if ecart_montant > tolerance:
                type_ecart = 'manquant' if total_vendu > total_declare else 'excedent'
                
                # Enregistrement de l'écart
                ecart = EcartCaisse.objects.create(
                    cloture=cloture,
                    montant=ecart_montant,
                    type_ecart=type_ecart,
                    commentaire=f"Écart détecté lors de la clôture. {commentaire}"
                )
                
                # Notification admin
                email_content = f"""
                <h3>Nouvel écart de caisse enregistré</h3>
                <p><strong>Vendeur:</strong> {user.get_full_name()} ({user.username})</p>
                <p><strong>Type:</strong> {ecart.get_type_ecart_display()}</p>
                <p><strong>Montant:</strong> {ecart.montant} FC</p>
                <p><strong>Clôture:</strong> #{cloture.id} du {cloture.date_jour}</p>
                <p><strong>Détails:</strong></p>
                <ul>
                    <li>Total système: {total_vendu} FC</li>
                    <li>Total déclaré: {total_declare} FC</li>
                    <li>Espèces: {montant_espece} FC</li>
                    <li>Carte: {montant_carte} FC</li>
                </ul>
                """
                
               # Correction de l'appel à send_mail
                send_mail(
                    subject=f"[ECART CAISSE] {ecart.get_type_ecart_display()} de {ecart.montant}FC",
                    message="",  # message vide car on utilise html_message
                    from_email=settings.DEFAULT_FROM_EMAIL,  # Ajout de l'email expéditeur
                    recipient_list=[admin[1] for admin in settings.ADMINS],
                    html_message=email_content,
                    fail_silently=False,
)
                ecart.notifie_admin = True
                ecart.save()
                
                messages.warning(
                    request,
                    f"Clôture validée avec écart {type_ecart} de {ecart_montant}FC enregistré."
                )
            else:
                messages.success(request, "Clôture validée sans écart.")
            
            return redirect('rapport_cloture', pk=cloture.id)
            
        except Exception as e:
            messages.error(request, f"Erreur: {str(e)}")
            return redirect('cloturer_caisse')
    
    context = {
        'total_ventes': total_vendu,
        'nombre_ventes': total_ventes['count'] or 0,
        'today': today.strftime("%d/%m/%Y"),
    }
    
    return render(request, 'vente/cloturer_caisse.html', context)


#vue ecart

@login_required
@user_passes_test(lambda u: u.is_superuser)
def liste_ecarts(request):
    ecarts = EcartCaisse.objects.select_related('cloture').order_by('-date_decouverte')
    return render(request, 'vente/liste_ecarts.html', {'ecarts': ecarts})

#rapport

@login_required
def rapport_cloture(request, pk):
    cloture = ClotureCaisse.objects.get(pk=pk)
    return render(request, 'vente/rapport_cloture.html', {'cloture': cloture})

#bila
@login_required
def bilan_du_jour(request):
    vendeur = request.user
    today = timezone.now().date()

    commandes = Commande.objects.filter(
        vente_au_comptoir=True,
        vente_confirmee=True,
        vendeur=vendeur,
        date_commande__date=today
    )

    total = commandes.aggregate(Sum("montant_total"))["montant_total__sum"] or 0
    nb_commandes = commandes.count()

    moyen_commande = total / nb_commandes if nb_commandes > 0 else 0

    derniere_commande = commandes.order_by("-date_commande").first()

    lignes = LigneCommande.objects.filter(commande__in=commandes)

    produits_vendus = {}
    for ligne in lignes:
        produit = ligne.produit
        if produit.id not in produits_vendus:
            produits_vendus[produit.id] = {
                "nom": produit.nom,
                "quantite": 0,
                "montant": 0,
            }
        produits_vendus[produit.id]["quantite"] += ligne.quantite
        produits_vendus[produit.id]["montant"] += ligne.sous_total()

    produits_vendus_list = sorted([
        {
            "nom": infos["nom"],
            "quantite": infos["quantite"],
            "montant": infos["montant"]
        }
        for infos in produits_vendus.values()
    ], key=lambda x: x["montant"], reverse=True)

    context = {
        "vendeur": vendeur,
        "date": today,
        "total": total,
        "nb_commandes": nb_commandes,
        "moyen_commande": moyen_commande,
        "derniere_commande": derniere_commande.date_commande if derniere_commande else None,
        "commandes": commandes,
        "produits_vendus": produits_vendus_list
    }

    return render(request, "vente/bilan_du_jour.html", context)
    
def afficher_bilan(request):
    bilan = bilan_caisse_du_jour(request.user)
    nb = bilan["nb_commandes"]
    total = bilan["total"]
    bilan["moyen_commande"] = total / nb if nb > 0 else 0
    bilan["vendeur"] = request.user
    bilan["date"] = timezone.now().date()
    return render(request, "vente/bilan_du_jour.html", bilan)

    
    
def ticket_caisse(request, commande_id):
    commande = get_object_or_404(Commande, pk=commande_id)
    
    # Récupérer les paramètres de l'entreprise
    try:
        parametre = Parametre.objects.first()
    except Parametre.DoesNotExist:
        # Créer un objet par défaut si aucun paramètre n'existe
        parametre = Parametre(
            nom_societe="Ma Société",
            adresse="Adresse non définie",
            telephone="0000000000",
            email="contact@example.com"
        )
    
    context = {
        'commande': commande,
        'parametre': parametre
    }
    return render(request, 'ticket_caisse.html', context)   
from .models import Parametre

    
def ma_vue(request, commande_id):
    commande = get_object_or_404(Commande, pk=commande_id)
    parametre = Parametre.objects.first()  # ou la méthode appropriée pour récupérer les paramètres
    return render(request, 'template.html', {'commande': commande, 'parametre': parametre})
# def afficher_P(request):
#     parametres = Parametre.objects.first()
#     return render(request, "parametres/parametres.html", {
#         "parA": parametres
#     })

def principal(request):
    parametres = Parametre.objects.first()
    return render(request, "stat/principale.html")



#tableau de bord
def dashboard(request):
    today = timezone.now().date()

    ventes_jour = Commande.objects.filter(date__date=today)
    total_journalier = ventes_jour.aggregate(total=Sum('montant'))['total'] or 0
    total_transactions = ventes_jour.count()

    # Top vendeur
    meilleurs = ventes_jour.values('vendeur__username') \
        .annotate(total=Sum('montant')) \
        .order_by('-total')
    meilleur_vendeur = {'nom': meilleurs[0]['vendeur__username']} if meilleurs else {'nom': 'Aucun'}

    # Produits populaires
    produits_populaires = ventes_jour.values('produit__nom') \
        .annotate(total_vendu=Sum('quantite')) \
        .order_by('-total_vendu')[:5]

    context = {
        'total_journalier': total_journalier,
        'total_transactions': total_transactions,
        'meilleur_vendeur': meilleur_vendeur,
        'produits_populaires': [{'nom': p['produit__nom'], 'total_vendu': p['total_vendu']} for p in produits_populaires],
        'now': timezone.now(),
    }
    return render(request, 'stat/dashboard.html', context)



def dashboard(request):
    return render(request, 'stat/statistiquesVente.html')

# def logout_view(request):
#     logout(request)
#     messages.info(request, "Vous êtes maintenant connécté ")
#     return redirect('login')  # Redirection vers la page de login


# #role

# Fonctions de vérification de rôle
def est_admin(user):
    return user.groups.filter(name='Admin').exists()

def est_caissier(user):
    return user.groups.filter(name='Caissier').exists()

def est_stock(user):
    return user.groups.filter(name='Stock').exists()

# Vue pour les caissiers
@login_required
@user_passes_test(est_caissier)
def vue_pour_caissier(request):
    return render(request, "vente/vente_comptoire.html")

# Vue pour le responsable stock
@login_required
@user_passes_test(est_stock)
def vue_stock(request):
    return render(request, "stock/liste_produits.html")

#vue utilisateurs
def is_admin(user):
    return user.groups.filter(name="Admin").exists()

@user_passes_test(is_admin)
def liste_utilisateurs(request):
    utilisateurs = User.objects.all()
    return render(request, 'utilisateurs/liste.html', {'utilisateurs': utilisateurs})

#modifier article
@user_passes_test(is_admin)
def modifier_utilisateur(request, user_id):
    user = User.objects.get(pk=user_id)
    groupes = Group.objects.all()

    if request.method == "POST":
        selected_group_id = request.POST.get("groupe")
        group = Group.objects.get(id=selected_group_id)
        user.groups.clear()
        user.groups.add(group)
        user.save()
        return redirect('liste_utilisateurs')

    return render(request, 'utilisateurs/modifier.html', {'user': user, 'groupes': groupes})

@user_passes_test(is_admin)
def desactiver_utilisateur(request, user_id):
    user = User.objects.get(pk=user_id)
    user.is_active = False
    user.save()
    return redirect('liste_utilisateurs')

@user_passes_test(is_admin)
def activer_utilisateur(request, user_id):
    user = User.objects.get(pk=user_id)
    user.is_active = True
    user.save()
    return redirect('liste_utilisateurs')


def reset_password(request, user_id):
    user = User.objects.get(pk=user_id)
    nouveau_mot_de_passe = get_random_string(10)

    user.password = make_password(nouveau_mot_de_passe)
    user.save()

    sujet = "Réinitialisation de votre mot de passe"
    message = f"""
Bonjour {user.get_full_name() or user.username},

Votre mot de passe a été réinitialisé.

Nom d'utilisateur : {user.username}
Mot de passe : {nouveau_mot_de_passe}

Merci de changer votre mot de passe après connexion.

Cordialement,
L'équipe support
    """.strip()

    send_mail(sujet, message, settings.DEFAULT_FROM_EMAIL, [user.email])

    messages.success(request, f"Mot de passe réinitialisé et envoyé à {user.email}")
    return redirect('liste_utilisateurs')

#ajouter user
def ajouter_utilisateur(request):
    groupes = Group.objects.all()

    if request.method == 'POST':
        username = request.POST.get('username')
        email = request.POST.get('email')
        password = request.POST.get('password')
        groupe_id = request.POST.get('groupe')

        if User.objects.filter(username=username).exists():
            messages.error(request, "Ce nom d'utilisateur existe déjà.")
            return redirect('ajouter_utilisateur')

        user = User.objects.create(
            username=username,
            email=email,
            password=make_password(password),
        )

        if groupe_id:
            group = Group.objects.get(id=groupe_id)
            user.groups.add(group)

        messages.success(request, "Utilisateur créé avec succès.")
        return redirect('liste_utilisateurs')

    return render(request, 'utilisateurs/ajouter_utilisateur.html', {'groupes': groupes})

#categorie par commande
def nouvelle_commande(request):
    # Récupérer tous les produits et catégories
    produits = Produit.objects.select_related('categorie').all()
    categories = Categorie.objects.all()
    clients = Client.objects.all()
    
    context = {
        'produits': produits,
        'categories': categories,
        'clients': clients,
    }
    
    return render(request, 'commande/creer_commande.html', context)


#statistique des produits
def tableau_de_bord(request):
    # Période du mois en cours
    aujourdhui = datetime.now()
    debut_mois = aujourdhui.replace(day=1)
    fin_mois = (debut_mois + timedelta(days=32)).replace(day=1) - timedelta(days=1)
    
    # Correction ici : remplacement de 'lignes_commandes' par 'lignecommande'
    produits = Produit.objects.annotate(
        quantite_vendue=Sum('lignecommande__quantite',
            filter=Q(lignecommande__commande__date_commande__range=[debut_mois, fin_mois])),
        montant_vendu=Sum(F('lignecommande__quantite') * F('lignecommande__prix_unitaire'),
            filter=Q(lignecommande__commande__date_commande__range=[debut_mois, fin_mois]))
    ).select_related('categorie').order_by('-montant_vendu')

    total_ventes = sum(p.quantite_vendue or 0 for p in produits)
    total_ca = sum(p.montant_vendu or 0 for p in produits)
    Produit.objects.filter(stock__lte=F('seuil_alerte')).count(),

    # Stats par catégorie
    categories = Categorie.objects.annotate(
        total_ventes=Sum('produit__lignecommande__quantite',
            filter=Q(produit__lignecommande__commande__date_commande__range=[debut_mois, fin_mois])),
        total_ca=Sum(F('produit__lignecommande__quantite') * F('produit__lignecommande__prix_unitaire'),
            filter=Q(produit__lignecommande__commande__date_commande__range=[debut_mois, fin_mois]))
    ).filter(total_ventes__gt=0)

    context = {
        'stats': produits,
        'categories': categories,
        'total_produits': Produit.objects.count(),
        'total_ventes': total_ventes,
        'total_ca': total_ca,
        'produits_alerte': Produit.objects.filter(stock__lte=F('seuil_alerte')).count(),
        'mois_courant': debut_mois.strftime("%B %Y")
    }
    
    return render(request, 'stat/produits.html', context)

#stat commandes
# views.py - Version complète


from django.contrib.auth.decorators import login_required
from django.db.models import Sum, Count, F, ExpressionWrapper, DecimalField
from django.db.models.functions import TruncMonth
from django.shortcuts import render
from django.utils import timezone
from django.core.exceptions import ValidationError
from decimal import Decimal
from datetime import timedelta
from .models import Commande, LigneCommande, TauxChange, Parametre

@login_required
def commande_stats(request):
    # Filtres
    period = request.GET.get('period', 'month')
    status = request.GET.get('status')
    sale_type = request.GET.get('sale_type')

    user = request.user
    param = getattr(user, 'parametre', None)

    if not param:
        return render(request, 'erreur.html', {'message': "Aucun paramètre configuré pour l'utilisateur."})

    # Gestion de la devise
    devise_source = param.devise_principale or "USD"
    devise_cible = request.GET.get("devise", request.session.get('devise_affichee', devise_source))

    # Vérifier que la devise cible est autorisée
    devises_acceptees = getattr(param, 'devises_acceptees', ['USD', 'EUR', 'CDF', 'XOF', 'FC'])
    if devise_cible not in devises_acceptees:
        devise_cible = devise_source

    # Sauvegarder en session si nouvelle devise valide
    if 'devise' in request.GET and devise_cible in devises_acceptees:
        request.session['devise_affichee'] = devise_cible

    # Taux de change
    try:
        taux_change = TauxChange.get_taux(devise_source, devise_cible)
        taux_change = Decimal(str(taux_change)) if taux_change is not None else Decimal('1.0')
    except ValidationError:
        taux_change = Decimal('1.0')

    # Filtrage des commandes
    queryset = Commande.objects.all()
    if status:
        queryset = queryset.filter(statut=status)
    if sale_type == 'comptoir':
        queryset = queryset.filter(vente_au_comptoir=True)
    elif sale_type == 'normal':
        queryset = queryset.filter(vente_au_comptoir=False)

    today = timezone.now().date()
    if period == 'today':
        queryset = queryset.filter(date_commande__date=today)
    elif period == 'week':
        queryset = queryset.filter(date_commande__date__gte=today - timedelta(days=7))
    elif period == 'month':
        queryset = queryset.filter(date_commande__date__gte=today - timedelta(days=30))
    elif period == 'year':
        queryset = queryset.filter(date_commande__date__gte=today - timedelta(days=365))

    # Calculs statistiques
    total_commandes = queryset.count()
    total_montant_source = queryset.aggregate(total=Sum('montant_total'))['total'] or Decimal('0')
    total_montant = total_montant_source * taux_change
    commandes_annulees = queryset.filter(statut='annulee').count()

    # Formater les montants principaux
    total_montant_formatted = param.format_devise(total_montant, devise_cible)
    total_montant_source_formatted = param.format_devise(total_montant_source, devise_source)

    # Données mensuelles pour graphiques
    monthly_data = (
        queryset.annotate(month=TruncMonth('date_commande'))
               .values('month')
               .annotate(total=Count('id'), amount=Sum('montant_total'))
               .order_by('month')
    )

    months = [entry['month'].strftime("%b") for entry in monthly_data]
    monthly_totals = [entry['total'] for entry in monthly_data]
    monthly_amounts = [
        float((Decimal(str(entry['amount'] or 0)) * taux_change) / Decimal('1000'))
        for entry in monthly_data
    ]

    # Top produits (avec montant formaté)
    top_produits = LigneCommande.objects.filter(
        commande__in=queryset
    ).annotate(
        montant_ligne=ExpressionWrapper(
            F('quantite') * F('prix_unitaire'),
            output_field=DecimalField()
        )
    ).values(
        'produit__nom', 'produit__code_barre_numero'
    ).annotate(
        quantite=Sum('quantite'),
        montant=Sum('montant_ligne')
    ).order_by('-quantite')[:5]

    for produit in top_produits:
        produit['montant_converted'] = Decimal(str(produit['montant'] or 0)) * taux_change
        produit['montant_formatted'] = param.format_devise(produit['montant_converted'], devise_cible)

    # Top clients (avec montant formaté)
    top_clients = queryset.values('client__nom', 'client__id').annotate(
        commandes=Count('id'),
        montant=Sum('montant_total')
    ).order_by('-montant')[:5]

    for client in top_clients:
        client['montant_converted'] = Decimal(str(client['montant'] or 0)) * taux_change
        client['montant_formatted'] = param.format_devise(client['montant_converted'], devise_cible)

    # Commandes récentes (avec montant formaté)
    recent_orders = queryset.select_related('client').order_by('-date_commande')[:10]
    for commande in recent_orders:
        commande.montant_formatted = param.format_devise(commande.montant_total, devise_cible)

    # Préparation des devises pour le template
    noms_devises = {
        'USD': 'Dollar américain ($)',
        'EUR': 'Euro (€)',
        'CDF': 'Franc congolais (FC)',
        'XOF': 'Franc CFA (XOF)',
        'FC': 'Franc congolais (FC)'
    }
    
    devises = {code: noms_devises.get(code, code) for code in devises_acceptees}

    # Contexte
    context = {
        'today': today,
        'total_commandes': total_commandes,
        'total_montant': total_montant,
        'total_montant_formatted': total_montant_formatted,
        'total_montant_source': total_montant_source,
        'total_montant_source_formatted': total_montant_source_formatted,
        'commandes_annulees': commandes_annulees,
        'statuts': queryset.values('statut').annotate(total=Count('id')).order_by('-total'),
        'monthly_labels': months,
        'monthly_totals': monthly_totals,
        'monthly_amounts': monthly_amounts,
        'devise': devise_cible,
        'taux_change': taux_change,
        'param': param,
        'devises': devises,
        'top_clients': top_clients,
        'top_produits': top_produits,
        'recent_orders': recent_orders,
        'active_filters': {
            'period': period,
            'status': status,
            'sale_type': sale_type,
            'devise': devise_cible
        }
    }

    return render(request, 'stat/commande_stats.html', context)
    
def inventaire(request):
    return render(request,"inventaire/inventaire.html")

def etat_stock(request):
    produits = Produit.objects.all()
    categories = Categorie.objects.all()
    fournisseurs = Fournisseur.objects.all()

    # Filtres
    cat = request.GET.get('categorie')
    frs = request.GET.get('fournisseur')
    seuil = request.GET.get('alerte')  # ex: "1" pour alerte activée

    if cat:
        produits = produits.filter(categorie_id=cat)

    if frs:
        produits = produits.filter(fournisseur_id=frs)

    if seuil == "1":
        produits = produits.filter(stock__lte=F('seuil_alerte'))

    context = {
        'produits': produits,
        'categories': categories,
        'fournisseurs': fournisseurs,
        'cat_selected': cat,
        'frs_selected': frs,
        'seuil_selected': seuil,
    }

    return render(request, 'inventaire/etat_stock.html', context)


#mouvement stock
@login_required
def ajouter_mouvement_stock(request):
    produits = Produit.objects.all()

    if request.method == "POST":
        produit_id = request.POST.get("produit")
        type_mouvement = request.POST.get("type")
        quantite = int(request.POST.get("quantite"))
        commentaire = request.POST.get("commentaire")

        produit = Produit.objects.get(id=produit_id)

        # Vérification du stock pour les sorties
        if type_mouvement == "sortie" and quantite > produit.stock:
            messages.error(request, "Stock insuffisant pour cette sortie.")
            return redirect("ajouter_mouvement_stock")

        # Création du mouvement
        mouvement = MouvementStock.objects.create(
            produit=produit,
            type_mouvement=type_mouvement,
            quantite=quantite,
            utilisateur=request.user,
            commentaire=commentaire
        )

        # Mise à jour manuelle du stock (si save() ne le fait pas)
        if type_mouvement == "entree":
            produit.stock += quantite
        elif type_mouvement == "sortie":
            produit.stock -= quantite
        produit.save()

        messages.success(request, "Mouvement enregistré avec succès.")
        return redirect("ajouter_mouvement_stock")

    return render(request, "inventaire/ajouter_mouvement.html", {"produits": produits})



#liste mouvement
from django.utils.dateparse import parse_date

@login_required
def liste_mouvements_stock(request):
    mouvements = MouvementStock.objects.select_related('produit', 'utilisateur').order_by('-date_mouvement')

    # Filtres
    produit_id = request.GET.get("produit")
    type_mouvement = request.GET.get("type")
    utilisateur_id = request.GET.get("utilisateur")
    date_debut = request.GET.get("date_debut")
    date_fin = request.GET.get("date_fin")

    if produit_id:
        mouvements = mouvements.filter(produit_id=produit_id)
    if type_mouvement:
        mouvements = mouvements.filter(type_mouvement=type_mouvement)
    if utilisateur_id:
        mouvements = mouvements.filter(utilisateur_id=utilisateur_id)
    if date_debut:
        mouvements = mouvements.filter(date_mouvement__gte=parse_date(date_debut))
    if date_fin:
        mouvements = mouvements.filter(date_mouvement__lte=parse_date(date_fin))

    produits = Produit.objects.all()
    utilisateurs = User.objects.all()

    context = {
        'mouvements': mouvements,
        'produits': produits,
        'utilisateurs': utilisateurs,
        'filtres': {
            'produit': produit_id,
            'type': type_mouvement,
            'utilisateur': utilisateur_id,
            'date_debut': date_debut,
            'date_fin': date_fin,
        }
    }
    return render(request, "inventaire/liste_mouvements.html", context)

# 🔢 Saisie de l'inventaire physique
@login_required
def saisie_inventaire(request):
    produits = Produit.objects.all()

    if request.method == "POST":
        for produit in produits:
            field_name = f"physique_{produit.id}"
            try:
                stock_physique = int(request.POST.get(field_name, 0))
            except ValueError:
                stock_physique = 0

            stock_theorique = produit.stock
            ecart = stock_physique - stock_theorique

            InventairePhysique.objects.create(
                produit=produit,
                stock_theorique=stock_theorique,
                stock_physique=stock_physique,
                ecart=ecart,
                utilisateur=request.user
            )

        messages.success(request, "Inventaire enregistré avec succès. Passez à la validation.")
        return redirect("liste_inventaires")

    return render(request, "inventaire/saisir_inventaire.html", {"produits": produits})


# 📋 Liste des inventaires non validés
@login_required
def liste_inventaires(request):
    inventaires = InventairePhysique.objects.filter(valide=False).select_related("produit")

    if request.method == "POST":
        for inv in inventaires:
            produit = inv.produit
            produit.stock = inv.stock_physique
            produit.save()

            inv.valide = True
            inv.save()

            MouvementStock.objects.create(
                produit=produit,
                type_mouvement="ajustement",
                quantite=abs(inv.ecart),
                commentaire=f"Ajustement suite à inventaire (écart : {inv.ecart:+})",
                utilisateur=request.user
            )

        messages.success(request, "Stocks ajustés avec succès.")
        return redirect("liste_inventaires")

    return render(request, "inventaire/liste_inventaires.html", {"inventaires": inventaires})


# ✅ Validation manuelle d’un inventaire (option alternative)
@require_POST
@login_required
def valider_inventaire(request):
    for key, value in request.POST.items():
        if key.startswith("quantite_physique_"):
            produit_id = key.split("_")[-1]
            try:
                produit = Produit.objects.get(id=produit_id)
                quantite_physique = int(value)
                ecart = quantite_physique - produit.stock

                if ecart != 0:
                    produit.stock = quantite_physique
                    produit.save()

                    MouvementStock.objects.create(
                        produit=produit,
                        type_mouvement="ajustement",
                        quantite=abs(ecart),
                        commentaire=f"Ajustement suite à inventaire (écart : {ecart:+})",
                        utilisateur=request.user
                    )

            except (Produit.DoesNotExist, ValueError):
                continue

    messages.success(request, "Inventaire validé et stocks mis à jour.")
    return redirect("liste_inventaires")




# partie 1 selection 



#rapport mouvement
@login_required
def rapport_mouvements(request):
    mouvements = MouvementStock.objects.select_related('produit', 'utilisateur').order_by('-date_mouvement')

    # Filtres
    date_debut = request.GET.get("date_debut")
    date_fin = request.GET.get("date_fin")
    type_mouvement = request.GET.get("type")

    if date_debut:
        mouvements = mouvements.filter(date_mouvement__date__gte=parse_date(date_debut))
    if date_fin:
        mouvements = mouvements.filter(date_mouvement__date__lte=parse_date(date_fin))
    if type_mouvement:
        mouvements = mouvements.filter(type_mouvement=type_mouvement)

    # Export CSV
    if request.GET.get("export") == "csv":
        return export_mouvements_csv(mouvements)
    
    # Impression spécifique
    if request.GET.get("print") == "1":
        context = {
            "mouvements": mouvements,
            "date_debut": date_debut,
            "date_fin": date_fin,
            "type_mouvement": type_mouvement,
            "print_mode": True  # Nouveau contexte pour le mode impression
        }
        return render(request, "rapports/rapport_mouvements_print.html", context)

    context = {
        "mouvements": mouvements,
        "date_debut": date_debut,
        "date_fin": date_fin,
        "type_mouvement": type_mouvement,
    }
    return render(request, "rapports/rapport_mouvements.html", context)

def export_mouvements_csv(mouvements):
    response = HttpResponse(content_type="text/csv")
    response["Content-Disposition"] = "attachment; filename=mouvements_stock.csv"

    writer = csv.writer(response)
    writer.writerow(["Date", "Produit", "Type", "Quantité", "Commentaire", "Utilisateur"])

    for m in mouvements:
        writer.writerow([
            m.date_mouvement.strftime("%Y-%m-%d %H:%M"),
            m.produit.nom,
            m.get_type_mouvement_display(),
            m.quantite,
            m.commentaire,
            m.utilisateur.username,
        ])

    return response

#rapport d'alert
@login_required
def rapport_alertes_pdf(request):
    produits_alertes = Produit.objects.filter(stock__lte=F('seuil_alerte'))
    infos = Parametre.objects.first()

    template = get_template("rapports/rapport_alertes_pdf.html")
    html = template.render({
        "produits_alertes": produits_alertes,
        "entreprise": infos,
        "user": request.user
    })

    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = 'attachment; filename="produits_en_alerte.pdf"'
    
    pisa.CreatePDF(BytesIO(html.encode("UTF-8")), dest=response)
    return response

def rapport(request):
    return render(request,"rapports/rapport.html")

def rapport_alert(request):
    return render(request,"rapports/rapport_alert.html")


#ecart rapport



@login_required
def rapport_ecarts_inventaire_pdf(request):
    ecarts = InventairePhysique.objects.filter(ecart__isnull=False).order_by('-date')
    template = get_template("rapports/rapport_ecarts_pdf.html")
    context = {
        "ecarts": ecarts,
        "user": request.user,
        "now": now(),
    }
    html_content = template.render(context)

    buffer = BytesIO()
    HTML(string=html_content).write_pdf(buffer)
    pdf_content = buffer.getvalue()

    response = HttpResponse(pdf_content, content_type='application/pdf')
    response['Content-Disposition'] = 'inline; filename="rapport_ecarts_inventaire.pdf"'
    response['Content-Length'] = len(pdf_content)
    return response

#liste cloture
@login_required
def clotures_du_jour(request):
    today = timezone.now().date()
    clotures = ClotureCaisse.objects.filter(date_jour=today)

    return render(request, "cloture/clotures_du_jour.html", {
        "clotures": clotures,
        "aujourd_hui": today
    })

#pdf cloture
def telecharger_rapport_cloture_pdf(request):
    cloture = ClotureCaisse.objects.filter(vendeur=request.user, date_jour=timezone.now().date()).first()
    if not cloture:
        return HttpResponse("Aucune clôture trouvée pour aujourd’hui.")

    html_string = render_to_string("cloture/rapport_cloture_pdf.html", {"cloture": cloture})
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = 'attachment; filename="rapport_cloture.pdf"'

    HTML(string=html_string).write_pdf(response)
    return response


from django.shortcuts import render
from django.http import JsonResponse
from django.core.files.base import ContentFile
from .models import Produit, Categorie
import base64, json

def ajout_multiple_produits(request):
    if request.method == 'GET':
        categories = Categorie.objects.all()
        return render(request, 'produit/ajout_multiple.html', {'categories': categories})

    elif request.method == 'POST':
        try:
            if not request.POST.get('produits_data'):
                return JsonResponse({'success': False, 'error': 'Aucune donnée reçue'}, status=400)

            produits_data = json.loads(request.POST['produits_data'])
            categorie_id = request.POST.get('categorie')

            produits_crees = []

            for produit_data in produits_data:
                if not all(key in produit_data for key in ['nom', 'prix_achat', 'prix_vente']):
                    continue

                produit = Produit(
                    nom=produit_data['nom'],
                    description=produit_data.get('description', ''),
                    prix_achat=float(produit_data['prix_achat']),
                    prix_vente=float(produit_data['prix_vente']),
                    stock=int(produit_data.get('stock', 0)),
                    seuil_alerte=int(produit_data.get('seuil_alerte', 10))
                )

                if categorie_id:
                    try:
                        produit.categorie = Categorie.objects.get(id=categorie_id)
                    except Categorie.DoesNotExist:
                        pass

                if produit_data.get('photo_data'):
                    try:
                        format, imgstr = produit_data['photo_data'].split(';base64,')
                        ext = format.split('/')[-1]
                        photo_data = base64.b64decode(imgstr)
                        produit.photo.save(
                            f"{produit_data['nom']}_{produit_data['prix_vente']}.{ext}",
                            ContentFile(photo_data),
                            save=False
                        )
                    except Exception as e:
                        print(f"Erreur traitement photo: {str(e)}")

                produit.save()
                produits_crees.append(produit.id)

            return JsonResponse({
                'success': True,
                'message': f'{len(produits_crees)} produits créés avec succès',
                'produits_ids': produits_crees
            })

        except json.JSONDecodeError as e:
            return JsonResponse({'success': False, 'error': f'Données JSON invalides: {str(e)}'}, status=400)
        except Exception as e:
            return JsonResponse({'success': False, 'error': str(e)}, status=500)

    return JsonResponse({'success': False, 'error': 'Méthode non autorisée'}, status=405)


def modifier_produit(request, pk):
    produit = get_object_or_404(Produit, pk=pk)

    if request.method == 'POST':
        produit.nom = request.POST.get('nom')
        produit.reference = request.POST.get('reference')
        produit.categorie_id = request.POST.get('categorie') or None
        produit.prix_achat = request.POST.get('prix_achat') or 0
        produit.prix_vente = request.POST.get('prix_vente') or 0
        produit.stock = request.POST.get('stock') or 0
        produit.tva = request.POST.get('tva') or 0
        produit.description = request.POST.get('description')

        # Gestion de la nouvelle image si elle est envoyée
        if request.FILES.get('photo'):
            produit.photo = request.FILES['photo']

        produit.save()
        messages.success(request,f" Produit  {produit.nom} modifier")
        return redirect('produits_par_categorie')

    context = {
        'produit': produit,
        'categories': Categorie.objects.all(),
    }
    return render(request, 'produit/modifier_produit.html', context)

def imprimer_produit(request, pk):
    """Génère la version PDF de la fiche produit"""
    produit = get_object_or_404(Produit, pk=pk)
    parametres = Parametre.objects.first()
    
    # Génération du code-barres (identique à la vue HTML)
    codebarres_img = None
    if produit.code:
        try:
            code = barcode.get('code128', produit.code, writer=ImageWriter())
            buffer = BytesIO()
            code.write(buffer)
            codebarres_img = base64.b64encode(buffer.getvalue()).decode('utf-8')
        except:
            pass
    
    context = {
        'produit': produit,
        'parametres': parametres,
        'date_impression': timezone.now().strftime("%d/%m/%Y %H:%M"),
        'codebarres_img': codebarres_img
    }
    
    template = get_template('produit/fiche_produit_pdf.html')
    html_content = template.render(context)
    
    buffer_pdf = BytesIO()
    HTML(string=html_content).write_pdf(buffer_pdf)
    buffer_pdf.seek(0)
    
    identifiant = getattr(produit, 'reference', None) or produit.code or produit.id
    nom_fichier = f"Fiche_Produit_{identifiant}.pdf"
    
    return FileResponse(buffer_pdf, content_type='application/pdf', filename=nom_fichier)

from django.shortcuts import render, get_object_or_404
from django.utils import timezone
from django.http import FileResponse
from django.template.loader import get_template
from weasyprint import HTML
from io import BytesIO
import base64


from django.shortcuts import get_object_or_404, render
from django.utils import timezone
from django.db.models import Avg, F
from .models import Produit, Parametre, TauxChange, Categorie
from decimal import Decimal, InvalidOperation
import base64
from io import BytesIO

def voir_produit(request, pk):
    """Affiche la fiche produit avec gestion robuste des données"""
    try:
        # Récupération sécurisée du produit
        produit = get_object_or_404(Produit, pk=pk)
        
        # Préparation des données du produit avec valeurs par défaut
        produit_data = {
            'id': produit.id,
            'nom': produit.nom,
            'description': produit.description or "Aucune description disponible",
            'prix_achat': float(produit.prix_achat),
            'prix_vente': float(produit.prix_vente),
            'prix_vente_suggere': float(produit.prix_vente_suggere()),
            'stock': produit.stock,
            'seuil_alerte': produit.seuil_alerte,
            'taux_tva': float(produit.taux_tva),
            'code_barre_numero': produit.code_barre_numero or "",
            'categorie': produit.categorie,
            'actif': produit.actif,
            'has_photo': bool(produit.photo),
            'has_code_barre': bool(produit.code_barre),
        }

        # Gestion du created_by si le champ existe
        if hasattr(produit, 'created_by') and produit.created_by:
            created_by_info = produit.created_by.get_full_name() or produit.created_by.username
        else:
            created_by_info = "Système"

        # Paramètres et taux de change
        parametres = Parametre.objects.first()
        taux_usd = taux_eur = taux_produit = None
        prix_achat_usd = prix_vente_usd = None
        date_taux = timezone.now().date().strftime("%d/%m/%Y")

        if parametres:
            try:
                # Taux de change USD
                if parametres.devise_principale != 'USD':
                    taux_usd = TauxChange.get_taux('USD', parametres.devise_principale)
                    if taux_usd:
                        prix_achat_usd = produit_data['prix_achat'] / float(taux_usd)
                        prix_vente_usd = produit_data['prix_vente'] / float(taux_usd)
                
                # Taux de change EUR
                if parametres.devise_principale not in ['USD', 'EUR']:
                    taux_eur = TauxChange.get_taux('EUR', parametres.devise_principale)
            except (TypeError, InvalidOperation, AttributeError) as e:
                print(f"Erreur conversion devise: {e}")

        # Gestion des images
        photo_base64 = None
        code_barre_base64 = None
        
        if produit.photo:
            try:
                with produit.photo.open('rb') as photo_file:
                    photo_base64 = base64.b64encode(photo_file.read()).decode('utf-8')
            except Exception as e:
                print(f"Erreur lecture photo: {e}")

        if produit.code_barre:
            try:
                with produit.code_barre.open('rb') as barcode_file:
                    code_barre_base64 = base64.b64encode(barcode_file.read()).decode('utf-8')
            except Exception as e:
                print(f"Erreur lecture code-barres: {e}")

        # Calcul de la marge
        marge_brute = produit_data['prix_vente'] - produit_data['prix_achat']
        try:
            pourcentage_marge = (marge_brute / produit_data['prix_achat']) * 100
        except ZeroDivisionError:
            pourcentage_marge = 0

        # Préparation du contexte final
        context = {
            'produit': produit_data,
            'parametres': parametres,
            'photo_base64': photo_base64,
            'code_barre_base64': code_barre_base64,
            'taux_usd': float(taux_usd) if taux_usd else None,
            'taux_eur': float(taux_eur) if taux_eur else None,
            'prix_achat_usd': round(prix_achat_usd, 2) if prix_achat_usd else None,
            'prix_vente_usd': round(prix_vente_usd, 2) if prix_vente_usd else None,
            'marge_brute': round(marge_brute, 2),
            'pourcentage_marge': round(pourcentage_marge, 2),
            'created_by_info': created_by_info,
            'date_impression': timezone.now().strftime("%d/%m/%Y à %H:%M"),
            'date_taux': date_taux,
        }

        return render(request, 'produit/fiche_produit.html', context)

    except Exception as e:
        # Contexte minimal en cas d'erreur grave
        context = {
            'error': str(e),
            'produit_id': pk,
            'produit': {
                'nom': 'Produit non trouvé',
                'description': 'Impossible de charger les détails du produit',
                'prix_achat': 0,
                'prix_vente': 0,
                'stock': 0,
                'seuil_alerte': 0,
            },
            'created_by_info': "Système",
            'photo_base64': None,
            'code_barre_base64': None,
        }
        return render(request, 'produit/fiche_produit.html', context, status=500)
def imprimer_produit(request, pk):
    """Génère la version PDF"""
    try:
        produit = get_object_or_404(Produit, pk=pk)
        parametres = Parametre.objects.first()
        
        context = {
            'produit': produit,
            'parametres': parametres,
            'date_impression': timezone.now().strftime("%d/%m/%Y %H:%M"),
            'code_barre_img': None
        }
        
        if produit.code_barre:
            try:
                with open(produit.code_barre.path, "rb") as image_file:
                    context['code_barre_img'] = base64.b64encode(image_file.read()).decode('utf-8')
            except Exception as e:
                print(f"Erreur lecture code-barres PDF: {e}")
        
        template = get_template('produit/fiche_produit.html')
        html_content = template.render(context)
        
        buffer = BytesIO()
        HTML(string=html_content).write_pdf(buffer)
        buffer.seek(0)
        
        nom_fichier = f"Fiche_Produit_{produit.nom.replace(' ', '_')}_{produit.id}.pdf"
        return FileResponse(buffer, content_type='application/pdf', filename=nom_fichier)
        
    except Exception as e:
        return render(request, 'produit/fiche_produit.html', {'error': str(e)}, status=500)
    
    

from openpyxl.styles import Font


import openpyxl
from openpyxl.styles import Font
from django.http import HttpResponse
from .models import Produit

def exporter_produits_excel(request):
    wb = openpyxl.Workbook()
    ws = wb.active
    ws.title = "Produits en stock"

    # En-têtes
    headers = ['ID', 'Nom', 'Catégorie', 'Prix Achat', 'Prix Vente', 'Stock','Seuil_alerte']
    ws.append(headers)

    # Style pour l'entête
    for col in range(1, len(headers) + 1):
        ws.cell(row=1, column=col).font = Font(bold=True)

    # Données
    produits = Produit.objects.filter(stock__gt=0)

    for p in produits:
        ws.append([
            p.id,
            p.nom,
            p.categorie.nom if p.categorie else 'Non classé',
            p.prix_achat,
            p.prix_vente,
            p.stock,
            p.seuil_alerte,
        ])

    # Génération du fichier
    response = HttpResponse(
        content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    )
    response['Content-Disposition'] = 'attachment; filename=produits_en_stock.xlsx'
    wb.save(response)
    return response
import io
def exporter_produits_pdf(request):
    categorie_id = request.GET.get('categorie')

    produits = Produit.objects.all()
    if categorie_id:
        produits = produits.filter(categorie_id=categorie_id)

    context = {
        'produits': produits,
        'parametres': Parametre.objects.first(),
        'user': request.user,
        'now': timezone.now(),
    }

    html = render_to_string("produit/produits_pdf.html", context)
    response = HttpResponse(content_type="application/pdf")
    response['Content-Disposition'] = 'attachment; filename="liste_produits.pdf"'  # Changé de 'inline' à 'attachment'
    HTML(string=html).write_pdf(response)
    return response




#export bd
from django.http import HttpResponse
from django.core.management import call_command
import io
from datetime import datetime
from django.contrib.admin.views.decorators import staff_member_required

@staff_member_required
def telecharger_sauvegarde(request):
    now = datetime.now().strftime('%Y-%m-%d_%H-%M')
    buffer = io.StringIO()
    call_command('dumpdata', indent=2, stdout=buffer)
    response = HttpResponse(buffer.getvalue(), content_type='application/json')
    response['Content-Disposition'] = f'attachment; filename=backup_{now}.json'
    return response
#facture

def creer_facture(request, commande_id):
    commande = get_object_or_404(Commande, pk=commande_id)
    
    if request.method == 'POST':
        numero = request.POST.get('numero')
        if not numero:
            numero = f"FACT-{commande.id}-{commande.date_commande.year}"
        
        facture = Facture.objects.create(
            commande=commande,
            numero=numero,
            montant_total=commande.montant_total
        )
        messages.success(request, 'Facture créée avec succès!')
        return redirect('detail_facture', pk=facture.id)
    
    return render(request, 'factures/creer_facture.html', {'commande': commande})

from django.views.decorators.http import require_http_methods
from django.contrib import messages

@require_http_methods(["POST"])
def enregistrer_paiement(request, facture_id):
    facture = get_object_or_404(Facture, id=facture_id)
    
    try:
        montant = Decimal(request.POST.get('montant', 0))
        methode = request.POST.get('methode', 'especes')
        
        if montant <= 0:
            messages.error(request, "Le montant doit être positif")
            return redirect('detail_facture', pk=facture.id)
            
        # Crée le paiement (qui mettra à jour la facture automatiquement)
        Paiement.objects.create(
            facture=facture,
            montant=montant,
            methode=methode
        )
        
        messages.success(request, "Paiement enregistré avec succès !")
        return redirect('detail_facture', pk=facture.id)
        
    except (ValueError, InvalidOperation):
        messages.error(request, "Montant invalide")
        return redirect('detail_facture', pk=facture.id)
    
    
def detail_facture(request, pk):
    facture = get_object_or_404(Facture, pk=pk)
    parametres = Parametre.objects.first()
    context = {
        'facture': facture,
        'paiements': facture.paiement_set.all(),
        'reste': facture.reste_a_payer(),
        'parametres': parametres
    }
    return render(request, 'factures/detail_facture.html', context)

from reportlab.pdfgen import canvas
def facture_pdf(request, pk):
    facture = get_object_or_404(Facture, pk=pk)
    response = HttpResponse(content_type='application/pdf')
    p = canvas.Canvas(response)
    p.drawString(100, 750, f"Facture {facture.numero}")
    p.showPage()
    p.save()
    return response

# Dans views.py
from django.views.generic import CreateView

class AjoutPaiement(CreateView):
    model = Paiement
    fields = ['montant', 'methode']
    template_name = 'factures/ajout_paiement.html'

    def form_valid(self, form):
        form.instance.facture = get_object_or_404(Facture, pk=self.kwargs['pk'])
        return super().form_valid(form)

def liste_paiements(request):
    # Récupération des paramètres de l'entreprise
    parametres = Parametre.objects.first()
    
    # Récupération de tous les paiements avec les relations optimisées
    paiements = Paiement.objects.select_related(
        'facture', 
        'facture__commande', 
        'facture__commande__client'
    ).order_by('-date')

    # Calcul des statistiques globales
    stats = paiements.aggregate(
        total=Sum('montant'),
        count=Count('id'),
        moyenne=Avg('montant')
    )

    # Préparation du contexte
    context = {
        'parametres': parametres,
        'paiements': paiements,
        'methodes': Paiement.methodes_disponibles(),
        'total_paiements': stats['total'] or 0,
        'moyenne_paiements': stats['moyenne'] or 0,
    }
    
    return render(request, 'factures/liste_paiements.html', context)


from django.shortcuts import render, get_object_or_404, redirect
from django.contrib import messages


def liste_factures(request):
    factures = Facture.objects.all().order_by('-date')
    context = {'factures': factures}
    return render(request, 'factures/liste_factures.html', context)

def liste_paiements(request):
    paiements = Paiement.objects.select_related('facture').order_by('-date')
    context = {'paiements': paiements}
    return render(request, 'factures/liste_paiements.html', context)

def actions_facture(request, facture_id):
    facture = get_object_or_404(Facture, pk=facture_id)
    
    if request.method == 'POST':
        action = request.POST.get('action')
        
        if action == 'marquer_payee' and facture.reste_a_payer() <= 0:
            facture.statut = 'payee'
            facture.save()
            messages.success(request, "Facture marquée comme payée")
        
        elif action == 'annuler':
            facture.statut = 'annulee'
            facture.save()
            messages.warning(request, "Facture annulée")
            
        return redirect('liste_factures')
    
    return render(request, 'factures/actions_facture.html', {'facture': facture})








from django.views.generic import ListView, CreateView, UpdateView, DetailView
from django.urls import reverse_lazy
from django.contrib.messages.views import SuccessMessageMixin

class FournisseurListView(ListView):
    model = Fournisseur
    template_name = 'achats/fournisseur_list.html'
    context_object_name = 'fournisseurs'
    paginate_by = 10

    def get_queryset(self):
        queryset = super().get_queryset()
        search_query = self.request.GET.get('search')
        type_filter = self.request.GET.get('type')
        
        if search_query:
            queryset = queryset.filter(Q(nom__icontains=search_query) | Q(telephone__icontains=search_query))
        if type_filter:
            queryset = queryset.filter(type=type_filter)
            
        return queryset

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['search_query'] = self.request.GET.get('search', '')
        context['selected_type'] = self.request.GET.get('type', '')
        return context

class FournisseurCreateView(SuccessMessageMixin, CreateView):
    model = Fournisseur
    template_name = 'achats/fournisseur_form.html'
    fields = ['nom', 'type', 'telephone', 'email', 'adresse', 'notes']
    success_url = reverse_lazy('fournisseur_list')
    success_message = "Fournisseur créé avec succès"
    
    
class FournisseurDetailView(DetailView):
    model = Fournisseur
    template_name = 'achats/fournisseur_detail.html'
    context_object_name = 'fournisseur'

class FournisseurUpdateView(SuccessMessageMixin, UpdateView):
    model = Fournisseur
    template_name = 'achats/fournisseur_form.html'
    fields = ['nom', 'type', 'telephone', 'email', 'adresse', 'notes']
    success_url = reverse_lazy('fournisseur_list')
    success_message = "Fournisseur modifié avec succès"

from django.views.generic.edit import DeleteView
from django.urls import reverse_lazy
from django.contrib import messages
from django.db.models import ProtectedError
from django.shortcuts import redirect
from .models import Fournisseur

class FournisseurDeleteView(DeleteView):
    model = Fournisseur
    template_name = 'achats/fournisseur_confirm_delete.html'
    success_url = reverse_lazy('fournisseur_list')

    def post(self, request, *args, **kwargs):
        self.object = self.get_object()
        try:
            self.object.delete()
            messages.success(request, "Fournisseur supprimé avec succès.")
        except ProtectedError:
            messages.error(request, "Ce fournisseur ne peut pas être supprimé car il est lié à un ou plusieurs achats.")
        return redirect(self.success_url)



class AchatCreateView(SuccessMessageMixin, CreateView):
    model = Achat
    template_name = 'achats/achat_form.html'
    fields = ['fournisseur', 'produit', 'quantite', 'prix_unitaire', 'date_achat', 'numero_facture', 'notes']
    success_message = "Achat enregistré avec succès"

    def form_valid(self, form):
        form.instance.created_by = self.request.user
        return super().form_valid(form)

    def get_success_url(self):
        return reverse_lazy('achat_detail', kwargs={'pk': self.object.pk})

class AchatDetailView(DetailView):
    model = Achat
    template_name = 'achats/achat_detail.html'

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        achat = self.object

        # ✅ Vérifie que l'objet Parametre existe dans ta base de données
        context['parametres'] = Parametre.objects.first()

        # ✅ Stock avant achat
        context['stock_avant'] = achat.produit.stock - achat.quantite if achat.quantite else achat.produit.stock

        # ✅ Auteur de l'achat
        context['auteur_achat'] = achat.created_by if achat.created_by else None

        return context
    
    
    
from weasyprint import HTML, CSS  
    
 #impression    
def achat_pdf_view(request, pk):
    achat = get_object_or_404(Achat, pk=pk)
    parametres = Parametre.objects.first()
    
    # Calcul des montants
    taux_tva = Decimal(parametres.taux_tva) if parametres else Decimal(0)
    total_ttc = Decimal(achat.quantite) * Decimal(achat.prix_unitaire)
    
    # Calcul HT et TVA
    if taux_tva:
        total_ht = total_ttc / (1 + taux_tva/100)
        montant_tva = total_ttc - total_ht
    else:
        total_ht = total_ttc
        montant_tva = Decimal(0)

    # Conversion devise
    taux_change = Decimal(1)
    montant_converti = None
    if achat.devise != parametres.devise_principale:
        taux_change = TauxChange.get_taux(achat.devise, parametres.devise_principale) or Decimal(1)
        montant_converti = total_ttc * taux_change

    context = {
        'achat': achat,
        'parametres': parametres,
        'total_ttc': total_ttc,  # Le total TTC principal
        'total': total_ttc,      # Alias pour compatibilité template
        'total_ht': total_ht,
        'montant_tva': montant_tva,
        'taux_tva': taux_tva,
        'taux_change': taux_change,
        'montant_converti': montant_converti,
        'stock_avant': achat.produit.stock - achat.quantite,
        'auteur': achat.created_by,
        'date_generation': timezone.now(),
    }
    
    if parametres.logo:
        context['logo_path'] = parametres.logo.path

    template = get_template("achats/achat_pdf.html")
    html = template.render(context)
    
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = f'inline; filename="facture_achat_{achat.id}.pdf"'
    HTML(string=html).write_pdf(response)
    return response


from django.contrib.auth.mixins import LoginRequiredMixin

from django.views.generic import ListView
from django.db.models import DecimalField
from decimal import Decimal
from django.core.exceptions import ValidationError
from django.contrib.auth.mixins import LoginRequiredMixin


class AchatListView(LoginRequiredMixin, ListView):
    model = Achat
    template_name = 'achats/achat_list.html'
    context_object_name = 'achats'
    paginate_by = 15

    def get_queryset(self):
        queryset = super().get_queryset().select_related('fournisseur', 'produit')

        date_debut = self.request.GET.get('date_debut')
        date_fin = self.request.GET.get('date_fin')
        fournisseur_id = self.request.GET.get('fournisseur')

        if date_debut:
            queryset = queryset.filter(date_achat__gte=date_debut)
        if date_fin:
            queryset = queryset.filter(date_achat__lte=date_fin)
        if fournisseur_id:
            queryset = queryset.filter(fournisseur_id=fournisseur_id)

        return queryset.order_by('-date_achat')

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)

        try:
            parametres = Parametre.objects.get(user=self.request.user)
            devise_principale = parametres.devise_principale
            devises_acceptees = parametres.devises_acceptees or ['USD', 'CDF']
        except Parametre.DoesNotExist:
            devise_principale = 'USD'
            devises_acceptees = ['USD', 'CDF']

        devise_affichee = self.request.session.get('devise_affichee', devise_principale)
        if devise_affichee not in devises_acceptees:
            devise_affichee = devise_principale
            self.request.session['devise_affichee'] = devise_affichee

        devise_symbols = {
            'USD': '$',
            'EUR': '€',
            'CDF': 'FC',
            'XOF': 'CFA',
            'FC': 'FC',
        }

        achats = context['achats']
        total_achats = Decimal('0.00')
        total_quantite = Decimal('0.00')

        for achat in achats:
            try:
                if achat.devise != devise_affichee:
                    taux = TauxChange.get_taux(achat.devise, devise_affichee)
                    if taux is None:
                        raise ValidationError(f"Taux non disponible entre {achat.devise} et {devise_affichee}")
                    achat.prix_unitaire_converti = achat.prix_unitaire * taux
                    achat.total_converti = achat.total_achat * taux
                else:
                    achat.prix_unitaire_converti = achat.prix_unitaire
                    achat.total_converti = achat.total_achat

                total_achats += achat.total_converti
                total_quantite += achat.quantite

            except (ValidationError, Exception) as e:
                print(f"Erreur conversion devise pour achat {achat.id}: {str(e)}")
                achat.prix_unitaire_converti = achat.prix_unitaire
                achat.total_converti = achat.total_achat
                total_achats += achat.total_achat
                total_quantite += achat.quantite

        context.update({
            'total_achats': total_achats,
            'total_quantite': total_quantite,
            'achats_count': achats.count(),
            'devise_affichee': devise_affichee,
            'devises_disponibles': devises_acceptees,
            'devise_symbols': devise_symbols,
            'fournisseurs': Fournisseur.objects.all().order_by('nom'),
            'selected_fournisseur': self.request.GET.get('fournisseur', ''),
            'date_debut': self.request.GET.get('date_debut', ''),
            'date_fin': self.request.GET.get('date_fin', ''),
            'devise_principale': devise_principale,
        })

        return context


   

@login_required
def liste_notifications(request):
    notifications = request.user.notifications.all().order_by('-date_creation')
    return render(request, 'notifications/liste.html', {'notifications': notifications})


def notifier_facture_impayee(facture):
    if not facture.est_payee:
        for utilisateur in User.objects.filter(is_staff=True):
            Notification.objects.create(
                utilisateur=utilisateur,
                message=f"Facture #{facture.id} non payée pour {facture.client.nom}.",
                url=f"/factures/{facture.id}/"
            )


#facture pdf 
from django.http import HttpResponse, Http404
from django.template.loader import get_template
from django.views import View
from django.contrib.auth.mixins import LoginRequiredMixin
from xhtml2pdf import pisa
from io import BytesIO
import logging
import os
logger = logging.getLogger(__name__)

class FacturePDFView(LoginRequiredMixin, View):
    def get(self, request, pk):
        try:
            facture = Facture.objects.select_related(
                'commande__client',
                'commande__vendeur'
            ).prefetch_related(
                'commande__lignes__produit'
            ).get(pk=pk)
        except Facture.DoesNotExist:
            raise Http404("Facture non trouvée.")
        
        parametres = Parametre.objects.first()
        
        context = {
            "facture": facture,
            "parametres": parametres,
            "user": request.user,
        }

        try:
            template = get_template("factures/facture_pdf.html")
            html = template.render(context)
            
            result = BytesIO()
            
            # Configuration supplémentaire pour xhtml2pdf
            pdf = pisa.pisaDocument(
                BytesIO(html.encode("UTF-8")),
                result,
                encoding='UTF-8',
                link_callback=self.link_callback
            )
            
            if not pdf.err:
                response = HttpResponse(result.getvalue(), content_type='application/pdf')
                filename = f"facture_{facture.numero or facture.id}.pdf"
                response['Content-Disposition'] = f'inline; filename="{filename}"'
                return response
            else:
                logger.error(f"Erreur PDF: {pdf.err}")
                return HttpResponse("Erreur lors de la génération du PDF", status=500)
                
        except Exception as e:
            logger.error(f"Erreur génération facture: {str(e)}")
            return HttpResponse(f"Erreur serveur: {str(e)}", status=500)

    def link_callback(self, uri, rel):
        """
        Callback pour gérer les ressources (images, CSS)
        """
        # Chemin absolu pour les médias
        if uri.startswith(settings.MEDIA_URL):
            path = os.path.join(settings.MEDIA_ROOT, uri.replace(settings.MEDIA_URL, ""))
        # Chemin absolu pour les fichiers statiques
        elif uri.startswith(settings.STATIC_URL):
            path = os.path.join(settings.STATIC_ROOT, uri.replace(settings.STATIC_URL, ""))
        else:
            path = None
            
        if path and os.path.isfile(path):
            return path
        return None
    
    
 
  #retour mses 
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.http import JsonResponse
from django.db import transaction

from .models import RetourProduit, LigneRetour



@login_required
def liste_retours(request):
    retours = RetourProduit.objects.select_related('commande', 'responsable').order_by('-date_creation')
    context = {
        'retours': retours,
        'statuts': dict(RetourProduit.STATUT_RETOUR)
    }
    return render(request, 'retours/liste.html', context)


@login_required
def creer_retour(request, commande_id):
    commande = get_object_or_404(Commande, id=commande_id)
    
    if request.method == 'POST':
        try:
            with transaction.atomic():
                retour = RetourProduit.objects.create(
                    commande=commande,
                    responsable=request.user,
                    motif=request.POST.get('motif'),
                    notes=request.POST.get('notes', '')
                )
                
                for ligne in commande.lignes.all():
                    quantite = int(request.POST.get(f'quantite_{ligne.id}', 0))
                    if quantite > 0:
                        LigneRetour.objects.create(
                            retour=retour,
                            produit=ligne.produit,
                            quantite=quantite,
                            prix_unitaire=ligne.prix_unitaire
                        )
                
                messages.success(request, "Retour créé avec succès.")
                return redirect('detail_retour', retour.id)
                
        except Exception as e:
            messages.error(request, f"Erreur lors de la création : {str(e)}")
    
    context = {
        'commande': commande,
        'motifs': dict(RetourProduit.MOTIF_RETOUR)
    }
    return render(request, 'retours/creer.html', context)


@login_required
def detail_retour(request, retour_id):
    retour = get_object_or_404(
        RetourProduit.objects.select_related('commande__client', 'responsable')
                             .prefetch_related('lignes__produit'),
        id=retour_id
    )

    parametre = Parametre.objects.first()  # On suppose qu'il n'y a qu'un seul enregistrement

    context = {
        'retour': retour,
        'user': request.user,
        'is_responsable': retour.responsable == request.user,
        'is_admin': request.user.is_superuser,
        'parametre': parametre,  # informations de l'entreprise
    }

    return render(request, 'retours/detail.html', context)

@login_required
def traiter_retour(request, retour_id):
    retour = get_object_or_404(RetourProduit, id=retour_id)
    
    if not hasattr(retour, 'peut_etre_traite') or not retour.peut_etre_traite():
        messages.warning(request, "Ce retour ne peut pas être traité.")
        return redirect('detail_retour', retour.id)
    
    if request.method == 'POST':
        if retour.traiter(request.user):
            messages.success(request, "Retour traité avec succès. Stock mis à jour.")
        else:
            messages.error(request, "Erreur lors du traitement.")
        
        return redirect('detail_retour', retour.id)
    
    return render(request, 'retours/traiter.html', {'retour': retour})


@login_required
def get_lignes_commande(request, commande_id):
    commande = get_object_or_404(Commande, id=commande_id)
    lignes = LigneCommande.objects.filter(commande=commande).select_related('produit')
    
    data = [{
        'id': ligne.id,
        'produit_id': ligne.produit.id,
        'nom': ligne.produit.nom,
        'reference': ligne.produit.code_barre_numero or '-',
        'quantite_max': ligne.quantite,
        'prix': str(ligne.prix_unitaire),
    } for ligne in lignes]
    
    return JsonResponse({'data': data}, safe=False)

def parametre(request):
    return render(request,'paramettre/paramettre.html')


#remises et promotions
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth.decorators import login_required, permission_required
from django.contrib import messages
from django.http import JsonResponse
from django.db import transaction
from django.utils import timezone
from .models import Promotion, RemiseCommande

@login_required
@permission_required('promotions.can_manage_promotions', raise_exception=True)
def liste_promotions(request):
    """Liste toutes les promotions avec filtres"""
    now = timezone.now()
    
    try:
        entreprise = Parametre.objects.get(user=request.user)
    except Parametre.DoesNotExist:
        messages.error(request, "Aucune entreprise associée à cet utilisateur.")
        return redirect('dashboard')  # ou autre

    promotions = Promotion.objects.select_related('produit', 'categorie', 'created_by') \
                                  .filter(entreprise=entreprise) \
                                  .order_by('-date_creation')
    
    # Filtres
    statut = request.GET.get('statut')
    if statut == 'actives':
        promotions = promotions.filter(actif=True, date_debut__lte=now, date_fin__gte=now)
    elif statut == 'inactives':
        promotions = promotions.filter(actif=False)
    elif statut == 'futures':
        promotions = promotions.filter(date_debut__gt=now)
    elif statut == 'expirees':
        promotions = promotions.filter(date_fin__lt=now)
    
    type_remise = request.GET.get('type_remise')
    if type_remise in ['pourcentage', 'montant_fixe']:
        promotions = promotions.filter(type_remise=type_remise)
    
    return render(request, 'promotions/liste.html', {
        'promotions': promotions,
        'now': now,
        'filtres': {
            'statut': statut,
            'type_remise': type_remise
        }
    })


@login_required
@permission_required('promotions.can_manage_promotions', raise_exception=True)
def creer_promotion(request):
    """Crée une nouvelle promotion"""
    if request.method == 'POST':
        try:
            with transaction.atomic():
                # Récupérer l'entreprise liée à l'utilisateur
                entreprise = Parametre.objects.get(user=request.user)
                
                # Activer la promotion par défaut sauf si explicitement désactivée
                actif = 'actif' not in request.POST or request.POST.get('actif') == 'on'
                
                # Validation des données
                type_remise = request.POST.get('type_remise')
                if type_remise not in dict(Promotion.TypeRemise.choices):
                    raise ValidationError("Type de remise invalide")
                
                promotion = Promotion.objects.create(
                    nom=request.POST.get('nom'),
                    description=request.POST.get('description', ''),
                    type_remise=type_remise,
                    valeur=Decimal(request.POST.get('valeur')),  # Conversion en Decimal
                    appliquer_a=request.POST.get('appliquer_a'),
                    produit_id=request.POST.get('produit') or None,
                    categorie_id=request.POST.get('categorie') or None,
                    date_debut=request.POST.get('date_debut'),
                    date_fin=request.POST.get('date_fin'),
                    actif=actif,
                    code_promo=request.POST.get('code_promo') or None,
                    usage_unique=request.POST.get('usage_unique') == 'on',
                    utilisations_max=int(request.POST.get('utilisations_max', 1)),
                    created_by=request.user,
                    entreprise=entreprise
                )
                
                messages.success(request, "Promotion créée avec succès")
                return redirect('liste_promotions')
        
        except Parametre.DoesNotExist:
            messages.error(request, "Aucune entreprise associée à votre compte")
        except ValidationError as e:
            messages.error(request, f"Erreur de validation: {str(e)}")
        except ValueError as e:
            messages.error(request, f"Valeur incorrecte: {str(e)}")
        except Exception as e:
            messages.error(request, f"Erreur lors de la création: {str(e)}")
            logger.error(f"Erreur création promotion: {str(e)}", exc_info=True)
    
    # Préparation des données pour le template
    produits = Produit.objects.filter(actif=True).order_by('nom')
    categories = Categorie.objects.all().order_by('nom')
    
    return render(request, 'promotions/creer.html', {
        'produits': produits,
        'categories': categories,
        'type_remise_choices': Promotion.TypeRemise.choices,
        'appliquer_a_choices': Promotion.TypeApplication.choices,
        'defaults': {
            'actif': True,
            'utilisations_max': 1,
            'type_remise': Promotion.TypeRemise.POURCENTAGE,
        }
    })
@login_required
def appliquer_promotion_commande(request, commande_id):
    commande = get_object_or_404(Commande, id=commande_id)
    if request.method == 'POST':
        code_promo = request.POST.get('code_promo', '').strip()

        try:
            promotion = Promotion.objects.get(code_promo=code_promo)

            if not promotion.est_valide():
                messages.error(request, "Cette promotion n'est plus valide.")
            elif RemiseCommande.objects.filter(commande=commande, promotion=promotion).exists():
                messages.error(request, "Cette promotion a déjà été appliquée à cette commande.")
            else:
                total_ht = commande.lignes.aggregate(
                    total=Sum(
                        ExpressionWrapper(
                            F('quantite') * F('produit__prix_vente'),
                            output_field=DecimalField()
                        )
                    )
                )['total'] or 0

                montant_remise = promotion.appliquer_remise(total_ht)

                RemiseCommande.objects.create(
                    commande=commande,
                    promotion=promotion,
                    montant_remise=montant_remise
                )

                promotion.incrementer_utilisation()

                messages.success(request, f"Promotion '{promotion.nom}' appliquée avec succès.")

        except Promotion.DoesNotExist:
            messages.error(request, "Code promo invalide.")
        except ValidationError as e:
            messages.error(request, str(e))
        return redirect('detail_commande', commande_id=commande.id)


    promotions_actives = Promotion.objects.filter(
        actif=True,
        date_debut__lte=timezone.now(),
        date_fin__gte=timezone.now()
    ).exclude(
        utilisations_actuelles__gte=F('utilisations_max')
    )

    return render(request, 'promotions/appliquer.html', {
        'commande': commande,
        'promotions_actives': promotions_actives
    })


@login_required
def _appliquer_promotion_valide(request, commande, promotion):
    with transaction.atomic():
        # Recalculer le total avant remise
        commande.calculer_totaux()
        total_initial = commande.total_ht
        
        # Calculer la remise
        if promotion.type_remise == 'pourcentage':
            montant_remise = total_initial * (promotion.valeur / 100)
        else:
            montant_remise = min(promotion.valeur, total_initial)
        
        # Créer la remise
        RemiseCommande.objects.create(
            commande=commande,
            promotion=promotion,
            montant_remise=montant_remise
        )
        
        # Pas besoin de sauvegarder la commande ici, 
        # car calculer_totaux() est appelé dans save() de RemiseCommande
        
        promotion.incrementer_utilisation()
        messages.success(request, f"Remise de {montant_remise:.2f} appliquée")
    
    return redirect('detail_commande', commande_id=commande.id)



def _appliquer_promotion_produit(request, commande, promotion):
    with transaction.atomic():
        # Vérifier que la promotion a un produit associé
        if not promotion.produit:
            messages.error(request, "Cette promotion nécessite un produit spécifique")
            return redirect('detail_commande', commande_id=commande.id)
            
        # Trouver les lignes de commande concernées
        lignes = commande.lignes_commande.filter(produit=promotion.produit)
        
        if not lignes.exists():
            messages.error(request, f"Aucun produit '{promotion.produit.nom}' dans cette commande")
            return redirect('detail_commande', commande_id=commande.id)
            
        # Appliquer la remise à chaque ligne concernée
        montant_total_remise = Decimal('0.00')
        for ligne in lignes:
            prix_initial = ligne.prix_unitaire * ligne.quantite
            prix_remise = promotion.appliquer_remise(prix_initial)
            montant_remise = prix_initial - prix_remise
            
            ligne.remise = montant_remise
            ligne.prix_total = prix_remise
            ligne.save()
            
            montant_total_remise += montant_remise
        
        # Enregistrer la remise globale
        RemiseCommande.objects.create(
            commande=commande,
            promotion=promotion,
            montant_remise=montant_total_remise
        )
        
        # Mettre à jour le total de la commande
        commande.montant_total = commande.calculer_total()
        commande.save()
        
        # Incrémenter l'utilisation de la promotion
        promotion.incrementer_utilisation()
        
        messages.success(
            request, 
            f"Remise de {montant_total_remise:.2f} FC appliquée sur le produit {promotion.produit.nom}"
        )
    
    return redirect('detail_commande', commande_id=commande.id)


def _appliquer_promotion_categorie(request, commande, promotion):
    with transaction.atomic():
        # Vérifier que la promotion a une catégorie associée
        if not promotion.categorie:
            messages.error(request, "Cette promotion nécessite une catégorie spécifique")
            return redirect('detail_commande', commande_id=commande.id)
            
        # Trouver les lignes de commande concernées
        lignes = commande.lignes_commande.filter(produit__categorie=promotion.categorie)
        
        if not lignes.exists():
            messages.error(request, f"Aucun produit de la catégorie '{promotion.categorie.nom}' dans cette commande")
            return redirect('detail_commande', commande_id=commande.id)
            
        # Appliquer la remise à chaque ligne concernée
        montant_total_remise = Decimal('0.00')
        for ligne in lignes:
            prix_initial = ligne.prix_unitaire * ligne.quantite
            prix_remise = promotion.appliquer_remise(prix_initial)
            montant_remise = prix_initial - prix_remise
            
            ligne.remise = montant_remise
            ligne.prix_total = prix_remise
            ligne.save()
            
            montant_total_remise += montant_remise
        
        # Enregistrer la remise globale
        RemiseCommande.objects.create(
            commande=commande,
            promotion=promotion,
            montant_remise=montant_total_remise
        )
        
        # Mettre à jour le total de la commande
        commande.montant_total = commande.calculer_total()
        commande.save()
        
        # Incrémenter l'utilisation de la promotion
        promotion.incrementer_utilisation()
        
        messages.success(
            request, 
            f"Remise de {montant_total_remise:.2f} FC appliquée sur la catégorie {promotion.categorie.nom}"
        )
    
    return redirect('detail_commande', commande_id=commande.id)

@login_required
@permission_required('promotions.can_manage_promotions', raise_exception=True)
def toggle_promotion(request, promotion_id):
    """Active/désactive une promotion"""
    promotion = get_object_or_404(Promotion, id=promotion_id)
    promotion.actif = not promotion.actif
    promotion.save()
    
    action = "activée" if promotion.actif else "désactivée"
    messages.success(request, f"Promotion {action} avec succès")
    return redirect('liste_promotions')

@login_required
@permission_required('promotions.can_manage_promotions', raise_exception=True)
def supprimer_promotion(request, promotion_id):
    """Supprime une promotion"""
    promotion = get_object_or_404(Promotion, id=promotion_id)
    
    if request.method == 'POST':
        promotion.delete()
        messages.success(request, "Promotion supprimée avec succès")
        return redirect('liste_promotions')
    
    return render(request, 'promotions/supprimer.html', {
        'promotion': promotion
    })
    
    
    
def appliquer_promotion(commande, code_promo):
    try:
        promotion = Promotion.objects.get(code_promo=code_promo)
        
        if not promotion.est_valide():
            return False, "Promotion invalide"
            
        if promotion.appliquer_a == 'commande':
            total_avant = commande.total_avant_remise
            total_apres = promotion.appliquer_remise(total_avant)
            remise = total_avant - total_apres
            
            RemiseCommande.objects.create(
                commande=commande,
                promotion=promotion,
                montant_remise=remise,
                details={
                    'total_avant': str(total_avant),
                    'total_apres': str(total_apres)
                }
            )
            
            promotion.incrementer_utilisation()
            return True, f"Remise de {remise} appliquée"
            
        # Gérer les autres cas (produit/catégorie)
        
    except Promotion.DoesNotExist:
        return False, "Code promo invalide"   
    
    
    


@login_required
def modifier_parametres(request):
    # Récupère ou crée les paramètres en associant l'utilisateur
    param, created = Parametre.objects.get_or_create(
        user=request.user,
        defaults={
            'nom_societe': 'Nom par défaut',
            'adresse': 'Adresse par défaut',
            'telephone': '+0000000000',
            'email': 'contact@example.com',
            'taux_tva': 20.0,
            'devise_principale': 'FC',  # Changé de 'devise' à 'devise_principale'
            'devises_acceptees': ['USD', 'EUR', 'CDF'],  # Ajouté
            'taux_change_auto': False  # Ajouté
        }
    )

    if request.method == 'POST':
        form_data = request.POST
        param.nom_societe = form_data.get('nom_societe', param.nom_societe)
        param.adresse = form_data.get('adresse', param.adresse)
        param.telephone = form_data.get('telephone', param.telephone)
        param.email = form_data.get('email', param.email)
        param.taux_tva = Decimal(form_data.get('taux_tva', param.taux_tva))  # Changé en Decimal
        
        # Gestion des devises
        param.devise_principale = form_data.get('devise_principale', param.devise_principale)  # Changé ici
        
        # Gestion des devises acceptées (convertir la chaîne en liste)
        devises_acceptees = form_data.get('devises_acceptees', '')
        if devises_acceptees:
            param.devises_acceptees = [d.strip() for d in devises_acceptees.split(',')]
        
        param.taux_change_auto = form_data.get('taux_change_auto') == 'on'  # Pour les checkbox
        
        if 'logo' in request.FILES:
            param.logo = request.FILES['logo']

        param.save()
        
        messages.success(request, "Paramètres mis à jour avec succès")
        return redirect('afficher_parametres')

    return render(request, 'parametres/edit_parametres.html', {'param': param})


def afficher_parametres(request):
    parametre, created = Parametre.objects.get_or_create(
        user=request.user,
        defaults={
            'nom_societe': 'Ma Société',
            # ... valeurs par défaut ...
        }
    )
    return render(request, 'parametres/parametres.html', {'parametre': parametre}) 




#IA PREDICATION
from django.shortcuts import render
from STOCK.ml.reapprovisionnement import generer_suggestions_reapprovisionnement

def suggestions_reapprovisionnement(request):
    suggestions = generer_suggestions_reapprovisionnement()
    return render(request, 'stock/suggestions.html', {'suggestions': suggestions})


def historique_suggestions(request):
    produit_id = request.GET.get('produit')
    date = request.GET.get('date')

    suggestions = SuggestionReapprovisionnement.objects.select_related('produit')

    if produit_id:
        suggestions = suggestions.filter(produit_id=produit_id)

    if date:
        suggestions = suggestions.filter(date_suggestion=date)

    paginator = Paginator(suggestions, 20)  # 20 suggestions par page
    page = request.GET.get('page')
    suggestions_page = paginator.get_page(page)

    produits = Produit.objects.all()

    return render(request, 'stock/historique_suggestions.html', {
        'suggestions': suggestions_page,
        'produits': produits,
        'produit_id': produit_id,
        'date': date,
    })

from django.http import HttpResponse

def export_historique_reappro(request):
    # Ton code d'export ici
    return HttpResponse("Export OK")


def FoctionnalitesIA(request):
    return render(request,"IA/Ia.html")


# # STOCK/views.py
# from django.shortcuts import render, redirect
# from django.contrib.auth.decorators import login_required

# from STOCK.ml.chatbot import repondre_au_message  # ✅ Import correct

# @login_required
# def chatbot_view(request):
#     if request.method == "POST":
#         texte = request.POST.get("message")

#         # Crée ou récupère une conversation pour l'utilisateur connecté
#         conversation, _ = Conversation.objects.get_or_create(utilisateur=request.user)

#         # Sauvegarde le message utilisateur
#         Message.objects.create(conversation=conversation, contenu=texte, role="user")

#         # Construit l'historique pour l'envoi à ChatGPT
#         historique = [{"role": msg.role, "content": msg.contenu} for msg in conversation.messages.all()]

#         # Appelle GPT pour générer une réponse
#         reponse = repondre_au_message(texte, historique)


#         # Sauvegarde la réponse de l'assistant
#         Message.objects.create(conversation=conversation, contenu=reponse, role="assistant")

#         return redirect('chatbot')

#     # Affiche la conversation existante si elle existe
#     conversation = Conversation.objects.filter(utilisateur=request.user).first()
#     messages = conversation.messages.all() if conversation else []

#     return render(request, "IA/chatbot.html", {"messages": messages})

from django.http import JsonResponse
from django.views.decorators.http import require_POST
from django.contrib.auth.decorators import login_required
from STOCK.ml.chatbot_engine import *


@csrf_exempt
@login_required
@require_http_methods(["POST"])
def chatbot_query(request):
    try:
        query = request.POST.get('query', '').strip()
        if not query:
            return JsonResponse({'error': 'Requête vide'}, status=400)
        
        engine = ChatbotEngine(request.user)
        response = engine.process_query(query)
        
        # Enregistrer la conversation
        ChatbotConversation.objects.create(
            user=request.user,
            context={'last_query': query, 'last_response': response}
        )
        
        return JsonResponse({'response': response})
    
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)
    
    

@login_required
def chatbot_view(request):
    conversations = ChatbotConversation.objects.filter(user=request.user)
    return render(request, 'IA/chatbot.html', {'conversations': conversations})




import logging
from django.shortcuts import get_object_or_404
from django.http import JsonResponse
from django.utils import timezone
from datetime import timedelta
from django.conf import settings
from django.core.cache import cache
from django.db.models import Avg, Sum
from decimal import Decimal
import json
import pandas as pd
from prophet import Prophet

def forecast_view(request, pk):
    produit = get_object_or_404(Produit, pk=pk)
    
    config = {
        'min_data_points': max(7, getattr(settings, 'FORECAST_MIN_DATA', 7)),
        'forecast_days': getattr(settings, 'FORECAST_DAYS', 30),
        'confidence_interval': getattr(settings, 'FORECAST_CONFIDENCE', 0.8),
    }
    
    try:
        # 1. Vérification des données historiques
        commandes = LigneCommande.objects.filter(
            produit=produit,
            commande__vente_confirmee=True,
            quantite__gt=0
        ).values('commande__date_commande').annotate(
            total_quantite=Sum('quantite')
        ).order_by('commande__date_commande')
        
        data_points = len(commandes)
        
        # 2. Gestion du fallback si données insuffisantes
        if data_points < config['min_data_points']:
            fallback_reason = (
                f"Données insuffisantes (nécessaire: {config['min_data_points']}, "
                f"disponible: {data_points})"
            )
            return handle_forecast_fallback(
                request, 
                produit, 
                config,
                fallback_reason,
                data_points
            )
        
        # 3. Préparation des données pour Prophet
        try:
            df = pd.DataFrame([{
                'ds': cmd['commande__date_commande'].strftime('%Y-%m-%d'),
                'y': float(cmd['total_quantite'])
            } for cmd in commandes])
            
            df['ds'] = pd.to_datetime(df['ds'])
            
            # Vérification des dates uniques
            if df['ds'].nunique() < config['min_data_points']:
                raise ValueError("Pas assez de dates uniques pour l'analyse")
                
        except Exception as e:
            logger.error(f"Erreur préparation données: {str(e)}", exc_info=True)
            return handle_forecast_fallback(
                request,
                produit,
                config,
                f"Erreur préparation données: {str(e)}",
                data_points
            )
        
        # 4. Génération de la prévision avec Prophet
        try:
            model = Prophet(
                interval_width=config['confidence_interval'],
                daily_seasonality=False,
                weekly_seasonality=True,
                yearly_seasonality=False,
                changepoint_prior_scale=0.05  # Réduit la sensibilité aux changements
            )
            
            with warnings.catch_warnings():
                warnings.simplefilter("ignore")
                model.fit(df)
            
            future = model.make_future_dataframe(
                periods=config['forecast_days'],
                freq='D'
            )
            forecast = model.predict(future)
            
            # Filtre seulement les futures prévisions
            last_historical_date = df['ds'].max()
            forecast = forecast[forecast['ds'] > last_historical_date]
            
            # 5. Calcul des métriques de performance
            try:
                from prophet.diagnostics import cross_validation, performance_metrics
                initial_days = max(30, len(df)-7)  # Correction ici
                df_cv = cross_validation(
                    model,
                    initial=f'{initial_days} days',  # Syntaxe corrigée
                    period='7 days',
                    horizon='7 days'
                )
                df_p = performance_metrics(df_cv)
                performance = {
                    'mdape': float(df_p['mdape'].mean()),
                    'mape': float(df_p['mape'].mean()),
                    'rmse': float(df_p['rmse'].mean()),
                    'interval': f"{int(config['confidence_interval']*100)}%"
                }
            except Exception as e:
                logger.warning(f"Erreur calcul performance: {str(e)}")
                performance = {'interval': f"{int(config['confidence_interval']*100)}%"}
            
            # 6. Formatage et enregistrement des résultats
            forecast_data = []
            for _, row in forecast.iterrows():
                forecast_data.append({
                    'date': row['ds'].strftime('%Y-%m-%d'),  # Format cohérent
                    'pred': round(float(row['yhat']), 2),
                    'min': round(float(row['yhat_lower']), 2),
                    'max': round(float(row['yhat_upper']), 2)
                })
                
              
                
                # Enregistrement en base si la date est dans le futur
                if row['ds'].date() > timezone.now().date():
                    HistoriquePrevision.objects.update_or_create(
                        produit=produit,
                        date_prevision=row['ds'].date(),
                        defaults={
                            'quantite_predite': pred,
                            'modele_utilise': 'prophet',
                            'parametres': {
                                'confidence': config['confidence_interval'],
                                'data_points': data_points,
                                'performance': performance
                            },
                            'precision': performance.get('mdape')
                        }
                    )
            
            # 7. Récupération de l'historique actualisé
            historique_previsions = HistoriquePrevision.objects.filter(
                produit=produit
            ).order_by('-date_prevision')[:30]
            
            return render(request, 'IA/forecast.html', {
                'produit': produit,
                'forecast_data': forecast_data,
                'performance': performance,
                'data_points': data_points,
                'historique_previsions': historique_previsions,
                'is_fallback': False
            })
            
        except Exception as e:
            logger.error(f"Erreur Prophet: {str(e)}", exc_info=True)
            return handle_forecast_fallback(
                request,
                produit,
                config,
                f"Erreur modélisation: {str(e)}",
                data_points
            )
            
    except Exception as e:
        logger.error(f"Erreur générale: {str(e)}", exc_info=True)
        return handle_forecast_fallback(
            request,
            produit,
            config,
            f"Erreur système: {str(e)}",
            0
        )
        
        
def handle_forecast_fallback(request, produit, config, reason, data_points):
    try:
        # 1. Calcul des statistiques de base
        stats = LigneCommande.objects.filter(
            produit=produit,
            commande__vente_confirmee=True
        ).aggregate(
            avg=Avg('quantite'),
            total=Sum('quantite'),
            count=Count('id')
        )
        
        # 2. Calcul des ventes quotidiennes moyennes
        if stats['count'] > 3 and stats['avg']:
            daily_sales = float(stats['avg'])
        else:
            # Fallback basé sur le stock si pas assez de données
            daily_sales = max(
                0.1,  # Minimum de 0.1 unité/jour
                float(produit.stock) / 30.0 if produit.stock else 1.0
            )
        
        # 3. Génération des prévisions basiques
        forecast_data = []
        for i in range(1, config['forecast_days'] + 1):
            date = (timezone.now() + timedelta(days=i)).strftime('%Y-%m-%d')
            pred = round(daily_sales, 2)
            min_val = round(max(0.1, daily_sales * 0.7), 2)  # -30% avec minimum de 0.1
            max_val = round(daily_sales * 1.3, 2)            # +30%
            
            forecast_data.append((date, pred, min_val, max_val))
            
            # Enregistrement en base
            if i <= 30:  # Limite à 30 jours pour éviter la surcharge
                HistoriquePrevision.objects.update_or_create(
                    produit=produit,
                    date_prevision=timezone.now().date() + timedelta(days=i),
                    defaults={
                        'quantite_predite': pred,
                        'modele_utilise': 'moyenne',
                        'parametres': {
                            'fallback': True,
                            'avg_sales': daily_sales,
                            'data_points': data_points
                        }
                    }
                )
        
        # 4. Récupération de l'historique
        historique_previsions = HistoriquePrevision.objects.filter(
            produit=produit
        ).order_by('-date_prevision')[:30]
        
        return render(request, 'IA/forecast.html', {
            'produit': produit,
            'forecast_data': forecast_data,
            'performance': {'interval': '70-130%'},
            'data_points': data_points,
            'historique_previsions': historique_previsions,
            'is_fallback': True,
            'fallback_reason': reason,
            'daily_sales': daily_sales
        })
        
    except Exception as e:
        logger.critical(f"Erreur critique dans fallback: {str(e)}", exc_info=True)
        return render(request, 'IA/forecast.html', {
            'produit': produit,
            'error': "Erreur critique dans le système de prévision",
            'show_system_error': True
        })
        

# STOCK/views.py
def product_detail(request, pk):
    produit = get_object_or_404(Produit, pk=pk)
    return render(request, 'STOCK/product_detail.html', {'produit': produit})






#Retours d'achat fournisseurs
def retour_fournisseur(request, achat_id):
    achat = get_object_or_404(Achat, pk=achat_id)

    if request.method == 'POST':
        quantite_retournee = request.POST.get('quantite_retournee')
        motif = request.POST.get('motif')

        # Validation
        try:
            quantite_retournee = int(quantite_retournee)
            if quantite_retournee <= 0 or quantite_retournee > achat.quantite:
                raise ValueError
        except ValueError:
            messages.error(request, "Quantité invalide")
            return redirect('retour_fournisseur', achat_id=achat.id)

        try:
            # La création du retour va automatiquement mettre à jour les quantités
            RetourFournisseur.objects.create(
                achat=achat,
                quantite_retournee=quantite_retournee,
                motif=motif,
                created_by=request.user
            )
            messages.success(request, f"Retour de {quantite_retournee} unités enregistré")
        except Exception as e:
            messages.error(request, f"Erreur: {str(e)}")

        return redirect('retour_fournisseur', achat_id=achat.id)

    # GET - Affichage du formulaire
    context = {
        'achat': achat,
        'quantite_retournee_totale': achat.quantite_retournee,
        'quantite_disponible': achat.quantite,
        'retours_existants': achat.retours.all().order_by('-date_retour'),
        'quantite_effective': achat.quantite_effective,
        'montant_effectif': achat.montant_effectif
    }
    
    return render(request, 'achats/retour_fournisseur.html', context)

def delete(self, *args, **kwargs):
    """Réajuste tout lors de la suppression d'un retour"""
    with transaction.atomic():
        # Réaugmente le stock
        self.achat.produit.stock = F('stock') + self.quantite_retournee
        self.achat.produit.save(update_fields=['stock'])
        super().delete(*args, **kwargs)

@login_required
def supprimer_retour(request, retour_id):
    retour = get_object_or_404(RetourFournisseur, id=retour_id)
    achat_id = retour.achat.id
    
    if request.method == 'POST':
        retour.delete()
        messages.success(request, "Le retour a été supprimé avec succès")
        return redirect('retour_fournisseur', achat_id=achat_id)
    
    return redirect('retour_fournisseur', achat_id=achat_id)




class RetourFournisseurDetailPDF(DetailView):
    model = RetourFournisseur
    template_name = 'achats/retour_fournisseur_pdf.html'
    context_object_name = 'retour'

    def get(self, request, *args, **kwargs):
        retour = self.get_object()
        parametre = Parametre.objects.first()
        
        # Calcul du taux de change si nécessaire
        taux_change = Decimal('1.0')
        if retour.achat.devise != parametre.devise_principale:
            taux = TauxChange.get_taux(retour.achat.devise, parametre.devise_principale)
            taux_change = taux if taux is not None else Decimal('1.0')
        
        context = {
            'retour': retour,
            'parametre': parametre,
            'taux_change': taux_change,
            'request': request  # Ajout crucial de la requête au contexte
        }
        
        # Rendu du template HTML
        html_string = render_to_string(self.template_name, context=context, request=request)  # Passage du request ici aussi
        
        # Création du PDF
        html = HTML(string=html_string, base_url=request.build_absolute_uri())
        result = html.write_pdf()
        
        # Création de la réponse HTTP pour affichage dans le navigateur
        response = HttpResponse(content_type='application/pdf')
        response['Content-Disposition'] = 'inline; filename="retour_fournisseur_{}.pdf"'.format(retour.id)
        response.write(result)
        
        return response





#vue bon de commande



def generer_bon_livraison(request, commande_id):
    commande = get_object_or_404(Commande, id=commande_id)

    if hasattr(commande, 'bon_livraison'):
        messages.warning(request, "Un Bon de Livraison existe déjà pour cette commande.")
        return redirect('liste_bons_livraison')

    parametre = Parametre.objects.first()  # ou filtre si plusieurs
    bon_livraison = BonLivraison.objects.create(
        commande=commande,
        client=commande.client,
        cree_par=request.user,
        parametre=parametre,
    )

    messages.success(request, "Bon de Livraison créé avec succès.")
    return redirect('detail_bon_livraison', bl_id=bon_livraison.id)



def liste_bons_livraison(request):
    bons = BonLivraison.objects.order_by('-date_creation')
    return render(request, 'bons_livraison/liste.html', {'bons': bons})

def detail_bon_livraison(request, bl_id):
    bon = get_object_or_404(BonLivraison, id=bl_id)

    if request.method == 'POST':
        livre = request.POST.get('livre') == 'true'
        date_livraison = request.POST.get('date_livraison') or None

        bon.livre = livre
        bon.date_livraison = date_livraison
        bon.save()

        messages.success(request, "Statut du Bon de Livraison mis à jour.")
        return redirect('liste_bons_livraison')  # ✅ Pas de bl_id ici

    return render(request, 'bons_livraison/detail_bon_livraison.html', {'bon': bon})


def bon_livraison_pdf(request, bl_id):
    bon = get_object_or_404(BonLivraison, id=bl_id)

    # Calcul des totaux
    lignes = bon.commande.lignes.all()
    quantite_totale = sum([ligne.quantite for ligne in lignes])
    montant_total = sum([ligne.quantite * ligne.prix_unitaire for ligne in lignes])

    context = {
        'bon': bon,
        'parametre': bon.parametre,
        'quantite_totale': quantite_totale,
        'montant_total': montant_total
    }

    # Rendu HTML
    template = get_template('bons_livraison/pdf.html')
    html_string = template.render(context)

    # Génération PDF
    html = HTML(string=html_string, base_url=request.build_absolute_uri('/'))
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = f'inline; filename="BL-{bon.id}.pdf"'
    html.write_pdf(response)

    return response


#comptabilites

@login_required
def liste_comptes(request):
    try:
        # Essayez d'obtenir les paramètres de l'entreprise
        entreprise = getattr(request.user, 'parametre', None)
        
        if entreprise is None:
            # Si aucun paramètre n'est associé, utilisez une entreprise par défaut
            entreprise = Parametre.objects.first()  # ou une autre logique
            
        comptes = Compte.objects.filter(entreprise=entreprise)
        
        for compte in comptes:
            compte.solde = compte.solde_actuel()
            
        return render(request, 'tresorerie/comptes/liste.html', {
            'comptes': comptes,
            'entreprise': entreprise
        })
        
    except Exception as e:
        # Journalisez l'erreur pour le débogage
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f"Erreur dans liste_comptes: {str(e)}")
        
        # Retournez une réponse vide ou une page d'erreur
        return render(request, 'tresorerie/comptes/liste.html', {
            'comptes': [],
            'error': "Une erreur s'est produite lors du chargement des comptes."
        })

@login_required
def ajouter_compte(request):
    if request.method == 'POST':
        nom = request.POST.get('nom')
        type_compte = request.POST.get('type_compte')
        solde_initial = request.POST.get('solde_initial', 0)
        
        compte = Compte(
            nom=nom,
            type_compte=type_compte,
            solde_initial=solde_initial,
            entreprise=request.user.parametre
        )
        compte.save()
        return redirect('liste_comptes')
    
    return render(request, 'tresorerie/comptes/ajouter.html')

from django.contrib.auth.decorators import login_required
from django.db.models import Q, F, Sum, Case, When, DecimalField
from django.core.paginator import Paginator
from django.shortcuts import render
from .models import Transaction, TauxChange
from django.utils import timezone


@login_required
def liste_transactions(request):
    entreprise = request.user.parametre
    transactions_list = Transaction.objects.filter(compte__entreprise=entreprise).order_by('-date_transaction')

    devise_affichee = request.session.get('devise_affichee', entreprise.devise_principale)

    devises_disponibles = set()
    devises_taux = TauxChange.objects.values_list('devise_source', 'devise_cible')
    for source, cible in devises_taux:
        devises_disponibles.add(source)
        devises_disponibles.add(cible)

    devises_disponibles.add(entreprise.devise_principale)
    if entreprise.devises_acceptees:
        devises_disponibles.update(entreprise.devises_acceptees)

    if devise_affichee not in devises_disponibles:
        devise_affichee = entreprise.devise_principale
        request.session['devise_affichee'] = devise_affichee

    search_query = request.GET.get('q', '')
    type_filter = request.GET.get('type', '')
    date_filter = request.GET.get('date', '')

    if search_query:
        transactions_list = transactions_list.filter(
            Q(description__icontains=search_query) |
            Q(compte__nom__icontains=search_query) |
            Q(categorie__nom__icontains=search_query)
        )

    if type_filter:
        transactions_list = transactions_list.filter(type_transaction=type_filter)

    if date_filter:
        transactions_list = transactions_list.filter(date_transaction__date=date_filter)

    paginator = Paginator(transactions_list, 25)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)

    solde_total_principal = transactions_list.aggregate(
        total=Sum(
            Case(
                When(type_transaction='ENTREE', then=F('montant')),
                When(type_transaction='SORTIE', then=-F('montant')),
                default=0,
                output_field=DecimalField()
            )
        )
    )['total'] or 0

    transactions_formatted = []
    for transaction in page_obj.object_list:
        try:
            if devise_affichee == entreprise.devise_principale:
                montant_affiche = transaction.montant
            else:
                montant_affiche = entreprise.convertir_vers_devise_affichee(transaction.montant, devise_affichee)

            transactions_formatted.append({
                'obj': transaction,
                'montant_affiche': entreprise.format_devise(montant_affiche, devise_affichee),
                'montant_original': entreprise.format_devise(transaction.montant, entreprise.devise_principale)
                    if devise_affichee != entreprise.devise_principale else None
            })
        except Exception as e:
            print(f"Erreur conversion transaction {transaction.id}: {e}")
            transactions_formatted.append({
                'obj': transaction,
                'montant_affiche': entreprise.format_devise(transaction.montant, entreprise.devise_principale),
                'montant_original': None
            })

    try:
        if devise_affichee == entreprise.devise_principale:
            solde_total = solde_total_principal
        else:
            solde_total = entreprise.convertir_vers_devise_affichee(solde_total_principal, devise_affichee)
    except Exception as e:
        print(f"Erreur conversion solde: {e}")
        solde_total = solde_total_principal
        devise_affichee = entreprise.devise_principale

    solde_total_formatted = entreprise.format_devise(solde_total, devise_affichee)
    solde_total_principal_formatted = (
        entreprise.format_devise(solde_total_principal, entreprise.devise_principale)
        if devise_affichee != entreprise.devise_principale else None
    )

    return render(request, 'tresorerie/transactions/liste.html', {
        'page_obj': page_obj,
        'transactions': transactions_formatted,
        'solde_total_formatted': solde_total_formatted,
        'solde_total_principal_formatted': solde_total_principal_formatted,
        'devise_affichee': devise_affichee,
        'devises_disponibles': sorted(devises_disponibles),
        'devise_principale': entreprise.devise_principale,
        'search_query': search_query,
        'type_filter': type_filter,
        'date_filter': date_filter,
    })



@login_required
def ajouter_transaction(request):
    entreprise = request.user.parametre
    if request.method == 'POST':
        compte_id = request.POST.get('compte')
        type_transaction = request.POST.get('type_transaction')
        categorie_id = request.POST.get('categorie')
        montant = request.POST.get('montant')
        mode_paiement = request.POST.get('mode_paiement')
        description = request.POST.get('description', '')
        
        transaction = Transaction(
            compte_id=compte_id,
            type_transaction=type_transaction,
            categorie_id=categorie_id,
            montant=montant,
            mode_paiement=mode_paiement,
            description=description,
            utilisateur=request.user
        )
        
        if 'piece_jointe' in request.FILES:
            transaction.piece_jointe = request.FILES['piece_jointe']
        
        transaction.save()
        return redirect('liste_transactions')
    
    comptes = Compte.objects.filter(entreprise=entreprise)
    categories = CategorieTransaction.objects.filter(entreprise=entreprise)
    return render(request, 'tresorerie/transactions/ajouter.html', {
        'comptes': comptes,
        'categories': categories
    })


@login_required
def journal_caisse(request):
    entreprise = request.user.parametre
    transactions_list = Transaction.objects.filter(
        compte__entreprise=entreprise
    ).order_by('-date_transaction')
    
    # Filtres
    date_debut = request.GET.get('date_debut', (datetime.now() - timedelta(days=30)).strftime('%Y-%m-%d'))
    date_fin = request.GET.get('date_fin', datetime.now().strftime('%Y-%m-%d'))
    compte_id = request.GET.get('compte')
    devise_affichee = request.GET.get('devise', entreprise.devise_principale)
    
    transactions_list = transactions_list.filter(
        date_transaction__date__gte=date_debut,
        date_transaction__date__lte=date_fin
    )
    
    if compte_id:
        transactions_list = transactions_list.filter(compte_id=compte_id)
    
    # Préparer les transactions avec les montants convertis
    transactions_converted = []
    for transaction in transactions_list:
        montant_converti = entreprise.convertir_vers_devise_affichee(
            transaction.montant, 
            devise_affichee
        )
        transactions_converted.append({
            'original': transaction,
            'montant_converti': montant_converti,
            'devise_affichee': devise_affichee
        })
    
    # Pagination
    paginator = Paginator(transactions_converted, 25)  # Utiliser la liste convertie
    page_number = request.GET.get('page')
    transactions_page = paginator.get_page(page_number)
    
    # Conversion des totaux (reste inchangé)
    total_entrees = transactions_list.filter(type_transaction='ENTREE').aggregate(
        total=Sum('montant')
    )['total'] or 0
    total_entrees = entreprise.convertir_vers_devise_affichee(total_entrees, devise_affichee)
    
    total_sorties = transactions_list.filter(type_transaction='SORTIE').aggregate(
        total=Sum('montant')
    )['total'] or 0
    total_sorties = entreprise.convertir_vers_devise_affichee(total_sorties, devise_affichee)
    
    return render(request, 'tresorerie/rapports/journal_caisse.html', {
        'transactions_page': transactions_page,  # Utiliser la page convertie
        'total_entrees': total_entrees,
        'total_sorties': total_sorties,
        'date_debut': date_debut,
        'date_fin': date_fin,
        'comptes': Compte.objects.filter(entreprise=entreprise),
        'devises_disponibles': entreprise.devises_acceptees if entreprise.devises_acceptees else [entreprise.devise_principale],
        'devise_affichee': devise_affichee,
        'devise_principale': entreprise.devise_principale
    })

@receiver(post_save, sender=Paiement)
def creer_transaction_paiement(sender, instance, created, **kwargs):
    if created:
        compte = Compte.objects.filter(type_compte='ESP').first()  # À adapter selon votre logique
        if compte:
            Transaction.objects.create(
                compte=compte,
                type_transaction='ENTREE',
                montant=instance.montant,
                mode_paiement=instance.methode[:3].upper(),
                description=f"Paiement facture {instance.facture.numero}",
                commande=instance.facture.commande,
                utilisateur=instance.facture.commande.vendeur
            )

from django.db import transaction as db_transaction
from django.db import transaction as db_transaction

from django.db import transaction as db_transaction


@require_POST
@csrf_exempt  # Temporaire pour debug - à retirer en production
def creer_transaction_achat(request, achat_id):
    try:
        with db_transaction.atomic():
            # Vérification de l'authentification
            if not request.user.is_authenticated:
                return JsonResponse({
                    'success': False, 
                    'message': 'Authentification requise'
                }, status=401)

            achat = Achat.objects.select_related('produit', 'transaction').get(id=achat_id)
            
            # Vérification de l'existence d'une transaction
            if achat.transaction:
                return JsonResponse({
                    'success': False, 
                    'message': 'Une transaction existe déjà pour cet achat'
                }, status=400)

            compte = Compte.objects.filter(type_compte='ESP').first()
            if not compte:
                return JsonResponse({
                    'success': False, 
                    'message': 'Aucun compte de caisse disponible'
                }, status=400)

            # Création de la transaction
            transaction = Transaction.objects.create(
                compte=compte,
                type_transaction='SORTIE',
                montant=achat.total_achat,
                montant_original=achat.total_achat,
                mode_paiement='VIR',
                description=f"Achat {achat.produit.nom}",
                utilisateur=request.user,
                devise=achat.devise,
                taux_change=achat.taux_change
            )

            # Liaison de la transaction à l'achat
            achat.transaction = transaction
            achat.save()

            return JsonResponse({
                'success': True,
                'transaction_id': transaction.id,
                'message': 'Transaction créée avec succès'
            })

    except Achat.DoesNotExist:
        return JsonResponse({
            'success': False,
            'message': 'Achat non trouvé'
        }, status=404)
    except Exception as e:
        return JsonResponse({
            'success': False,
            'message': f'Erreur serveur: {str(e)}'
        }, status=500)

@login_required
def voir_transaction_achat(request, achat_id):
    achat = get_object_or_404(Achat, id=achat_id)
    if not achat.transaction:
        raise Http404("Aucune transaction pour cet achat")
    
    return render(request, 'transactions/detail.html', {
        'transaction': achat.transaction,
        'achat': achat
    })       
        
        

@login_required
def detail_compte(request, pk):
    compte = get_object_or_404(Compte, pk=pk, entreprise=request.user.parametre)
    transactions = Transaction.objects.filter(compte=compte).order_by('-date_transaction')[:10]
    return render(request, 'tresorerie/comptes/detail.html', {
        'compte': compte,
        'transactions': transactions,
        'solde_actuel': compte.solde_actuel()
    })






@login_required
def detail_transaction(request, pk):
    transaction = get_object_or_404(Transaction, pk=pk, compte__entreprise=request.user.parametre)
    return render(request, 'tresorerie/transactions/detail.html', {'transaction': transaction})

@login_required
def liste_categories(request):
    categories = CategorieTransaction.objects.filter(entreprise=request.user.parametre)
    return render(request, 'tresorerie/categories/liste.html', {'categories': categories})

@login_required
def ajouter_categorie(request):
    if request.method == 'POST':
        nom = request.POST.get('nom')
        type_categorie = request.POST.get('type_categorie')
        description = request.POST.get('description', '')
        
        categorie = CategorieTransaction(
            nom=nom,
            type_categorie=type_categorie,
            description=description,
            entreprise=request.user.parametre
        )
        categorie.save()
        return redirect('liste_categories')
    
    return render(request, 'tresorerie/categories/ajouter.html')

@login_required
def balance_comptes(request):
    entreprise = request.user.parametre
    date_debut = request.GET.get('date_debut', (datetime.now() - timedelta(days=30)).strftime('%Y-%m-%d'))
    date_fin = request.GET.get('date_fin', datetime.now().strftime('%Y-%m-%d'))
    
    comptes = Compte.objects.filter(entreprise=entreprise)
    balance = []
    
    for compte in comptes:
        transactions = Transaction.objects.filter(
            compte=compte,
            date_transaction__date__range=[date_debut, date_fin]
        )
        
        entree = transactions.filter(type_transaction='ENTREE').aggregate(total=Sum('montant'))['total'] or 0
        sortie = transactions.filter(type_transaction='SORTIE').aggregate(total=Sum('montant'))['total'] or 0
        
        balance.append({
            'compte': compte,
            'entree': entree,
            'sortie': sortie,
            'solde': entree - sortie
        })
    
    return render(request, 'tresorerie/rapports/balance.html', {
        'balance': balance,
        'date_debut': date_debut,
        'date_fin': date_fin
    })

@login_required
def bilan_simplifie(request):
    entreprise = request.user.parametre
    date_fin = request.GET.get('date_fin', datetime.now().strftime('%Y-%m-%d'))
    
    # Actifs (comptes avec solde positif)
    actifs = Compte.objects.filter(
        entreprise=entreprise
    ).annotate(
        solde=Sum(
            Case(
                When(transaction__type_transaction='ENTREE', then='transaction__montant'),
                When(transaction__type_transaction='SORTIE', then=-F('transaction__montant')),
                default=0,
                output_field=DecimalField()
            )
        ) + F('solde_initial')
    ).filter(solde__gt=0)
    
    # Passifs (comptes avec solde négatif)
    passifs = Compte.objects.filter(
        entreprise=entreprise
    ).annotate(
        solde=Sum(
            Case(
                When(transaction__type_transaction='ENTREE', then='transaction__montant'),
                When(transaction__type_transaction='SORTIE', then=-F('transaction__montant')),
                default=0,
                output_field=DecimalField()
            )
        ) + F('solde_initial')
    ).filter(solde__lt=0).annotate(
        solde_abs=Abs(F('solde'))
    )
    
    total_actifs = actifs.aggregate(total=Sum('solde'))['total'] or 0
    total_passifs = - (passifs.aggregate(total=Sum('solde'))['total'] or 0)
    
    return render(request, 'tresorerie/rapports/bilan.html', {
        'actifs': actifs,
        'passifs': passifs,
        'total_actifs': total_actifs,
        'total_passifs': total_passifs,
        'date_fin': date_fin
    })
    


import openpyxl
from django.http import HttpResponse
from django.utils import timezone
from datetime import datetime
from django.contrib.auth.decorators import login_required
from openpyxl.styles import Font, PatternFill

@login_required
def export_journal_excel(request):
    entreprise = request.user.parametre
    
    # Récupérer les mêmes filtres que dans journal_caisse
    date_debut = request.GET.get('date_debut', (timezone.now() - timezone.timedelta(days=30)).strftime('%Y-%m-%d'))
    date_fin = request.GET.get('date_fin', timezone.now().strftime('%Y-%m-%d'))
    compte_id = request.GET.get('compte')
    
    transactions = Transaction.objects.filter(
        compte__entreprise=entreprise,
        date_transaction__date__gte=date_debut,
        date_transaction__date__lte=date_fin
    ).order_by('-date_transaction')
    
    if compte_id:
        transactions = transactions.filter(compte_id=compte_id)
    
    # Créer un nouveau classeur Excel
    wb = openpyxl.Workbook()
    ws = wb.active
    ws.title = "Journal de Caisse"
    
    # En-têtes
    headers = [
        "Date", 
        "Compte", 
        "Type", 
        "Catégorie", 
        "Description", 
        "Mode Paiement", 
        "Montant"
    ]
    ws.append(headers)
    
    # Données
    for t in transactions:
        ws.append([
            t.date_transaction.strftime("%d/%m/%Y %H:%M"),
            t.compte.nom,
            t.get_type_transaction_display(),
            t.categorie.nom if t.categorie else "-",
            t.description,
            t.get_mode_paiement_display(),
            t.montant
        ])
    
    # Style des en-têtes
    for cell in ws[1]:
        cell.font = Font(bold=True)
        cell.fill = PatternFill(start_color="DDDDDD", end_color="DDDDDD", fill_type="solid")
    
    # Ajuster la largeur des colonnes
    for column in ws.columns:
        max_length = 0
        column_letter = column[0].column_letter
        for cell in column:
            try:
                if len(str(cell.value)) > max_length:
                    max_length = len(cell.value)
            except:
                pass
        adjusted_width = (max_length + 2) * 1.2
        ws.column_dimensions[column_letter].width = adjusted_width
    
    # Format de la date
    for row in ws.iter_rows(min_row=2):
        row[0].number_format = 'DD/MM/YYYY HH:MM'
    
    # Format monétaire
    for row in ws.iter_rows(min_row=2):
        row[6].number_format = '#,##0.00'
    
    # Ajouter les totaux
    ws.append([])  # Ligne vide
    
    # Calcul des totaux
    total_entrees = sum(t.montant for t in transactions if t.type_transaction == 'ENTREE')
    total_sorties = sum(t.montant for t in transactions if t.type_transaction == 'SORTIE')
    solde_net = total_entrees - total_sorties
    
    # Ajout des totaux
    ws.append(["", "", "", "", "", "Total Entrées:", total_entrees])
    ws.append(["", "", "", "", "", "Total Sorties:", total_sorties])
    ws.append(["", "", "", "", "", "Solde Net:", solde_net])
    
    # Style des totaux
    for row in ws.iter_rows(min_row=ws.max_row-2, max_row=ws.max_row):
        for cell in row[5:]:
            cell.font = Font(bold=True)
        row[-1].number_format = '#,##0.00'
    
    # Préparer la réponse
    response = HttpResponse(
        content_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    )
    filename = f"journal_caisse_{datetime.now().strftime('%Y%m%d_%H%M%S')}.xlsx"
    response['Content-Disposition'] = f'attachment; filename={filename}'
    
    wb.save(response)
    return responses





from django.shortcuts import render
from django.db.models import Sum, Count
from datetime import datetime, timedelta
from .models import Transaction, Compte, CategorieTransaction

def dashboard_tresorerie(request):
    # Paramètre de période
    jours = int(request.GET.get('jours', 30))
    date_debut = datetime.now() - timedelta(days=jours)
    
    # 1. Flux de trésorerie (entrées/sorties par jour)
    transactions = Transaction.objects.filter(
        date_transaction__gte=date_debut
    ).values('date_transaction__date').annotate(
        entieres=Sum('montant', filter=Q(type_transaction='ENTREE')),
        sorties=Sum('montant', filter=Q(type_transaction='SORTIE'))
    ).order_by('date_transaction__date')
    
    dates_flux = []
    entieres_flux = []
    sorties_flux = []
    
    for t in transactions:
        dates_flux.append(t['date_transaction__date'].strftime('%d/%m'))
        entieres_flux.append(float(t['entieres'] or 0))
        sorties_flux.append(float(t['sorties'] or 0))
    
    # 2. Répartition des dépenses par catégorie
    categories_depenses = CategorieTransaction.objects.filter(
        type_categorie='DEP'
    ).annotate(
        total=Sum('transaction__montant', filter=Q(
            transaction__type_transaction='SORTIE',
            transaction__date_transaction__gte=date_debut
        ))
    ).exclude(total=None).order_by('-total')
    
    labels_depenses = []
    data_depenses = []
    colors_depenses = []
    color_palette = [
        '#e74a3b', '#f6c23e', '#36b9cc', '#858796', 
        '#1cc88a', '#4e73df', '#5a5c69', '#fd7e14'
    ]
    
    for i, categorie in enumerate(categories_depenses):
        labels_depenses.append(categorie.nom)
        data_depenses.append(float(categorie.total))
        colors_depenses.append(color_palette[i % len(color_palette)])
    
    # 3. Soldes des comptes
    comptes = Compte.objects.all().annotate(
        solde=Sum(
            Case(
                When(transaction__type_transaction='ENTREE', then='transaction__montant'),
                When(transaction__type_transaction='SORTIE', then=-F('transaction__montant')),
                default=0,
                output_field=DecimalField()
            )
        ) + F('solde_initial')
    ).order_by('-solde')
    
    labels_comptes = [c.nom for c in comptes]
    data_comptes = [float(c.solde) for c in comptes]
    
    # 4. Répartition des moyens de paiement
    modes_paiement = Transaction.objects.filter(
        date_transaction__gte=date_debut
    ).values('mode_paiement').annotate(
        total=Sum('montant'),
        count=Count('id')
    ).order_by('-total')
    
    labels_paiements = []
    data_paiements = []
    colors_paiements = []
    mode_colors = {
        'ESP': '#4e73df',  # Espèces - bleu
        'MM': '#1cc88a',   # Mobile Money - vert
        'CHQ': '#f6c23e',  # Chèque - jaune
        'VIR': '#36b9cc',  # Virement - cyan
        'CRD': '#e74a3b'   # Carte - rouge
    }
    
    for mode in modes_paiement:
        labels_paiements.append(dict(Transaction.MODE_PAIEMENT).get(mode['mode_paiement']))
        data_paiements.append(float(mode['total']))
        colors_paiements.append(mode_colors.get(mode['mode_paiement'], '#858796'))
    
    return render(request, 'tresorerie/dashboard.html', {
        'dates_flux': dates_flux,
        'entieres_flux': entieres_flux,
        'sorties_flux': sorties_flux,
        'categories_depenses': zip(categories_depenses, colors_depenses),
        'labels_depenses': labels_depenses,
        'data_depenses': data_depenses,
        'colors_depenses': colors_depenses,
        'labels_comptes': labels_comptes,
        'data_comptes': data_comptes,
        'labels_paiements': labels_paiements,
        'data_paiements': data_paiements,
        'colors_paiements': colors_paiements,
        'modes_paiement': [{'mode': m[1], 'color': mode_colors.get(m[0], '#858796')} 
                          for m in Transaction.MODE_PAIEMENT]
    })
    
    
def liste_paiements(request):
    paiements = Paiement.objects.all().order_by('-date').select_related('facture', 'facture__commande')
    for paiement in paiements:
        paiement.transaction = Transaction.objects.filter(
            commande=paiement.facture.commande,
            montant=paiement.montant
        ).first()
    return render(request, 'tresorerie/paiements/liste.html', {'paiements': paiements})

def detail_paiement(request, pk):
    paiement = get_object_or_404(Paiement, pk=pk)
    transaction = paiement.transaction_set.first()
    return render(request, 'tresorerie/paiements/detail.html', {
        'paiement': paiement,
        'transaction': transaction
    })
from django.shortcuts import render, redirect, get_object_or_404
from STOCK.forms import AchatForm
from STOCK.models import Achat, Parametre, TauxChange, Compte, CategorieTransaction, Transaction


# views.py
from django.shortcuts import render
from .models import Achat, Parametre, TauxChange
from decimal import Decimal, InvalidOperation

def get_devise_affichee():
    """Retourne la devise principale depuis les paramètres."""
    parametre = Parametre.objects.first()
    return parametre.devise_principale if parametre else 'CDF'


def get_taux(source, cible):
    """Retourne le taux de conversion entre deux devises."""
    if source == cible:
        return Decimal('1.0')

    try:
        # Taux direct
        taux = (
            TauxChange.objects
            .filter(devise_source=source, devise_cible=cible)
            .order_by('-date_mise_a_jour')
            .first()
        )
        if taux:
            return taux.taux

        # Taux inverse si le direct n'existe pas
        taux_inverse = (
            TauxChange.objects
            .filter(devise_source=cible, devise_cible=source)
            .order_by('-date_mise_a_jour')
            .first()
        )
        if taux_inverse and taux_inverse.taux != 0:
            return Decimal('1.0') / taux_inverse.taux

    except (TauxChange.DoesNotExist, InvalidOperation):
        pass

    return Decimal('1.0')  # Valeur de secours


@login_required
def liste_achats(request):
    achats = Achat.objects.all()

    # Récupérer les paramètres utilisateur
    try:
        parametres = Parametre.objects.get(user=request.user)
        devise_principale = parametres.devise_principale
        devises_disponibles = parametres.devises_acceptees
    except Parametre.DoesNotExist:
        devise_principale = "USD"
        devises_disponibles = ["USD", "CDF", "EUR"]

    # Gérer la devise affichée
    devise_affichee = request.session.get('devise_affichee', devise_principale)
    if devise_affichee not in devises_disponibles:
        devise_affichee = devise_principale

    total_general = Decimal('0.00')

    for achat in achats:
        devise_source = achat.devise
        montant = achat.total_achat

        try:
            if devise_source == devise_affichee:
                achat.montant_converti = montant
                achat.taux_applique = Decimal('1.0')
            else:
                achat.montant_converti = TauxChange.convertir(
                    montant, 
                    devise_source, 
                    devise_affichee
                )
                achat.taux_applique = TauxChange.get_taux(devise_source, devise_affichee)
                
            total_general += achat.montant_converti
        except Exception as e:
            print(f"Erreur conversion: {e}")
            achat.montant_converti = Decimal('0.00')
            achat.taux_applique = None

    context = {
        "achats": achats,
        "devise_affichee": devise_affichee,
        "devises_disponibles": devises_disponibles,
        "total_general": total_general,
        "devise_principale": devise_principale,
        "devise_symbols": {"USD": "$", "CDF": "FC", "EUR": "€"},
    }

    return render(request, "tresorerie/achats/liste.html", context)
# Dans vos views.py
from django.views.decorators.http import require_POST
from django.http import JsonResponse

@require_POST
@login_required
def set_devise(request):
    devise = request.POST.get('devise')
    print(f"Devise reçue: {devise}")  # Debug
    try:
        parametres = Parametre.objects.get(user=request.user)
        if devise in parametres.devises_acceptees:
            request.session['devise_affichee'] = devise
            print("Devise enregistrée en session")  # Debug
            return JsonResponse({'status': 'success'})
    except Parametre.DoesNotExist:
        if devise in ["USD", "CDF"]:  # Simplifié
            request.session['devise_affichee'] = devise
            return JsonResponse({'status': 'success'})
    
    return JsonResponse({'status': 'error', 'message': 'Devise non autorisée'}, status=400)





@login_required
def obtenir_taux_change(request):
    devise_cible = request.GET.get('devise')
    parametres = Parametre.objects.first()

    if not parametres or not devise_cible:
        return JsonResponse({'status': 'error', 'message': 'Paramètres manquants'})

    try:
        devise_source = parametres.devise_principale
        taux = TauxChange.get_taux(devise_source, devise_cible)

        if taux is None:
            return JsonResponse({'status': 'error', 'message': f"Aucun taux de change disponible pour {devise_source} vers {devise_cible}"})

        return JsonResponse({'status': 'success', 'taux': str(taux)})
    except Exception as e:
        return JsonResponse({'status': 'error', 'message': str(e)})






def detail_achat(request, pk):
    achat = get_object_or_404(Achat, pk=pk)
    return render(request, 'tresorerie/achats/detail.html', {'achat': achat})


def ajouter_achat(request):
    if request.method == 'POST':
        form = AchatForm(request.POST)
        if form.is_valid():
            achat = form.save(commit=False)
            achat.created_by = request.user

            # Récupérer les paramètres globaux
            param = Parametre.objects.first()
            devise_principale = param.devise_principale if param else 'FC'

            achat.devise = devise_principale
            achat.montant_original = achat.prix_unitaire  # Pas besoin de conversion
            achat.taux_change = 1.0

            achat.save()

            # Créer la transaction automatiquement (SANS lien avec achat)
            try:
                compte = Compte.objects.first()
                categorie = CategorieTransaction.objects.get(nom__iexact='Achats')

                Transaction.objects.create(
                    compte=compte,
                    montant=achat.total_achat_devise_principale,
                    type_transaction='SORTIE',
                    categorie=categorie,
                    mode_paiement='ESP',
                    description=f"Achat automatique : {achat.quantite} x {achat.produit.nom}"
                )
            except Exception as e:
                print(f"Erreur lors de la création de la transaction : {e}")

            return redirect('liste_achats')
    else:
        form = AchatForm()

    return render(request, 'tresorerie/achats/ajouter.html', {
        'form': form,
        'devise': request.user.parametre.devise_principale if hasattr(request.user, 'parametre') else 'FC'
    })

    
    
    
    
    
    #Module tresorerie
    
def Tresorerie(request):
    return render(request,"tresorerie/module_tresorerie.html")

import requests
class MettreAJourTauxChange(View):
    def get(self, request):
        parametres = Parametre.objects.first()
        if not parametres or not parametres.devises_acceptees:
            return JsonResponse({'status': 'error', 'message': 'Configuration manquante'})
        
        try:
            # Exemple avec une API fictive - à remplacer par une vraie API
            response = requests.get(
                f"https://api.exemple.com/taux?devises={','.join(parametres.devises_acceptees)}"
            )
            data = response.json()
            
            for devise in parametres.devises_acceptees:
                if devise == parametres.devise_principale:
                    continue
                
                taux, created = TauxChange.objects.update_or_create(
                    devise_source=devise,
                    devise_cible=parametres.devise_principale,
                    defaults={
                        'taux': Decimal(str(data['rates'][devise])),
                        'est_manuel': False
                    }
                )
            
            return JsonResponse({
                'status': 'success',
                'message': f'Taux mis à jour le {datetime.now().strftime("%Y-%m-%d %H:%M")}'
            })
        except Exception as e:
            return JsonResponse({'status': 'error', 'message': str(e)})
        
        
        
        
        
from django.shortcuts import render, redirect
from django.contrib import messages
from django.views.generic import ListView, CreateView, UpdateView
from django.urls import reverse_lazy
from .models import Parametre, TauxChange
from .forms import DeviseForm, TauxChangeForm
import requests
from decimal import Decimal
from django.http import JsonResponse

class ListeDevisesView(ListView):
    model = TauxChange
    template_name = 'tresorerie/devises/liste.html'
    context_object_name = 'taux_list'
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['parametres'] = Parametre.objects.first()
        return context

def ajouter_devise(request):
    parametres = Parametre.objects.first()
    if request.method == 'POST':
        form = DeviseForm(request.POST, instance=parametres)
        if form.is_valid():
            form.save()
            messages.success(request, "Devises mises à jour avec succès")
            return redirect('liste_devises')
    else:
        form = DeviseForm(instance=parametres)
    
    return render(request, 'tresorerie/devises/ajouter_devise.html', {'form': form})

from django.urls import reverse_lazy

def ajouter_taux(request):
    # Récupérer les devises disponibles
    parametres = Parametre.objects.first()
    devises_disponibles = []
    if parametres:
        devises_disponibles = sorted(set(
            parametres.devises_acceptees + [parametres.devise_principale]
        ))

    if request.method == 'POST':
        # Récupérer les données du formulaire
        devise_source = request.POST.get('devise_source')
        devise_cible = request.POST.get('devise_cible')
        taux_str = request.POST.get('taux')

        # Validation manuelle
        errors = []
        if not devise_source or not devise_cible or not taux_str:
            errors.append("Tous les champs sont obligatoires")
        
        if devise_source == devise_cible:
            errors.append("Les devises source et cible doivent être différentes")

        try:
            taux = Decimal(taux_str)
            if taux <= 0:
                errors.append("Le taux doit être positif")
        except:
            errors.append("Le taux doit être un nombre valide")

        # Vérifier si le taux existe déjà
        if TauxChange.objects.filter(
            devise_source=devise_source,
            devise_cible=devise_cible
        ).exists():
            errors.append("Ce taux de change existe déjà")

        if not errors:
            # Créer et sauvegarder le nouveau taux
            TauxChange.objects.create(
                devise_source=devise_source,
                devise_cible=devise_cible,
                taux=taux,
                est_manuel=True
            )
            messages.success(
                request,
                f"Taux de change {devise_source}/{devise_cible} ajouté avec succès"
            )
            return redirect(reverse_lazy('liste_devises'))

        # Si erreurs, les afficher
        for error in errors:
            messages.error(request, error)

    context = {
        'devises_disponibles': devises_disponibles,
        'page_title': "Ajouter un Taux de Change",
        'active_menu': 'tresorerie'
    }
    return render(request, 'tresorerie/devises/ajouter_taux.html', context)


from django.core.paginator import Paginator

def historique_taux(request):
    """
    Affiche l'historique des modifications des taux de change
    avec pagination et filtres possibles.
    """
    # Récupérer les paramètres de filtrage
    devise_source = request.GET.get('devise_source')
    devise_cible = request.GET.get('devise_cible')
    
    # Construire la requête de base
    queryset = TauxChange.objects.all().order_by('-date_mise_a_jour')
    
    # Appliquer les filtres
    if devise_source:
        queryset = queryset.filter(devise_source=devise_source)
    if devise_cible:
        queryset = queryset.filter(devise_cible=devise_cible)
    
    # Pagination (10 éléments par page)
    paginator = Paginator(queryset, 10)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    # Récupérer les devises disponibles pour les filtres
    parametres = Parametre.objects.first()
    devises_disponibles = []
    if parametres:
        devises_disponibles = parametres.devises_acceptees + [parametres.devise_principale]
    
    context = {
        'page_obj': page_obj,
        'devises_disponibles': sorted(set(devises_disponibles)),
        'selected_devise_source': devise_source,
        'selected_devise_cible': devise_cible,
        'page_title': "Historique des Taux de Change",
        'active_menu': 'tresorerie'
    }
    
    return render(request, 'tresorerie/devises/historique_taux.html', context)
    
    
    
    


from django.shortcuts import render
from django.http import JsonResponse
from django.views.decorators.http import require_http_methods
from django.core.cache import cache
from .models import Parametre, TauxChange
import requests
import json
from decimal import Decimal

def get_available_currencies(parametres):
    """
    Récupère les devises disponibles depuis l'API ou le cache
    """
    if not parametres.openexchangerates_app_id:
        return {}

    cache_key = f'oer_currencies_{parametres.user.id}'
    currencies = cache.get(cache_key)
    
    if not currencies:
        try:
            response = requests.get(
                'https://openexchangerates.org/api/currencies.json',
                params={'app_id': parametres.openexchangerates_app_id},
                timeout=5
            )
            currencies = response.json()
            cache.set(cache_key, currencies, timeout=86400)  # Cache 24h
        except Exception:
            currencies = {}

    return currencies


#modif taux
def modifier_taux(request, taux_id):
    taux = get_object_or_404(TauxChange, id=taux_id)
    parametres = Parametre.objects.first()  # Récupération des paramètres
    
    if request.method == 'POST':
        # Récupération des données du formulaire
        devise_source = request.POST.get('devise_source')
        devise_cible = request.POST.get('devise_cible')
        taux_value = request.POST.get('taux')
        
        # Validation basique
        errors = []
        if not devise_source or not devise_cible or not taux_value:
            errors.append("Tous les champs sont obligatoires")
        
        if devise_source == devise_cible:
            errors.append("Les devises source et cible doivent être différentes")

        try:
            taux_decimal = Decimal(taux_value)
            if taux_decimal <= 0:
                errors.append("Le taux doit être positif")
        except:
            errors.append("Le taux doit être un nombre valide")

        if not errors:
            try:
                taux.devise_source = devise_source
                taux.devise_cible = devise_cible
                taux.taux = taux_decimal
                taux.save()
                messages.success(request, "Taux mis à jour avec succès")
                return redirect('liste_devises')
            except Exception as e:
                messages.error(request, f"Erreur: {str(e)}")
        else:
            for error in errors:
                messages.error(request, error)
    
    # Préparer les devises disponibles
    devises_disponibles = []
    if parametres:
        devises_disponibles = sorted(set(
            parametres.devises_acceptees + [parametres.devise_principale]
        ))
    
    context = {
        'taux': taux,
        'devises_disponibles': devises_disponibles,
        'page_title': "Modifier Taux de Change",
        'parametres': parametres  # Ajout des paramètres au contexte
    }
    return render(request, 'tresorerie/devises/modifier_taux.html', context)


def supprimer_taux(request, taux_id):
    taux = get_object_or_404(TauxChange, id=taux_id)
    
    if request.method == 'POST':
        taux.delete()
        messages.success(request, "Taux supprimé avec succès")
        return redirect('liste_devises')
    
    context = {
        'taux': taux,
        'page_title': "Confirmer la suppression"
    }
    return render(request, 'tresorerie/devises/confirmer_suppression.html', context)


def obtenir_devises_disponibles(request):
    if request.method == 'GET':
        try:
            parametres = Parametre.objects.first()
            if not parametres or not parametres.openexchangerates_app_id:
                return JsonResponse({'status': 'error', 'message': 'Configuration manquante'})
            
            response = requests.get(
                f"https://openexchangerates.org/api/currencies.json",
                params={'app_id': parametres.openexchangerates_app_id}
            )
            
            if response.status_code == 200:
                return JsonResponse({
                    'status': 'success',
                    'devises': response.json()
                })
            else:
                return JsonResponse({
                    'status': 'error',
                    'message': 'Erreur lors de la récupération des devises'
                })
        except Exception as e:
            return JsonResponse({'status': 'error', 'message': str(e)})
    
    return JsonResponse({'status': 'error', 'message': 'Méthode non autorisée'})



@csrf_exempt  # nécessaire si tu n'utilises pas {% csrf_token %}, mais tu l'utilises donc à retirer si non requis
def changer_devise(request):
    if request.method == 'POST':
        try:
            data = json.loads(request.body)
            nouvelle_devise = data.get('devise')

            if nouvelle_devise in ['USD', 'EUR', 'CDF']:  # sécurise les entrées
                parametre = Parametre.objects.first()
                if parametre:
                    parametre.devise_principale = nouvelle_devise
                    parametre.save()
                else:
                    Parametre.objects.create(devise_principale=nouvelle_devise)

                return JsonResponse({'success': True})
            else:
                return JsonResponse({'success': False, 'message': 'Devise invalide'})

        except Exception as e:
            return JsonResponse({'success': False, 'message': str(e)})

    return JsonResponse({'success': False, 'message': 'Méthode non autorisée'})



def liste_devises(request):
    try:
        parametres, _ = Parametre.objects.get_or_create(
            user=request.user,
            defaults={
                "nom_societe": "Ma Société",
                "devise_principale": "USD",
                "devises_acceptees": ["USD", "EUR", "CDF"],
                "openexchangerates_app_id": "",
                "openexchangerates_base_devise": "USD"
            }
        )
    except Exception as e:
        messages.error(request, str(e))
        return redirect('home')

    taux_list = TauxChange.objects.all()

    context = {
        'parametres': parametres,
        'taux_list': taux_list,
        'page_title': "Gestion des Devises",
        'devises_disponibles': json.dumps(get_available_currencies(parametres))
    }

    if request.headers.get('x-requested-with') == 'XMLHttpRequest':
        return render(request, 'tresorerie/devises/partials/rates_table.html', context)

    return render(request, 'tresorerie/devises/liste_devises.html', context)


from django.views.decorators.http import require_http_methods
from django.http import JsonResponse
from django.utils import timezone
from decimal import Decimal
import requests
from .models import Parametre, TauxChange

@require_http_methods(["POST"])
def maj_taux_auto(request):
    if not request.user.is_authenticated:
        return JsonResponse({'status': 'error', 'message': 'Non authentifié'}, status=403)

    try:
        parametres = Parametre.objects.get(user=request.user)
        if not parametres.openexchangerates_app_id:
            return JsonResponse({'status': 'error', 'message': 'Clé API non définie'}, status=400)

        response = requests.get(
            'https://openexchangerates.org/api/latest.json',
            params={
                'app_id': parametres.openexchangerates_app_id,
                'base': parametres.openexchangerates_base_devise,
                'symbols': ','.join(set(parametres.devises_acceptees + [parametres.devise_principale]))
            },
            timeout=10
        )

        if response.status_code != 200:
            return JsonResponse({'status': 'error', 'message': 'Erreur API'}, status=400)

        data = response.json()

        # Si on veut juste tester l’API sans modifier la base
        if request.POST.get("test_only"):
            return JsonResponse({'status': 'success', 'message': 'Connexion API réussie'})

        base_rate = data['rates'].get(parametres.devise_principale, 1)
        updated_count = 0

        for devise, taux in data['rates'].items():
            if devise == parametres.devise_principale:
                continue

            taux_converti = Decimal(str(base_rate / taux)) \
                if parametres.openexchangerates_base_devise != parametres.devise_principale \
                else Decimal(str(taux))

            TauxChange.objects.update_or_create(
                devise_source=devise,
                devise_cible=parametres.devise_principale,
                defaults={'taux': taux_converti, 'est_manuel': False}
            )
            updated_count += 1

        return JsonResponse({
            'status': 'success',
            'message': f"{updated_count} taux mis à jour",
            'last_update': timezone.now().isoformat()
        })

    except requests.Timeout:
        return JsonResponse({'status': 'error', 'message': 'Délai API dépassé'}, status=408)
    except Exception as e:
        return JsonResponse({'status': 'error', 'message': str(e)}, status=500)

def modifier_taux(request, taux_id):
    taux = get_object_or_404(TauxChange, id=taux_id)
    parametres = Parametre.objects.first()

    if request.method == 'POST':
        devise_source = request.POST.get('devise_source')
        devise_cible = request.POST.get('devise_cible')
        taux_value = request.POST.get('taux')

        errors = []
        if not devise_source or not devise_cible or not taux_value:
            errors.append("Tous les champs sont obligatoires")
        if devise_source == devise_cible:
            errors.append("Les devises doivent être différentes")

        try:
            taux_decimal = Decimal(taux_value)
            if taux_decimal <= 0:
                errors.append("Le taux doit être positif")
        except:
            errors.append("Taux invalide")

        if not errors:
            taux.devise_source = devise_source
            taux.devise_cible = devise_cible
            taux.taux = taux_decimal
            taux.est_manuel = True
            taux.save()
            messages.success(request, "Taux mis à jour avec succès")
            return redirect('liste_devises')
        else:
            for err in errors:
                messages.error(request, err)

    context = {
        'taux': taux,
        'devises_disponibles': sorted(set(parametres.devises_acceptees + [parametres.devise_principale])),
        'page_title': "Modifier Taux de Change"
    }
    return render(request, 'tresorerie/devises/modifier_taux.html', context)

def supprimer_taux(request, taux_id):
    taux = get_object_or_404(TauxChange, id=taux_id)
    if request.method == 'POST':
        taux.delete()
        messages.success(request, "Taux supprimé avec succès")
        return redirect('liste_devises')
    return render(request, 'tresorerie/devises/confirmer_suppression.html', {'taux': taux})




#reception de stocks
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib.auth.decorators import login_required
from django.contrib import messages
from django.forms import formset_factory
from django.http import JsonResponse
from decimal import Decimal
from .models import Reception, LigneReception, Parametre, TauxChange
from .forms import ReceptionForm, LigneReceptionForm

@login_required
def liste_receptions(request):
    receptions = Reception.objects.all().order_by('-date_reception')
    
    # Filtres
    status = request.GET.get('status')
    if status:
        receptions = receptions.filter(status=status)
    
    fournisseur = request.GET.get('fournisseur')
    if fournisseur:
        receptions = receptions.filter(fournisseur__id=fournisseur)
    
    date_debut = request.GET.get('date_debut')
    date_fin = request.GET.get('date_fin')
    if date_debut and date_fin:
        receptions = receptions.filter(date_reception__range=[date_debut, date_fin])
    
    return render(request, 'stock/liste_receptions.html', {
        'receptions': receptions,
        'status_choices': Reception.STATUS_CHOICES,
    })

@login_required
def creer_reception(request):
    LigneFormSet = formset_factory(LigneReceptionForm, extra=1)
    parametres = Parametre.objects.first()

    if request.method == 'POST':
        form = ReceptionForm(request.POST)
        formset = LigneFormSet(request.POST)
        
        if form.is_valid() and formset.is_valid():
            reception = form.save(commit=False)
            reception.created_by = request.user
            
            devise = form.cleaned_data.get('devise') or parametres.devise_principale
            reception.devise = devise
            
            # Correction taux change
            if devise != parametres.devise_principale:
                taux = TauxChange.get_taux(devise, parametres.devise_principale)
                reception.taux_change = taux or 1.0  # Si pas de taux -> 1.0
            else:
                reception.taux_change = 1.0

            reception.save()

            for ligne_form in formset:
                if ligne_form.cleaned_data.get('produit'):
                    ligne = ligne_form.save(commit=False)
                    ligne.reception = reception
                    ligne.save()

            messages.success(request, 'Réception créée avec succès!')
            return redirect('detail_reception', pk=reception.pk)
    else:
        form = ReceptionForm(initial={
            'devise': parametres.devise_principale,
        })
        formset = LigneFormSet()

    return render(request, 'stock/creer_reception.html', {
        'form': form,
        'formset': formset,
        'devises': parametres.devises_acceptees,
    })


@login_required
def modifier_reception(request, pk):
    reception = get_object_or_404(Reception, pk=pk)
    parametres = get_object_or_404(Parametre, user=request.user)
    LigneFormSet = formset_factory(LigneReceptionForm, extra=1)
    
    if reception.status != 'B':
        messages.error(request, "Seules les réceptions brouillon peuvent être modifiées")
        return redirect('detail_reception', pk=reception.pk)

    if request.method == 'POST':
        form = ReceptionForm(request.POST, instance=reception)
        formset = LigneFormSet(request.POST, prefix='lignes')
        
        if form.is_valid() and formset.is_valid():
            try:
                with transaction.atomic():
                    # Mise à jour des informations de base
                    reception = form.save(commit=False)
                    
                    # Gestion du taux de change
                    nouvelle_devise = form.cleaned_data.get('devise')
                    if nouvelle_devise != reception.devise:
                        taux = TauxChange.get_taux(nouvelle_devise, parametres.devise_principale)
                        if taux is None:
                            raise ValueError(f"Aucun taux de change disponible pour {nouvelle_devise} vers {parametres.devise_principale}")
                        reception.taux_change = taux
                    
                    reception.save()
                    
                    # Suppression des anciennes lignes
                    reception.lignes.all().delete()
                    
                    # Création des nouvelles lignes
                    for ligne_form in formset:
                        if ligne_form.cleaned_data.get('produit'):
                            ligne = ligne_form.save(commit=False)
                            ligne.reception = reception
                            ligne.save()
                    
                    messages.success(request, 'Réception modifiée avec succès!')
                    return redirect('detail_reception', pk=reception.pk)
            
            except Exception as e:
                messages.error(request, f"Erreur lors de la modification: {str(e)}")
                # On laisse le formulaire avec les données saisies pour correction
    else:
        form = ReceptionForm(instance=reception, initial={
            'devise': reception.devise,
            'taux_change': reception.taux_change
        })
        formset = LigneFormSet(
            prefix='lignes',
            initial=[
                {
                    'produit': l.produit, 
                    'quantite': l.quantite, 
                    'prix_unitaire': l.prix_unitaire,
                    'lot': l.lot, 
                    'date_peremption': l.date_peremption
                } for l in reception.lignes.all()
            ]
        )

    context = {
        'form': form,
        'formset': formset,
        'reception': reception,
        'devises': parametres.devises_acceptees,
        'devise_principale': parametres.devise_principale,
    }
    return render(request, 'stock/modifier_reception.html', context)

@login_required
def supprimer_reception(request, pk):
    reception = get_object_or_404(Reception, pk=pk)
    
    if request.method == 'POST':
        if reception.status != 'B':
            messages.error(request, "Seules les réceptions brouillon peuvent être supprimées")
        else:
            reception.delete()
            messages.success(request, 'Réception supprimée avec succès!')
        return redirect('liste_receptions')
    
    return render(request, 'stock/supprimer_reception.html', {'reception': reception})


@login_required
def detail_reception(request, pk):
    reception = get_object_or_404(Reception, pk=pk)
    parametres = Parametre.objects.first()

    devise_source = reception.devise
    devise_cible = parametres.devise_principale

    taux_change = TauxChange.get_taux(devise_source, devise_cible) or Decimal('1.0')

    # Préparer les montants convertis pour chaque ligne
    lignes_converties = []
    for ligne in reception.lignes.all():
        montant_origine = ligne.prix_unitaire * ligne.quantite
        montant_converti = parametres.convertir_en_devise_principale(montant_origine, devise_source)

        lignes_converties.append({
            'produit': ligne.produit,
            'quantite': ligne.quantite,
            'prix_unitaire': ligne.prix_unitaire,
            'montant_devise_origine': montant_origine,
            'montant_devise_principale': montant_converti,
        })

    # Totaux
    total_origine = sum(l['montant_devise_origine'] for l in lignes_converties)
    total_principale = sum(l['montant_devise_principale'] for l in lignes_converties)

    return render(request, 'stock/detail_reception.html', {
        'reception': reception,
        'parametres': parametres,
        'taux_change': taux_change,
        'lignes_converties': lignes_converties,
        'total_devise_origine': total_origine,
        'total_devise_principale': total_principale,
    })

@login_required
def valider_reception(request, pk):
    reception = get_object_or_404(Reception, pk=pk)
    if reception.status == 'B':
        reception.valider()
        messages.success(request, 'Réception validée avec succès!')
    else:
        messages.warning(request, 'Cette réception a déjà été traitée.')
    return redirect('detail_reception', pk=reception.pk)

@login_required
def generer_bon_reception(request, pk):
    reception = get_object_or_404(Reception, pk=pk)
    parametres = Parametre.objects.first()
    
    return render(request, 'stock/bon_reception.html', {
        'reception': reception,
        'parametres': parametres,
    })
    
    
# views.py (ou wherever se trouve ta vue manual_backup)
import os
import json
import io
import zipfile
from datetime import datetime
from django.conf import settings
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from django.core.management import call_command

@csrf_exempt
def manual_backup(request):
    if request.method == 'POST':
        try:
            # Créer le répertoire de sauvegarde s’il n'existe pas
            backup_dir = settings.BACKUP_DIR
            os.makedirs(backup_dir, exist_ok=True)

            # Nom du fichier de sauvegarde
            now = datetime.now().strftime("%Y%m%d_%H%M%S")
            backup_filename = f"backup_{now}.zip"
            backup_path = os.path.join(backup_dir, backup_filename)

            # Buffer pour les données JSON
            json_buffer = io.StringIO()

            # Exécuter dumpdata en excluant django_apscheduler
            call_command('dumpdata',
                         '--natural-foreign',
                         '--natural-primary',
                         '--indent', '2',
                         '--exclude', 'django_apscheduler',
                         stdout=json_buffer)

            json_data = json_buffer.getvalue().encode('utf-8')

            # Créer le fichier zip contenant le dump
            with zipfile.ZipFile(backup_path, 'w', zipfile.ZIP_DEFLATED) as zip_file:
                zip_file.writestr('backup.json', json_data)

            return JsonResponse({
                'status': 'success',
                'message': 'Sauvegarde créée avec succès',
                'filename': backup_filename
            })

        except Exception as e:
            return JsonResponse({
                'status': 'error',
                'message': str(e)
            }, status=500)

    return JsonResponse({'error': 'Méthode non autorisée'}, status=405)


@csrf_exempt
def restore_backup(request):
    if request.method == 'POST':
        filename = request.POST.get('filename')
        if not filename:
            return JsonResponse({'status': 'error', 'message': 'Nom de fichier manquant'}, status=400)

        backup_path = os.path.join(settings.BACKUP_DIR, filename)
        if not os.path.exists(backup_path):
            return JsonResponse({'status': 'error', 'message': 'Fichier introuvable'}, status=404)

        try:
            call_command('loaddata', backup_path)
            return JsonResponse({'status': 'success', 'message': 'Sauvegarde restaurée avec succès'})
        except Exception as e:
            return JsonResponse({'status': 'error', 'message': str(e)}, status=500)

from django.shortcuts import render

def home(request):
    return render(request, 'home.html')  # Crée un fichier home.html simple pour l’instant


@login_required
def backup_management(request):
    if not request.user.is_superuser:
        return HttpResponseForbidden("Accès réservé aux administrateurs")

    try:
        backup_dir = os.path.join(settings.BASE_DIR, 'backups')
        if not os.path.exists(backup_dir):
            os.makedirs(backup_dir)

        backups = []
        for filename in os.listdir(backup_dir):
            if filename.endswith('.zip'):
                filepath = os.path.join(backup_dir, filename)
                stat = os.stat(filepath)

                backups.append({
                    'filename': filename,
                    'path': filepath,
                    'size': stat.st_size,
                    'date': stat.st_mtime,
                    'human_size': sizeof_fmt(stat.st_size),
                    'formatted_date': datetime.fromtimestamp(stat.st_mtime).strftime("%d/%m/%Y %H:%M")
                })

        backups.sort(key=lambda x: x['date'], reverse=True)

        return render(request, 'backup/backup_management.html', {
            'backups': backups,
            'backup_dir': backup_dir,
            'title': 'Gestion des sauvegardes'
        })

    except Exception as e:
        logger.error(f"Erreur dans backup_management : {str(e)}")
        return render(request, 'backup/backup_management.html', {
            'backups': [],
            'error': str(e)
        })


@login_required
def download_backup(request, filename):
    if not request.user.is_superuser:
        return JsonResponse({'status': 'error', 'message': 'Permission refusée'}, status=403)

    backup_path = os.path.join(settings.BASE_DIR, 'backups', filename)
    if not os.path.exists(backup_path):
        return JsonResponse({'status': 'error', 'message': 'Fichier non trouvé'}, status=404)

    response = FileResponse(open(backup_path, 'rb'))
    response['Content-Disposition'] = f'attachment; filename="{filename}"'
    return response


@login_required
def delete_backup(request):
    if not request.user.is_superuser:
        return JsonResponse({'status': 'error', 'message': 'Permission refusée'}, status=403)

    filename = request.GET.get('filename')
    if not filename:
        return JsonResponse({'status': 'error', 'message': 'Nom de fichier manquant'}, status=400)

    backup_path = os.path.join(settings.BASE_DIR, 'backups', filename)
    if not os.path.exists(backup_path):
        return JsonResponse({'status': 'error', 'message': 'Fichier non trouvé'}, status=404)

    try:
        os.remove(backup_path)
        return JsonResponse({'status': 'success', 'message': 'Sauvegarde supprimée'})
    except Exception as e:
        return JsonResponse({'status': 'error', 'message': str(e)}, status=500)


def sizeof_fmt(num, suffix='o'):
    """Convertit une taille en format lisible (Ko, Mo, Go, etc.)"""
    for unit in ['','K','M','G','T','P','E','Z']:
        if abs(num) < 1024.0:
            return "%3.1f %s%s" % (num, unit, suffix)
        num /= 1024.0
    return "%.1f %s%s" % (num, 'Y', suffix)

